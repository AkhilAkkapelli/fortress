// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.1,
// (C) 2004-2008 Robert Grimm,
// on Thursday, October 11, 2018 at 3:24:59 AM.
// Edit at your own risk.
// ===========================================================================

package com.sun.fortress.parser.templateparser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import com.sun.fortress.exceptions.ProgramError;
import com.sun.fortress.repository.ProjectProperties;
import com.sun.fortress.parser_util.precedence_opexpr.*;
import com.sun.fortress.parser_util.precedence_resolver.*;
import com.sun.fortress.nodes.*;
import com.sun.fortress.nodes_util.*;
import com.sun.fortress.parser_util.*;
import com.sun.fortress.useful.PureList;
import com.sun.fortress.useful.Empty;
import com.sun.fortress.useful.Cons;
import com.sun.fortress.useful.Useful;
import com.sun.fortress.Shell;
import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.iter.IterUtil;
import edu.rice.cs.plt.collect.CollectUtil;
import xtc.util.Action;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;


import static com.sun.fortress.exceptions.ProgramError.errorMsg;
import static com.sun.fortress.exceptions.ProgramError.error;

/**
 * Packrat parser for grammar <code>com.sun.fortress.parser.templateparser.TemplateParser</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.1, (C) 2004-2008 Robert Grimm.
 */
public final class TemplateParser extends ParserBase {

  /** The isNative flag. */
  public static final boolean isNative = true;

  /** The FORTRESS_SYNTAX_SPECIAL_SYMBOLS set. */
  public static final Set<String> FORTRESS_SYNTAX_SPECIAL_SYMBOLS = new HashSet<String>();

  /** The FORTRESS_SYNTAX_SPECIAL_CHARS set. */
  public static final Set<String> FORTRESS_SYNTAX_SPECIAL_CHARS = new HashSet<String>();

  /** The FORTRESS_KEYWORDS set. */
  public static final Set<String> FORTRESS_KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fImportOrExports;
    Result fImportOrExports$$Star1;
    Result fImportOrExport;
    Result fForeignLang;
    Result fAliasedSimpleName;
    Result fAliasedQualifiedName;
    Result fAliasedAPIName;
    Result fAPINames;
    Result fAPINames$$Plus1;
    Result fAPINames$$Plus2;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fDecls;
    Result fDecls$$Star1;
    Result fDecl;
    Result fAbsDecls;
    Result fAbsDecls$$Star1;
    Result fAbsDecl;
    Result fTraitHeaderFront;
    Result fTraitValParam;
    Result fTraitClause;
    Result fGoesInATrait;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fObjectHeader;
    Result fObjectValParam;
    Result fGoInAnObject;
    Result fGoInAnObject$$Star1;
    Result fGoesInAnObject;
    Result f$$Shared3;
    Result fAbsFnDecl;
    Result fFnHeaderFront;
    Result fMdDecl;
    Result fCoercion;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fVarDecl;
    Result fVariable$VarMayType;
    Result fInitVal;
    Result fAbsVarDecl;
    Result fPattern;
    Result f$$Shared49;
    Result f$$Shared50;
    Result fTypeOrPattern;
    Result fIsTypeOrPattern;
    Result fNoNewlinePattern;
  }

  /** Chunk 5 of memoized results. */
  static final class Chunk5 {
    Result fIsType;
    Result fOpBool;
    Result fBoolPrimary;
    Result fBoolPrefix;
    Result fStaticArgs;
    Result fStaticArg;
    Result fExtendsWhere;
    Result fExtendsWhere$$Star1;
    Result fTraitTypeWhere;
    Result fExtends;
  }

  /** Chunk 6 of memoized results. */
  static final class Chunk6 {
    Result fTraitTypes;
    Result fTraitTypes$$Star1;
    Result fComprisingTypeList;
    Result fComprisingTypeList$$Star1;
    Result fComprisingTypeWithError;
    Result fFnHeaderClause;
    Result fFnClauses;
    Result fFnClauses$$Star1;
    Result fThrows;
    Result fStaticParams;
  }

  /** Chunk 7 of memoized results. */
  static final class Chunk7 {
    Result fStaticParams$$Star1;
    Result fStaticParam;
    Result fDimUnitDecl;
    Result f$$Shared52;
    Result fDimUnitDecl$$Star1;
    Result fDimUnitDecl$$Star2;
    Result fTypeAlias;
    Result fTestDecl;
    Result fPropertyDecl;
    Result fNonterminalDecl;
  }

  /** Chunk 8 of memoized results. */
  static final class Chunk8 {
    Result fNonterminalHeader;
    Result fSyntax$Param;
    Result fSyntaxDef;
    Result fSyntaxExtensionDef;
    Result fPreTransformer;
    Result fCaseTransformerClause;
    Result fSymbs;
    Result fSymbs$$Plus1;
    Result fSyntaxSymbol;
    Result fSymbolMod;
  }

  /** Chunk 9 of memoized results. */
  static final class Chunk9 {
    Result fSingle;
    Result fChar;
    Result futf16;
    Result fSpecialChars;
    Result fSpecialSymbols;
    Result fType$Type;
    Result fType$OpType;
    Result fType$TypePrimary;
    Result fType$TypePrefix;
    Result fType$TypeFront;
  }

  /** Chunk 10 of memoized results. */
  static final class Chunk10 {
    Result fType$ParenthesizedType;
    Result fType$KeywordType;
    Result fType$TupleType;
    Result f$$Shared26;
    Result f$$Shared8;
    Result fType$ArraySize;
    Result fType$ArraySize$$Star1;
    Result fType$ExtentRange;
    Result f$$Shared10;
    Result f$$Shared11;
  }

  /** Chunk 11 of memoized results. */
  static final class Chunk11 {
    Result f$$Shared12;
    Result f$$Shared13;
    Result fType$TraitType;
    Result fType$TraitType$$Plus1;
    Result f$$Shared14;
    Result fNoNewlineType$Type;
    Result fNoNewlineType$OpType;
    Result fNoNewlineType$TypePrimary;
    Result fNoNewlineType$TypePrefix;
    Result fNoNewlineType$TypeFront;
  }

  /** Chunk 12 of memoized results. */
  static final class Chunk12 {
    Result fNoNewlineType$ParenthesizedType;
    Result fNoNewlineType$KeywordType;
    Result fNoNewlineType$TupleType;
    Result fNoNewlineType$ArraySize;
    Result fNoNewlineType$ArraySize$$Star1;
    Result fNoNewlineType$ExtentRange;
    Result fNoNewlineType$TraitTypeWithError;
    Result fNoNewlineType$TraitTypeWithError$$Plus1;
    Result fNoNewlineType$TypeRefWithError;
    Result fNoNewlineTupleType;
  }

  /** Chunk 13 of memoized results. */
  static final class Chunk13 {
    Result fNoNewlineExtentRange;
    Result fNoNewlineType;
    Result fExpression$Expr;
    Result f$$Shared53;
    Result fExpression$AssignExpr;
    Result f$$Shared36;
    Result f$$Shared36$$Star1;
    Result f$$Shared32;
    Result f$$Shared32$$Plus1;
    Result fExpression$OpExpr;
  }

  /** Chunk 14 of memoized results. */
  static final class Chunk14 {
    Result fExpression$OpExprNoEnc;
    Result fExpression$LeftLooseInfix;
    Result fExpression$OpExprLeftEncloser;
    Result fExpression$OpExprPrimary;
    Result fExpression$OpExprPrefix;
    Result fExpression$LooseInfix;
    Result f$$Shared42;
    Result f$$Shared42$$Plus1;
    Result f$$Shared41;
    Result f$$Shared29;
  }

  /** Chunk 15 of memoized results. */
  static final class Chunk15 {
    Result f$$Shared20;
    Result f$$Shared22;
    Result fExpression$AtomicBack;
    Result fExpression$GeneratorClauseList;
    Result fExpression$GeneratorClauseList$$Star1;
    Result fExpression$GeneratorBinding;
    Result fExpression$GeneratorClause;
    Result fDelimitedExpr;
    Result f$$Shared55;
    Result f$$Shared56;
  }

  /** Chunk 16 of memoized results. */
  static final class Chunk16 {
    Result fDo;
    Result fDo$$Star1;
    Result fDoFront;
    Result fArgExpr;
    Result fArgExpr$$Star1;
    Result fArgExpr$$Star2;
    Result fKeywordExpr;
    Result fParenthesized;
    Result fElifs;
    Result fElifs$$Star1;
  }

  /** Chunk 17 of memoized results. */
  static final class Chunk17 {
    Result fElif;
    Result fElse;
    Result fCaseClauses;
    Result fCaseClauses$$Star1;
    Result fCaseElse;
    Result fTypecaseClauses;
    Result fTypecaseClauses$$Star1;
    Result fTypecaseClause;
    Result fCatchClause;
    Result fEntry;
  }

  /** Chunk 18 of memoized results. */
  static final class Chunk18 {
    Result fIdOrInt;
    Result fIdOrIntList;
    Result fIdOrIntList$$Plus1;
    Result fIdOrIntList$$Plus2;
    Result fExprList;
    Result fExprList$$Star1;
    Result fNoNewlineExpr$Expr;
    Result fNoNewlineExpr$Expr$$Star1;
    Result fNoNewlineExpr$OpExpr;
    Result fNoNewlineExpr$OpExprNoEnc;
  }

  /** Chunk 19 of memoized results. */
  static final class Chunk19 {
    Result fNoNewlineExpr$LeftLooseInfix;
    Result fNoNewlineExpr$OpExprLeftEncloser;
    Result fNoNewlineExpr$OpExprPrimary;
    Result fNoNewlineExpr$OpExprPrefix;
    Result fNoNewlineExpr$LooseInfix;
    Result fNoNewlineExpr$AtomicBack;
    Result fNoNewlineExpr$GeneratorClauseList;
    Result fNoNewlineExpr$GeneratorClauseList$$Star1;
    Result fNoNewlineExpr$GeneratorBinding;
    Result fNoNewlineExpr;
  }

  /** Chunk 20 of memoized results. */
  static final class Chunk20 {
    Result fNoNewlineVarWTypes;
    Result fNoNewlineVarWTypes$$Plus1;
    Result fNoNewlineVarWType;
    Result fNoSpaceExpr$Expr;
    Result fNoSpaceExpr$ExprFront;
    Result fNoSpaceExpr$OpExprNoEnc;
    Result fNoSpaceExpr$OpExprLeftEncloser;
    Result fNoSpaceExpr$OpExprPrimary;
    Result fNoSpaceExpr$OpExprPrefix;
    Result fNoSpaceExpr;
  }

  /** Chunk 21 of memoized results. */
  static final class Chunk21 {
    Result fLiteralExpr;
    Result fNumericLiteralExpr;
    Result fNumericLiteralExpr$$Star1;
    Result fStringLiteralExpr;
    Result fStringLiteralExpr$$Star1;
    Result fStringLiteralExpr$$Star2;
    Result fStringLiteralExpr$$Star3;
    Result fStringLiteralExpr$$Star4;
    Result fStringLiteralContent;
    Result fEscapeSequence;
  }

  /** Chunk 22 of memoized results. */
  static final class Chunk22 {
    Result fCharLiteralContent;
    Result f$$Shared57;
    Result fUnicodeCharLiteralContent;
    Result fUnicodeHexChar;
    Result fUnicodeHexChar$$Plus1;
    Result fUnicodeHexChar$$Plus2;
    Result fUnicodeHexChar$$Plus3;
    Result fBlockElems;
    Result fBlockElemCollection;
    Result f$$Shared58;
  }

  /** Chunk 23 of memoized results. */
  static final class Chunk23 {
    Result fLocalFnDecl;
    Result fLocalDecl$VarMayType;
    Result fVarWoTypes;
    Result fVarWoTypes$$Plus1;
    Result fVarWoType;
    Result fNoNewlineVarWTypeOrPattern;
    Result fUnpasting;
    Result fUnpastingElems;
    Result fCaseClause;
    Result fReserved;
  }

  /** Chunk 24 of memoized results. */
  static final class Chunk24 {
    Result fId;
    Result fBindId;
    Result fBindIdList;
    Result fBindIdList$$Plus1;
    Result fBindIdList$$Plus2;
    Result fBindIdOrBindIdTuple;
    Result fSimpleName;
    Result fidOrKeyword;
    Result fidOrKeyword$$Star1;
    Result fAPIName;
  }

  /** Chunk 25 of memoized results. */
  static final class Chunk25 {
    Result fAPIName$$Star1;
    Result fQualifiedName;
    Result fQualifiedName$$Star1;
    Result fEncloser;
    Result fLeftEncloser;
    Result fRightEncloser;
    Result fExponentOp;
    Result fEncloserPair;
    Result fOpName;
    Result fOp;
  }

  /** Chunk 26 of memoized results. */
  static final class Chunk26 {
    Result fmultiOp;
    Result fop;
    Result fArrayComprehensionClause;
    Result fComment;
    Result fNoNewlineComment;
    Result fParamList;
    Result fParamList$$Plus1;
    Result fParamList$$Plus2;
    Result fprefix;
    Result fsuffix;
  }

  /** Chunk 27 of memoized results. */
  static final class Chunk27 {
    Result fExprGap;
    Result fFnExprGap;
    Result fLooseJuxtGap;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class TemplateParserColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
    Chunk5 chunk5;
    Chunk6 chunk6;
    Chunk7 chunk7;
    Chunk8 chunk8;
    Chunk9 chunk9;
    Chunk10 chunk10;
    Chunk11 chunk11;
    Chunk12 chunk12;
    Chunk13 chunk13;
    Chunk14 chunk14;
    Chunk15 chunk15;
    Chunk16 chunk16;
    Chunk17 chunk17;
    Chunk18 chunk18;
    Chunk19 chunk19;
    Chunk20 chunk20;
    Chunk21 chunk21;
    Chunk22 chunk22;
    Chunk23 chunk23;
    Chunk24 chunk24;
    Chunk25 chunk25;
    Chunk26 chunk26;
    Chunk27 chunk27;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public TemplateParser(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public TemplateParser(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new TemplateParserColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.File.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFile(final int yyStart) throws IOException {
    Result          yyResult;
    CompilationUnit yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pProgram(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pcloseParser(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.closeParser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcloseParser(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pEndOfFile(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        try {
          writer.close();
        } catch (IOException error) {
          error("Closing a log file for the parser failed!");
        }

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Program.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProgram(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    Object          yyOpValue1;
    CompilationUnit yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCompilationUnit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      String file = span.getBegin().getFileName();
      String cuname = yyValue.getName().toString();
      if (!Shell.checkCompilationUnitName(file, cuname))
      log(NodeUtil.getSpan(yyValue.getName()),
      "    Component/API names must match their enclosing file names." +
      "\n    File name: " + file +
      "\n    Component/API name: " + cuname);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pImportOrExports(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      com.sun.fortress.useful.Pair<List<Import>,List<APIName>> a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDecls(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Decl> a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = psemicolon(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }
          }

          Span span = createSpan(yyStart,yyCount);
          String file = span.begin.getFileName();
          APIName name = NodeFactory.makeAPINameFromPath(writer, span, file, "\\.");
          List<Import>  imports = a1.getA();
          List<APIName> exports = a1.getB();
          if ( ! exports.isEmpty() )
          yyValue = NodeFactory.makeComponent(span, name, imports, a2, exports);
          // already checked that file.length() > 4 by NodeFactory.makeAPINameFromPath
          else if ( file.substring( file.length()-3).equals("fsi") ) {
            yyValue = NodeFactory.makeApi(span, name, imports, a2);
          } else {
            log(span, "Components should have at least one export statement.");
            yyValue = NodeFactory.makeComponent(span, name, imports, a2,
            Collections.<APIName>emptyList());
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pProgram$$Choice1(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Decl> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for a2.
        List<Decl> a2 = cast(yyOpValue1);

        if (a2 == null) a2 = Collections.<Decl>emptyList();
        Span span = createSpan(yyStart,yyCount);
        String file = span.begin.getFileName();
        APIName name = NodeFactory.makeAPINameFromPath(writer, span, file, "\\.");
        if ( ! a1.getB().isEmpty() )
        log(span, "APIs should not have export statements.");
        yyValue = NodeFactory.makeApi(span, name, a1.getA(), a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 3.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pProgram$$Choice2(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      com.sun.fortress.useful.Pair<List<Import>,List<APIName>> v$el$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$2;
    }
    { // Start scope for a1.
      com.sun.fortress.useful.Pair<List<Import>,List<APIName>> a1 = cast(yyOpValue1);

      yyResult = pAbsDecls(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Decl> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = psemicolon(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }
        }

        List<Import> imports = (a1 == null) ? Collections.<Import>emptyList()
        : a1.getA();
        Span span = createSpan(yyStart,yyCount);
        String file = span.begin.getFileName();
        APIName name = NodeFactory.makeAPINameFromPath(writer, span, file, "\\.");
        if ( a1 != null && ! a1.getB().isEmpty() )
        log(span, "APIs should not have export statements.");
        yyValue = NodeFactory.makeApi(span, name, imports, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Program$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProgram$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pAbsDecls(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyOption1  = yyResult.index;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = psemicolon(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }
        }

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Program$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProgram$$Choice2(final int yyStart) throws IOException {
    Result                                                   yyResult;
    int                                                      yyOption1;
    com.sun.fortress.useful.Pair<List<Import>,List<APIName>> yyValue;
    ParseError                                               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pImportOrExports(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyOption1  = yyResult.index;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.CompilationUnit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompilationUnit(final int yyStart) throws IOException {
    Result          yyResult;
    CompilationUnit yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComponent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pApi(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Component.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComponent(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    int        yyOption2;
    Component  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pnative(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      yyResult = pcomponent(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pAPIName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            APIName a2 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pw(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomprises(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pAPINames(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<APIName> a3 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = p$$Shared43(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      com.sun.fortress.useful.Pair<List<Import>,List<APIName>> v$el$2 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$2;
                    }
                    { // Start scope for a4.
                      com.sun.fortress.useful.Pair<List<Import>,List<APIName>> a4 = cast(yyOpValue1);

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyOption1  = yyResult.index;
                        yyOpValue1 = null;

                        yyResult = p$$Shared44(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          List<Decl> v$el$3 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$3;
                        }
                        { // Start scope for a5.
                          List<Decl> a5 = cast(yyOpValue1);

                          yyResult = pw(yyOption1);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pend(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyOption1  = yyResult.index;
                              yyOpValue1 = null;

                              yyOption2  = yyOption1;

                              yyResult = ps(yyOption2);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pcomponent(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyOption2  = yyResult.index;
                                }
                              }

                              yyResult = ps(yyOption2);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pAPIName(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  APIName v$el$4 = yyResult.semanticValue();

                                  yyOption1  = yyResult.index;
                                  yyOpValue1 = v$el$4;
                                }
                              }
                              { // Start scope for a6.
                                APIName a6 = cast(yyOpValue1);

                                Span span = createSpan(yyStart,yyCount);
                                if (a6 != null && !NodeUtil.nameString(a6).equals(NodeUtil.nameString(a2)))
                                log(span, "A component declaration of " + a2 +
                                " has the different name " + a6 + " at the end.");
                                if ( a5 != null)
                                log(span, "Compound component " + a2 + " should not include new declarations.");
                                List<Import>  imports = ( a4 == null ) ? Collections.<Import>emptyList()
                                : a4.getA();
                                List<APIName> exports = ( a4 == null ) ? Collections.<APIName>emptyList()
                                : a4.getB();
                                List<Decl>    decls   = Collections.<Decl>emptyList();
                                if (a1 == null)
                                yyValue = NodeFactory.makeComponent(span, a2, imports, decls, a3, false, exports);
                                else
                                yyValue = NodeFactory.makeComponent(span, a2, imports, decls, a3, true, exports);

                                return new SemanticValue(yyValue, yyOption1, yyError);
                              } // End scope for a6.
                            }
                          }
                        } // End scope for a5.
                      }
                    } // End scope for a4.
                  }
                }
              }
            }

            // Nested alternative 2.

            yyOption1  = yyChoice1;
            yyOpValue1 = null;

            yyResult = p$$Shared43(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              com.sun.fortress.useful.Pair<List<Import>,List<APIName>> v$el$5 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$5;
            }
            { // Start scope for a3.
              com.sun.fortress.useful.Pair<List<Import>,List<APIName>> a3 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = p$$Shared44(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Decl> v$el$6 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$6;
                }
                { // Start scope for a4.
                  List<Decl> a4 = cast(yyOpValue1);

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pend(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyOption2  = yyOption1;

                      yyResult = ps(yyOption2);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pcomponent(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyOption2  = yyResult.index;
                        }
                      }

                      yyResult = ps(yyOption2);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pAPIName(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          APIName v$el$7 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$7;
                        }
                      }
                      { // Start scope for a5.
                        APIName a5 = cast(yyOpValue1);

                        Span span = createSpan(yyStart,yyCount);
                        if ( a3 == null ||
                        a3 != null && a3.getB().isEmpty() )
                        log(span, "Components should have at least one export statement.");
                        if (a5 != null && !NodeUtil.nameString(a5).equals(NodeUtil.nameString(a2)))
                        log(span, "A component declaration of " + a2 +
                        " has the different name " + a5 + " at the end.");
                        List<Import>  imports = ( a3 == null ) ? Collections.<Import>emptyList()
                        : a3.getA();
                        List<APIName> exports = ( a3 == null ) ? Collections.<APIName>emptyList()
                        : a3.getB();
                        if (a4 == null) a4 = Collections.<Decl>emptyList();
                        if (a1 == null)
                        yyValue = NodeFactory.makeComponent(span, a2, imports, a4, exports);
                        else
                        yyValue = NodeFactory.makeComponent(span, a2, imports, a4, true, exports);

                        return new SemanticValue(yyValue, yyOption1, yyError);
                      } // End scope for a5.
                    }
                  }
                } // End scope for a4.
              }
            } // End scope for a3.
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared43.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.Component$$Choice1, 
   * com.sun.fortress.parser.templateparser.TemplateParser.Component$$Choice3, 
   * com.sun.fortress.parser.templateparser.TemplateParser.Api$$Choice1, 
   * and com.sun.fortress.parser.templateparser.TemplateParser.Api$$Choice3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared43(final int yyStart) throws IOException {
    Result                                                   yyResult;
    int                                                      yyOption1;
    com.sun.fortress.useful.Pair<List<Import>,List<APIName>> yyValue;
    ParseError                                               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pImportOrExports(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyOption1  = yyResult.index;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = psemicolon(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }
        }

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared44.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.Component$$Choice2 
   * and com.sun.fortress.parser.templateparser.TemplateParser.Component$$Choice4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared44(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDecls(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyOption1  = yyResult.index;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = psemicolon(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }
        }

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Api.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pApi(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    int        yyOption2;
    Api        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pnative(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a0.
      String a0 = cast(yyOpValue1);

      yyResult = papi(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pAPIName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            APIName a1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pw(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomprises(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pAPINames(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<APIName> a2 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = p$$Shared43(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      com.sun.fortress.useful.Pair<List<Import>,List<APIName>> v$el$2 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$2;
                    }
                    { // Start scope for a3.
                      com.sun.fortress.useful.Pair<List<Import>,List<APIName>> a3 = cast(yyOpValue1);

                      yyOpValue1 = null;

                      yyResult = p$$Shared45(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        List<Decl> v$el$3 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$3;
                      }
                      { // Start scope for a4.
                        List<Decl> a4 = cast(yyOpValue1);

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pend(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyOption1  = yyResult.index;
                            yyOpValue1 = null;

                            yyOption2  = yyOption1;

                            yyResult = ps(yyOption2);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = papi(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyOption2  = yyResult.index;
                              }
                            }

                            yyResult = ps(yyOption2);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pAPIName(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {
                                APIName v$el$4 = yyResult.semanticValue();

                                yyOption1  = yyResult.index;
                                yyOpValue1 = v$el$4;
                              }
                            }
                            { // Start scope for a5.
                              APIName a5 = cast(yyOpValue1);

                              Span span = createSpan(yyStart,yyCount);
                              if ( a0 != null )
                              log(span, "The native modifier is only for components not for APIs.");
                              if ( a5 != null && !NodeUtil.nameString(a5).equals(NodeUtil.nameString(a1)) )
                              log(span, "An API declaration of " + a1 +
                              " has the different name " + a5 + " at the end.");
                              if (a3 != null || a4 != null)
                              log(span, "Compound API " + a1 + " should not include new declarations.");
                              yyValue = NodeFactory.makeApi(span, a1, Collections.<Import>emptyList(),
                              Collections.<Decl>emptyList(), a2);

                              return new SemanticValue(yyValue, yyOption1, yyError);
                            } // End scope for a5.
                          }
                        }
                      } // End scope for a4.
                    } // End scope for a3.
                  }
                }
              }
            }

            // Nested alternative 2.

            yyOption1  = yyChoice1;
            yyOpValue1 = null;

            yyResult = p$$Shared43(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              com.sun.fortress.useful.Pair<List<Import>,List<APIName>> v$el$5 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$5;
            }
            { // Start scope for a2.
              com.sun.fortress.useful.Pair<List<Import>,List<APIName>> a2 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = p$$Shared45(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Decl> v$el$6 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$6;
              }
              { // Start scope for a3.
                List<Decl> a3 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pend(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyOption2  = yyOption1;

                    yyResult = ps(yyOption2);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = papi(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyOption2  = yyResult.index;
                      }
                    }

                    yyResult = ps(yyOption2);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pAPIName(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        APIName v$el$7 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$7;
                      }
                    }
                    { // Start scope for a4.
                      APIName a4 = cast(yyOpValue1);

                      Span span = createSpan(yyStart,yyCount);
                      if ( a0 != null )
                      log(span, "The native modifier is only for components not for APIs.");
                      if ( a4 != null && !NodeUtil.nameString(a4).equals(NodeUtil.nameString(a1)) )
                      log(span, "An API declaration of " + a1 +
                      " has the different name " + a4 + " at the end.");
                      if ( a2 != null && ! a2.getB().isEmpty() )
                      log(span, "APIs should not have export statements.");
                      List<Import> imports = (a2 == null) ? Collections.<Import>emptyList()
                      : a2.getA();
                      if (a3 == null) a3 = Collections.<Decl>emptyList();
                      yyValue = NodeFactory.makeApi(span, a1, imports, a3);

                      return new SemanticValue(yyValue, yyOption1, yyError);
                    } // End scope for a4.
                  }
                }
              } // End scope for a3.
            } // End scope for a2.
          }
        }
      }
    } // End scope for a0.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared45.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.Api$$Choice2 
   * and com.sun.fortress.parser.templateparser.TemplateParser.Api$$Choice4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared45(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pAbsDecls(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyOption1  = yyResult.index;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = psemicolon(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }
        }

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ImportOrExports.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportOrExports(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImportOrExports) 
      yyColumn.chunk1.fImportOrExports = pImportOrExports$1(yyStart);
    return yyColumn.chunk1.fImportOrExports;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.ImportOrExports. */
  private Result pImportOrExports$1(final int yyStart) throws IOException {
    Result                                                   yyResult;
    com.sun.fortress.useful.Pair<List<Import>,List<APIName>> yyValue;
    ParseError                                               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pImportOrExport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      com.sun.fortress.useful.Pair<List<Import>,List<APIName>> a1 = yyResult.semanticValue();

      yyResult = pImportOrExports$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<com.sun.fortress.useful.Pair<List<Import>,List<APIName>>> a2s = yyResult.semanticValue();

        List<Import>  imports = a1.getA();
        List<APIName> exports = a1.getB();
        for ( com.sun.fortress.useful.Pair<List<Import>,List<APIName>> pair : a2s.list()) {
          imports.addAll(pair.getA());
          exports.addAll(pair.getB());
        }
        yyValue = new com.sun.fortress.useful.Pair<List<Import>,List<APIName>>(imports, exports);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ImportOrExports$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportOrExports$$Star1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImportOrExports$$Star1) 
      yyColumn.chunk1.fImportOrExports$$Star1 = pImportOrExports$$Star1$1(yyStart);
    return yyColumn.chunk1.fImportOrExports$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.ImportOrExports$$Star1. */
  private Result pImportOrExports$$Star1$1(final int yyStart) 
    throws IOException {

    Result                                                         yyResult;
    Pair<com.sun.fortress.useful.Pair<List<Import>,List<APIName>>> yyValue;
    ParseError                                                     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pImportOrExport(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        com.sun.fortress.useful.Pair<List<Import>,List<APIName>> v$el$1 = yyResult.semanticValue();

        yyResult = pImportOrExports$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<com.sun.fortress.useful.Pair<List<Import>,List<APIName>>> v$2 = yyResult.semanticValue();

          yyValue = new Pair<com.sun.fortress.useful.Pair<List<Import>,List<APIName>>>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ImportOrExport.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportOrExport(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImportOrExport) 
      yyColumn.chunk1.fImportOrExport = pImportOrExport$1(yyStart);
    return yyColumn.chunk1.fImportOrExport;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.ImportOrExport. */
  private Result pImportOrExport$1(final int yyStart) throws IOException {
    Result                                                   yyResult;
    com.sun.fortress.useful.Pair<List<Import>,List<APIName>> yyValue;
    ParseError                                               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pImport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Import> a1 = yyResult.semanticValue();

      yyValue = new com.sun.fortress.useful.Pair<List<Import>,List<APIName>>(Useful.list(a1),
      new ArrayList<APIName>());

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<APIName> a1 = yyResult.semanticValue();

      yyValue = new com.sun.fortress.useful.Pair<List<Import>,List<APIName>>(new ArrayList<Import>(),
      Useful.list(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImport(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    String       yyOpValue1;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pimport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pForeignLang(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a1.
        String a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = papi(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAliasedAPINames(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<AliasedAPIName> a2 = yyResult.semanticValue();

                Option<String> f = ( a1 == null ) ? Option.<String>none()
                : Option.<String>some(a1);
                yyValue = Useful.list((Import)NodeFactory.makeImportApi(createSpan(yyStart,yyCount),
                f, a2));

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      } // End scope for a1.

      // Nested alternative 2.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pImportedNames(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ForeignLang.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pForeignLang(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fForeignLang) 
      yyColumn.chunk1.fForeignLang = pForeignLang$1(yyStart);
    return yyColumn.chunk1.fForeignLang;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.ForeignLang. */
  private Result pForeignLang$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pId(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredResult = pw(yyPredResult.index);
      if (yyPredResult.hasValue()) {

        yyPredResult = pdot(yyPredResult.index);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }
      }
    }

    if (! yyPredMatched) {

      yyResult = pId(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a1 = yyResult.semanticValue();

        yyValue = a1.getText();

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("foreign lang expected", yyStart);
    }

    // Alternative 2.

    yyResult = pStringLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StringLiteralExpr a1 = yyResult.semanticValue();

      yyValue = a1.getText();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ImportedNames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportedNames(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pForeignLang(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      yyResult = pAPIName(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        APIName a2 = yyResult.semanticValue();

        yyResult = pdot(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popencurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pellipses(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pexcept(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pSimpleNames(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              List<IdOrOpOrAnonymousName> v$el$2 = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$2;
                            }
                          }
                        }
                      }
                      { // Start scope for a3.
                        List<IdOrOpOrAnonymousName> a3 = cast(yyOpValue1);

                        Option<String> f = ( a1 == null ) ? Option.<String>none()
                        : Option.<String>some(a1);
                        if (a3 == null) a3 = Collections.<IdOrOpOrAnonymousName>emptyList();
                        yyValue = Useful.list((Import)NodeFactory.makeImportStar(createSpan(yyStart,yyCount),
                        f, a2, a3));

                        return new SemanticValue(yyValue, yyOption1, yyError);
                      } // End scope for a3.
                    }
                  }
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pForeignLang(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAPIName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          APIName a2 = yyResult.semanticValue();

          yyResult = pdot(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = popencurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pAliasedQualifiedNameList(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<AliasedSimpleName> a3 = yyResult.semanticValue();

                    final int yyChoice1 = yyResult.index;

                    // Nested alternative 1.

                    yyOption1  = yyChoice1;
                    yyOpValue1 = null;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pcomma(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pellipses(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            String v$el$3 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;
                            yyOpValue1 = v$el$3;
                          }
                        }
                      }
                    }
                    { // Start scope for a4.
                      String a4 = cast(yyOpValue1);

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pclosecurly(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          Option<String> f = Option.<String>some(a1);
                          Span span = createSpan(yyStart,yyCount);
                          List<Import> imports = Useful.list((Import)NodeFactory.makeImportNames(span, f, a2, a3));
                          if (a4 != null)
                          imports.add((Import)NodeFactory.makeImportStar(span, f, a2,
                          Collections.<IdOrOpOrAnonymousName>emptyList()));
                          yyValue = imports;

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    } // End scope for a4.

                    // Nested alternative 2.

                    yyResult = pw(yyChoice1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pellipses(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pclosecurly(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            log(createSpan(yyStart,yyCount), "Missing comma.");
                            yyValue = Collections.<Import>emptyList();

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 3.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pForeignLang(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$4 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$4;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pAPIName(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        APIName a2 = yyResult.semanticValue();

        yyResult = pdot(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popencurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pAliasedSimpleNameList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<AliasedSimpleName> a3 = yyResult.semanticValue();

                  final int yyChoice2 = yyResult.index;

                  // Nested alternative 1.

                  yyOption1  = yyChoice2;
                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcomma(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pellipses(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          String v$el$5 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$5;
                        }
                      }
                    }
                  }
                  { // Start scope for a4.
                    String a4 = cast(yyOpValue1);

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pclosecurly(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        Option<String> f = ( a1 == null ) ? Option.<String>none()
                        : Option.<String>some(a1);
                        Span span = createSpan(yyStart,yyCount);
                        List<Import> imports = Useful.list((Import)NodeFactory.makeImportNames(span, f, a2,a3));
                        if (a4 != null)
                        imports.add((Import)NodeFactory.makeImportStar(span, f, a2,
                        Collections.<IdOrOpOrAnonymousName>emptyList()));
                        yyValue = imports;

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  } // End scope for a4.

                  // Nested alternative 2.

                  yyResult = pw(yyChoice2);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pellipses(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pclosecurly(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          log(createSpan(yyStart,yyCount), "Missing comma.");
                          yyValue = Collections.<Import>emptyList();

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // Nested alternative 2.

      yyResult = pId(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a2 = yyResult.semanticValue();

        yyResult = pdot(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pQualifiedName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Id a3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pmatch(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pId(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Id v$el$6 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$6;
                  }
                }
              }
            }
            { // Start scope for a4.
              Id a4 = cast(yyOpValue1);

              Option<String> f = ( a1 == null ) ? Option.<String>none()
              : Option.<String>some(a1);
              APIName api;
              Id id;
              if (a3.getApiName().isNone()) {
                api = NodeFactory.makeAPIName(a2);
                id = a3;
              } else {
                api = NodeFactory.makeAPINameSkipLast(a2, a3);
                id  = NodeFactory.makeIdFromLast(a3);
              }
              AliasedSimpleName an = (a4 == null) ? NodeFactory.makeAliasedSimpleName(id)
              : NodeFactory.makeAliasedSimpleName(id, a4);
              Import imp = NodeFactory.makeImportNames(createSpan(yyStart,yyCount), f,
              api, Useful.list(an));
              yyValue = Useful.list(imp);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a4.
          }
        }
      }
    } // End scope for a1.

    // Alternative <ErrorProduction>.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }
          }
        }
      }

      log(createSpan(yyStart,yyCount), "Try \"import api APIName\"");
      yyValue = Collections.<Import>emptyList();

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.SimpleNames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleNames(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    boolean                     yyRepeated1;
    Pair<IdOrOpOrAnonymousName> yyRepValue1;
    List<IdOrOpOrAnonymousName> yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IdOrOpOrAnonymousName a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSimpleName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOpOrAnonymousName a1 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pSimpleName(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    IdOrOpOrAnonymousName v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = 
                      new Pair<IdOrOpOrAnonymousName>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<IdOrOpOrAnonymousName> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSymbol$commaOrNot(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pSimpleName(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    IdOrOpOrAnonymousName v$el$2 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = 
                      new Pair<IdOrOpOrAnonymousName>(v$el$2, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<IdOrOpOrAnonymousName> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                log(createSpan(yyStart,yyCount), "Missing comma.");
                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 3.

          yyResult = pw(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = Useful.list(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.AliasedSimpleName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedSimpleName(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAliasedSimpleName) 
      yyColumn.chunk1.fAliasedSimpleName = pAliasedSimpleName$1(yyStart);
    return yyColumn.chunk1.fAliasedSimpleName;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.AliasedSimpleName. */
  private Result pAliasedSimpleName$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    Object            yyOpValue1;
    AliasedSimpleName yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Id a2 = cast(yyOpValue1);

        if (a2 == null)
        yyValue = NodeFactory.makeAliasedSimpleName(a1);
        else
        yyValue = NodeFactory.makeAliasedSimpleName(a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = pEncloserPair(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op a1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pmatch(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pEncloserPair(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Op v$el$3 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$3;
                  }
                }
              }
            }
            { // Start scope for a2.
              Op a2 = cast(yyOpValue1);

              if (big != null) a1 = NodeFactory.makeBig(a1);
              if (a2 == null)
              yyValue = NodeFactory.makeAliasedSimpleName(a1);
              else {
                if (big != null)
                yyValue = NodeFactory.makeAliasedSimpleName(a1, NodeFactory.makeBig(a2));
                else
                yyValue = NodeFactory.makeAliasedSimpleName(a1, a2);
              }

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a2.
          }

          // Nested alternative 2.

          yyResult = pAliasedSimpleName$$Choice1(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op a1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pAliasedSimpleName$$Choice2(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op v$el$6 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$6;
            }
            { // Start scope for a2.
              Op a2 = cast(yyOpValue1);

              if (big != null) a1 = NodeFactory.makeBig(a1);
              if (a2 == null)
              yyValue = NodeFactory.makeAliasedSimpleName(a1);
              else {
                if (big != null)
                yyValue = NodeFactory.makeAliasedSimpleName(a1, NodeFactory.makeBig(a2));
                else
                yyValue = NodeFactory.makeAliasedSimpleName(a1, a2);
              }

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a2.
          }
        }
      } // End scope for big.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.AliasedSimpleName$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedSimpleName$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.AliasedSimpleName$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedSimpleName$$Choice2(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pmatch(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = pEncloser(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            yyValue = yyResult.semanticValue();

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyResult = pOp(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            yyValue = yyResult.semanticValue();

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.AliasedSimpleNameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedSimpleNameList(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    int                     yyRepetition1;
    boolean                 yyRepeated1;
    Pair<AliasedSimpleName> yyRepValue1;
    List<AliasedSimpleName> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedSimpleName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedSimpleName a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAliasedSimpleName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                AliasedSimpleName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = 
                  new Pair<AliasedSimpleName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<AliasedSimpleName> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$commaOrNot(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAliasedSimpleName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                AliasedSimpleName v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = 
                  new Pair<AliasedSimpleName>(v$el$2, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<AliasedSimpleName> a2s = yyRepValue1.reverse();

        log(createSpan(yyStart,yyCount), "Missing comma.");
        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 3.

      yyValue = Useful.list(a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.AliasedQualifiedName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedQualifiedName(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAliasedQualifiedName) 
      yyColumn.chunk1.fAliasedQualifiedName = pAliasedQualifiedName$1(yyStart);
    return yyColumn.chunk1.fAliasedQualifiedName;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.AliasedQualifiedName. */
  private Result pAliasedQualifiedName$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    int               yyOption1;
    Id                yyOpValue1;
    AliasedSimpleName yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pQualifiedName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Id a2 = yyOpValue1;

        a1 = NodeFactory.makeDottedId(a1);
        if (a2 == null)
        yyValue = NodeFactory.makeAliasedSimpleName(a1);
        else {
          a2 = NodeFactory.makeDottedId(a2);
          yyValue = NodeFactory.makeAliasedSimpleName(a1, a2);
        }

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.AliasedQualifiedNameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedQualifiedNameList(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    int                     yyRepetition1;
    boolean                 yyRepeated1;
    Pair<AliasedSimpleName> yyRepValue1;
    List<AliasedSimpleName> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedSimpleName a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAliasedQualifiedName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                AliasedSimpleName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = 
                  new Pair<AliasedSimpleName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<AliasedSimpleName> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$commaOrNot(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAliasedQualifiedName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                AliasedSimpleName v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = 
                  new Pair<AliasedSimpleName>(v$el$2, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<AliasedSimpleName> a2s = yyRepValue1.reverse();

        log(createSpan(yyStart,yyCount), "Missing comma.");
        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 3.

      yyValue = Useful.list(a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.AliasedAPINames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedAPINames(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyRepetition1;
    boolean              yyRepeated1;
    Pair<AliasedAPIName> yyRepValue1;
    List<AliasedAPIName> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedAPIName a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAliasedAPIName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          AliasedAPIName a1 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pAliasedAPIName(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    AliasedAPIName v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = 
                      new Pair<AliasedAPIName>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<AliasedAPIName> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSymbol$commaOrNot(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pAliasedAPIName(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    AliasedAPIName v$el$2 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = 
                      new Pair<AliasedAPIName>(v$el$2, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<AliasedAPIName> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                log(createSpan(yyStart,yyCount), "Missing comma.");
                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 3.

          yyResult = pw(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = Useful.list(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.AliasedAPIName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedAPIName(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAliasedAPIName) 
      yyColumn.chunk1.fAliasedAPIName = pAliasedAPIName$1(yyStart);
    return yyColumn.chunk1.fAliasedAPIName;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.AliasedAPIName. */
  private Result pAliasedAPIName$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Id             yyOpValue1;
    AliasedAPIName yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      APIName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Id a2 = yyOpValue1;

        if (a2 == null)
        yyValue = NodeFactory.makeAliasedAPIName(a1);
        else
        yyValue = NodeFactory.makeAliasedAPIName(a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Export.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExport(final int yyStart) throws IOException {
    Result        yyResult;
    List<APIName> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAPINames(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.APINames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAPINames(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAPINames) 
      yyColumn.chunk1.fAPINames = pAPINames$1(yyStart);
    return yyColumn.chunk1.fAPINames;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.APINames. */
  private Result pAPINames$1(final int yyStart) throws IOException {
    Result        yyResult;
    List<APIName> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      APIName a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAPIName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          APIName a1 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = pAPINames$$Plus1(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<APIName> a2s = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyResult = pAPINames$$Plus2(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<APIName> a2s = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                log(createSpan(yyStart,yyCount), "Missing comma.");
                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 3.

          yyResult = pw(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = Useful.list(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.APINames$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAPINames$$Plus1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAPINames$$Plus1) 
      yyColumn.chunk1.fAPINames$$Plus1 = pAPINames$$Plus1$1(yyStart);
    return yyColumn.chunk1.fAPINames$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.APINames$$Plus1. */
  private Result pAPINames$$Plus1$1(final int yyStart) throws IOException {
    Result        yyResult;
    Pair<APIName> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pAPIName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            APIName v$el$1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pAPINames$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<APIName> v$2 = yyResult.semanticValue();

              yyValue = new Pair<APIName>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<APIName>(v$el$1);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.APINames$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAPINames$$Plus2(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAPINames$$Plus2) 
      yyColumn.chunk1.fAPINames$$Plus2 = pAPINames$$Plus2$1(yyStart);
    return yyColumn.chunk1.fAPINames$$Plus2;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.APINames$$Plus2. */
  private Result pAPINames$$Plus2$1(final int yyStart) throws IOException {
    Result        yyResult;
    Pair<APIName> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSymbol$commaOrNot(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pAPIName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            APIName v$el$3 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pAPINames$$Plus2(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<APIName> v$4 = yyResult.semanticValue();

              yyValue = new Pair<APIName>(v$el$3, v$4);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<APIName>(v$el$3);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.Decls.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecls(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDecls) 
      yyColumn.chunk2.fDecls = pDecls$1(yyStart);
    return yyColumn.chunk2.fDecls;
  }

  /** Actually parse Declaration.Decls. */
  private Result pDecls$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Decl> a1 = yyResult.semanticValue();

      yyResult = pDecls$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<List<Decl>> a2s = yyResult.semanticValue();

        for (List<Decl> ds : a2s.list())  a1.addAll(ds);
        yyValue = a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Decls$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecls$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDecls$$Star1) 
      yyColumn.chunk2.fDecls$$Star1 = pDecls$$Star1$1(yyStart);
    return yyColumn.chunk2.fDecls$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.Decls$$Star1. */
  private Result pDecls$$Star1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<List<Decl>> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDecl(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Decl> v$el$1 = yyResult.semanticValue();

        yyResult = pDecls$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<List<Decl>> v$2 = yyResult.semanticValue();

          yyValue = new Pair<List<Decl>>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.Decl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecl(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDecl) 
      yyColumn.chunk2.fDecl = pDecl$1(yyStart);
    return yyColumn.chunk2.fDecl;
  }

  /** Actually parse Declaration.Decl. */
  private Result pDecl$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pObjectDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ObjectDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pVarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      VarDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pTopLevelFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FnDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pDimUnitDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pTypeAlias(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeAlias a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pTestDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TestDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PropertyDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.AbsDecls.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsDecls(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAbsDecls) 
      yyColumn.chunk2.fAbsDecls = pAbsDecls$1(yyStart);
    return yyColumn.chunk2.fAbsDecls;
  }

  /** Actually parse Declaration.AbsDecls. */
  private Result pAbsDecls$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Decl> a1 = yyResult.semanticValue();

      yyResult = pAbsDecls$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<List<Decl>> a2s = yyResult.semanticValue();

        for (List<Decl> ds : a2s.list())  a1.addAll(ds);
        yyValue = a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.AbsDecls$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsDecls$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAbsDecls$$Star1) 
      yyColumn.chunk2.fAbsDecls$$Star1 = pAbsDecls$$Star1$1(yyStart);
    return yyColumn.chunk2.fAbsDecls$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.AbsDecls$$Star1. */
  private Result pAbsDecls$$Star1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<List<Decl>> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pAbsDecl(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Decl> v$el$1 = yyResult.semanticValue();

        yyResult = pAbsDecls$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<List<Decl>> v$2 = yyResult.semanticValue();

          yyValue = new Pair<List<Decl>>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.AbsDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsDecl(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAbsDecl) 
      yyColumn.chunk2.fAbsDecl = pAbsDecl$1(yyStart);
    return yyColumn.chunk2.fAbsDecl;
  }

  /** Actually parse Declaration.AbsDecl. */
  private Result pAbsDecl$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsTraitDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAbsObjectDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ObjectDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pAbsVarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      VarDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pVarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      VarDecl a1 = yyResult.semanticValue();

      log(NodeUtil.getSpan(a1),
      "A variable declaration with an initializing expression " +
      "is not allowed in an API.");
      yyValue = new ArrayList<Decl>();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FnDecl a1 = yyResult.semanticValue();

      if ( a1.getBody().isSome() ) {
        log(NodeUtil.getSpan(a1),
        "A function declaration with an initializing expression " +
        "is not allowed in an API.");
        yyValue = new ArrayList<Decl>();
      } else yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pDimUnitDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pTypeAlias(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeAlias a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pTestDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TestDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PropertyDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pGrammarDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      GrammarDecl a1 = yyResult.semanticValue();

      yyValue = Useful.list((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.Parameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitObject$Parameter(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitObject$Keyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pTraitObject$Varargs(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pTraitObject$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitObject$Params(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyRepetition1;
    boolean     yyRepeated1;
    Pair<Param> yyRepValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitObject$Parameter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Param a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTraitObject$Parameter(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.checkParams(writer, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$commaOrNot(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTraitObject$Parameter(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$2, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        log(createSpan(yyStart,yyCount), "Missing comma.");
        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 3.

      yyValue = Useful.list(a1);
      NodeUtil.checkParams(writer, yyValue);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared1.
   * This nonterminal represents the duplicate productions 
   * TraitObject.VarargsParam, Parameter.VarargsParam, 
   * and MethodParam.VarargsParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared1(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$Type(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pellipses(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = NodeFactory.makeVarargsParam(a1, a2);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.Varargs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitObject$Varargs(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <ErrorProduction>.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      log(span, "Varargs parameters of objects are not allowed.");
      yyValue = NodeFactory.bogusParam(span);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitObject$Keyword(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitObject$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Param a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeParam(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared2.
   * This nonterminal represents the duplicate productions 
   * TraitObject.PlainParam, Parameter.PlainParam, and MethodParam.PlainParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared2(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    TypeOrPattern yyOpValue1;
    Param         yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIsTypeOrPattern(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TypeOrPattern v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        TypeOrPattern a2 = yyOpValue1;

        if (a2 != null) yyValue = NodeFactory.makeParam(a1, a2);
        else            yyValue = NodeFactory.makeParam(a1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.Param.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitObject$Param(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Modifiers  yyOpValue1;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      Modifiers a1 = yyOpValue1;

      yyResult = p$$Shared2(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Param a2 = yyResult.semanticValue();

        yyValue = (a1 != null) ? NodeFactory.makeParam(a2, a1) : a2;

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.TraitDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    int        yyOption2;
    TraitDecl  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      Modifiers a1 = cast(yyOpValue1);

      yyResult = pTraitHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        TraitHeader a2 = yyResult.semanticValue();

        yyResult = pTraitClauses(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TraitClauses a3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pGoInATrait(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Decl> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a4.
            List<Decl> a4 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pend(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyOption2  = yyOption1;

                yyResult = ps(yyOption2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = ptrait(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption2  = yyResult.index;
                  }
                }

                yyResult = ps(yyOption2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pId(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Id v$el$3 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$3;
                  }
                }
                { // Start scope for a5.
                  Id a5 = cast(yyOpValue1);

                  Span span = createSpan(yyStart,yyCount);
                  if (a5 != null && !a2.getName().getText().equals(a5.getText()))
                  log(span, "A trait declaration of " + a2.getName() +
                  " has the different name " + a5 + " at the end.");
                  if (a1 == null) a1 = Modifiers.None;
                  if (a4 == null) a4 = Collections.<Decl>emptyList();
                  yyValue = NodeFactory.makeTraitDecl(span, a1, a2.getName(),
                  a2.getStaticParams(), a2.getParams(),
                  a2.getExtendsClause(), a3.getWhere(),
                  a4, a3.getExcludes(),
                  a3.getComprises(), a3.getEllipses(),
                  Option.<SelfType>none());

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for a5.
              }
            }
          } // End scope for a4.
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.TraitHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitHeaderFront(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTraitHeaderFront) 
      yyColumn.chunk2.fTraitHeaderFront = pTraitHeaderFront$1(yyStart);
    return yyColumn.chunk2.fTraitHeaderFront;
  }

  /** Actually parse TraitObject.TraitHeaderFront. */
  private Result pTraitHeaderFront$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    Object      yyOpValue1;
    TraitHeader yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptrait(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pOpName(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticParams(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticParam> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<StaticParam> a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTraitValParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Param> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for a3.
              List<Param> a3 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExtendsWhere(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<TraitTypeWhere> v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
              { // Start scope for a4.
                List<TraitTypeWhere> a4 = cast(yyOpValue1);

                Span span = createSpan(yyStart,yyCount);
                log(span, a1 + " is not a valid trait name.");
                yyValue = new TraitHeader(NodeFactory.bogusId(span),
                Collections.<StaticParam>emptyList(),
                Option.<List<Param>>none(),
                Collections.<TraitTypeWhere>emptyList());

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a4.
            } // End scope for a3.
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = pId(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticParams(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticParam> v$el$4 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$4;
            }
          }
          { // Start scope for a2.
            List<StaticParam> a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTraitValParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Param> v$el$5 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$5;
              }
            }
            { // Start scope for a3.
              List<Param> a3 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExtendsWhere(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<TraitTypeWhere> v$el$6 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$6;
                }
              }
              { // Start scope for a4.
                List<TraitTypeWhere> a4 = cast(yyOpValue1);

                if (a2 == null) a2 = Collections.<StaticParam>emptyList();
                if (a4 == null) a4 = Collections.<TraitTypeWhere>emptyList();
                yyValue = new TraitHeader(a1, a2, Option.<List<Param>>wrap(a3), a4);

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a4.
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.TraitValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitValParam(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTraitValParam) 
      yyColumn.chunk2.fTraitValParam = pTraitValParam$1(yyStart);
    return yyColumn.chunk2.fTraitValParam;
  }

  /** Actually parse TraitObject.TraitValParam. */
  private Result pTraitValParam$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = (a1 == null) ? Collections.<Param>emptyList() : a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.TraitParams.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitParams(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyRepetition1;
    boolean     yyRepeated1;
    Pair<Param> yyRepValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Param a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTraitParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$commaOrNot(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTraitParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$2, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        log(createSpan(yyStart,yyCount), "Missing comma.");
        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 3.

      yyValue = Useful.list(a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.TraitParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitParam(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIsType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a2 = yyResult.semanticValue();

          yyValue = NodeFactory.makeParam(a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.TraitClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitClauses(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<TraitClause> yyRepValue1;
    TraitClauses      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pw(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TraitClause v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<TraitClause>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }
    { // Start scope for a1s.
      Pair<TraitClause> a1s = yyRepValue1.reverse();

      yyValue = new TraitClauses();
      for (TraitClause t : (List<TraitClause>)a1s.list()) {
        yyValue.set(t);
        if ( t instanceof Comprises && ((Comprises)t).hasEllipses() ) {
          String file = createSpan(yyStart,yyCount).begin.getFileName();
          if ( file.length() > 4 &&
          file.substring( file.length()-3).equals("fss") )
          log(t.span(), "Comprises clauses can include \"...\" only in APIs.");
        }
      }

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for a1s.
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.TraitClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitClause(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTraitClause) 
      yyColumn.chunk2.fTraitClause = pTraitClause$1(yyStart);
    return yyColumn.chunk2.fTraitClause;
  }

  /** Actually parse TraitObject.TraitClause. */
  private Result pTraitClause$1(final int yyStart) throws IOException {
    Result      yyResult;
    TraitClause yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExcludes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<BaseType> a1 = yyResult.semanticValue();

      yyValue = new Excludes(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pComprises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Comprises a1 = yyResult.semanticValue();

      yyValue = a1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pWhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WhereClause a1 = yyResult.semanticValue();

      yyValue = new Where(createSpan(yyStart,yyCount),
      Option.<WhereClause>some(a1));
      NodeUtil.checkWhereClauses(writer, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <ErrorProduction>.

    yyResult = pExtendsWhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      log(span,
      "Extends clauses should come before excludes/comprises/where clauses.");
      yyValue = new Where(span, Option.<WhereClause>none());

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoInATrait.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoInATrait(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Decl> yyRepValue1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGoesInATrait(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoesInATrait(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Decl v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Decl>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Decl> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.checkMembers(writer, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoesInATrait.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoesInATrait(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fGoesInATrait) 
      yyColumn.chunk2.fGoesInATrait = pGoesInATrait$1(yyStart);
    return yyColumn.chunk2.fGoesInATrait;
  }

  /** Actually parse TraitObject.GoesInATrait. */
  private Result pGoesInATrait$1(final int yyStart) throws IOException {
    Result     yyResult;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCoercion(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAbsVarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pMdDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.ObjectDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pObjectDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    int        yyOption2;
    ObjectDecl yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      Modifiers a1 = cast(yyOpValue1);

      yyResult = pObjectHeader(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ObjectHeader a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoInAnObject(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Decl> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<Decl> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pend(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyOption2  = yyOption1;

              yyResult = ps(yyOption2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pobject(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption2  = yyResult.index;
                }
              }

              yyResult = ps(yyOption2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pId(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Id v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
              { // Start scope for a4.
                Id a4 = cast(yyOpValue1);

                Span span = createSpan(yyStart,yyCount);
                if (a4 != null && !a2.getName().getText().equals(a4.getText()))
                log(span, "An object declaration of " + a2.getName() +
                " has the different name " + a4 + " at the end.");
                if (a1 == null) a1 = Modifiers.None;
                if (a3 == null) a3 = Collections.<Decl>emptyList();
                FnHeaderClause fhc = a2.getFnHeaderClause();
                yyValue = NodeFactory.makeObjectDecl(span, a1, a2.getName(),
                a2.getStaticParams(),
                a2.getExtendsClause(),
                fhc.getWhereClause(),
                a3, a2.getParams(),
                fhc.getThrowsClause(),
                fhc.getContractClause(),
                Option.<SelfType>none());

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a4.
            }
          }
        } // End scope for a3.
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.ObjectHeader.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pObjectHeader(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fObjectHeader) 
      yyColumn.chunk3.fObjectHeader = pObjectHeader$1(yyStart);
    return yyColumn.chunk3.fObjectHeader;
  }

  /** Actually parse TraitObject.ObjectHeader. */
  private Result pObjectHeader$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    ObjectHeader yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pobject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pOpName(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticParams(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticParam> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<StaticParam> a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pObjectValParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Param> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for a3.
              List<Param> a3 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExtendsWhere(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<TraitTypeWhere> v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
              { // Start scope for a4.
                List<TraitTypeWhere> a4 = cast(yyOpValue1);

                yyResult = pFnClauses(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  FnHeaderClause a5 = yyResult.semanticValue();

                  Span span = createSpan(yyStart,yyCount);
                  log(span, a1 + " is not a valid object name.");
                  NodeUtil.checkWhereClauses(writer, a5.getWhereClause());
                  yyValue = new ObjectHeader(NodeFactory.bogusId(span),
                  Collections.<StaticParam>emptyList(),
                  Option.<List<Param>>none(),
                  Collections.<TraitTypeWhere>emptyList(), a5);

                  return yyResult.createValue(yyValue, yyError);
                }
              } // End scope for a4.
            } // End scope for a3.
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = pId(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticParams(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticParam> v$el$4 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$4;
            }
          }
          { // Start scope for a2.
            List<StaticParam> a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pObjectValParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Param> v$el$5 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$5;
              }
            }
            { // Start scope for a3.
              List<Param> a3 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExtendsWhere(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<TraitTypeWhere> v$el$6 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$6;
                }
              }
              { // Start scope for a4.
                List<TraitTypeWhere> a4 = cast(yyOpValue1);

                yyResult = pFnClauses(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  FnHeaderClause a5 = yyResult.semanticValue();

                  if (a2 == null) a2 = Collections.<StaticParam>emptyList();
                  if (a4 == null) a4 = Collections.<TraitTypeWhere>emptyList();
                  NodeUtil.checkWhereClauses(writer, a5.getWhereClause());
                  yyValue = new ObjectHeader(a1, a2, Option.<List<Param>>wrap(a3), a4, a5);

                  return yyResult.createValue(yyValue, yyError);
                }
              } // End scope for a4.
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.ObjectValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pObjectValParam(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fObjectValParam) 
      yyColumn.chunk3.fObjectValParam = pObjectValParam$1(yyStart);
    return yyColumn.chunk3.fObjectValParam;
  }

  /** Actually parse TraitObject.ObjectValParam. */
  private Result pObjectValParam$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitObject$Params(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = (a1 == null) ? Collections.<Param>emptyList() : a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoInAnObject(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fGoInAnObject) 
      yyColumn.chunk3.fGoInAnObject = pGoInAnObject$1(yyStart);
    return yyColumn.chunk3.fGoInAnObject;
  }

  /** Actually parse TraitObject.GoInAnObject. */
  private Result pGoInAnObject$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGoesInAnObject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyResult = pGoInAnObject$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Decl> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.checkMembers(writer, yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.GoInAnObject$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoInAnObject$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fGoInAnObject$$Star1) 
      yyColumn.chunk3.fGoInAnObject$$Star1 = pGoInAnObject$$Star1$1(yyStart);
    return yyColumn.chunk3.fGoInAnObject$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.GoInAnObject$$Star1. */
  private Result pGoInAnObject$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pGoesInAnObject(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Decl v$el$1 = yyResult.semanticValue();

        yyResult = pGoInAnObject$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Decl> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Decl>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoesInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoesInAnObject(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fGoesInAnObject) 
      yyColumn.chunk3.fGoesInAnObject = pGoesInAnObject$1(yyStart);
    return yyColumn.chunk3.fGoesInAnObject;
  }

  /** Actually parse TraitObject.GoesInAnObject. */
  private Result pGoesInAnObject$1(final int yyStart) throws IOException {
    Result     yyResult;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCoercion(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pVarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pMdDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsTraitDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsTraitDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    int        yyOption2;
    TraitDecl  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      Modifiers a1 = cast(yyOpValue1);

      yyResult = pTraitHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        TraitHeader a2 = yyResult.semanticValue();

        yyResult = pAbsTraitClauses(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TraitClauses a3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAbsGoInATrait(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Decl> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a4.
            List<Decl> a4 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pend(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyOption2  = yyOption1;

                yyResult = ps(yyOption2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = ptrait(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption2  = yyResult.index;
                  }
                }

                yyResult = ps(yyOption2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pId(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Id v$el$3 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$3;
                  }
                }
                { // Start scope for a5.
                  Id a5 = cast(yyOpValue1);

                  Span span = createSpan(yyStart,yyCount);
                  if (a5 != null && !a2.getName().getText().equals(a5.getText())) {
                    log(span, "A trait declaration of " + a2.getName() +
                    " has the different name " + a5 + " at the end.");
                  }
                  if (a1 == null) a1 = Modifiers.None;
                  if (a4 == null) a4 = Collections.<Decl>emptyList();
                  yyValue = NodeFactory.makeTraitDecl(span, a1, a2.getName(),
                  a2.getStaticParams(), a2.getParams(),
                  a2.getExtendsClause(), a3.getWhere(),
                  a4, a3.getExcludes(),
                  a3.getComprises(), a3.getEllipses(),
                  Option.<SelfType>none());

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for a5.
              }
            }
          } // End scope for a4.
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsTraitClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsTraitClauses(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<TraitClause> yyRepValue1;
    TraitClauses      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pw(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TraitClause v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<TraitClause>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }
    { // Start scope for a1s.
      Pair<TraitClause> a1s = yyRepValue1.reverse();

      yyValue = new TraitClauses();
      for (TraitClause t : (List<TraitClause>)a1s.list()) yyValue.set(t);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for a1s.
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsGoInATrait.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsGoInATrait(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Decl> yyRepValue1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared3(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Decl v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Decl>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Decl> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.checkAbsMembers(writer, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared3.
   * This nonterminal represents the duplicate productions 
   * TraitObject.AbsGoesInATrait and TraitObject.AbsGoesInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared3(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.f$$Shared3) 
      yyColumn.chunk3.f$$Shared3 = p$$Shared3$1(yyStart);
    return yyColumn.chunk3.f$$Shared3;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared3. */
  private Result p$$Shared3$1(final int yyStart) throws IOException {
    Result     yyResult;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCoercion(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pVarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      log(NodeUtil.getSpan(yyValue),
      "A field declaration with an initializing expression " +
      "is not allowed in an API.");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pAbsVarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pMdDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if ( ((FnDecl)yyValue).getBody().isSome() )
      log(NodeUtil.getSpan(yyValue),
      "A method declaration with a body expression " +
      "is not allowed in an API.");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsObjectDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsObjectDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    int        yyOption2;
    ObjectDecl yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      Modifiers a1 = cast(yyOpValue1);

      yyResult = pObjectHeader(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ObjectHeader a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pAbsGoInAnObject(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Decl> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<Decl> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pend(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyOption2  = yyOption1;

              yyResult = ps(yyOption2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pobject(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption2  = yyResult.index;
                }
              }

              yyResult = ps(yyOption2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pId(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Id v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
              { // Start scope for a4.
                Id a4 = cast(yyOpValue1);

                Span span = createSpan(yyStart,yyCount);
                if (a4 != null && !a2.getName().getText().equals(a4.getText())) {
                  log(span, "An object declaration of " + a2.getName() +
                  " has the different name " + a4 + " at the end.");
                }
                if (a1 == null) a1 = Modifiers.None;
                if (a3 == null) a3 = Collections.<Decl>emptyList();
                FnHeaderClause fhc = a2.getFnHeaderClause();
                Option<List<Param>> params = a2.getParams();
                NodeUtil.checkNoWrapped(writer, params);
                yyValue = NodeFactory.makeObjectDecl(span, a1, a2.getName(),
                a2.getStaticParams(),
                a2.getExtendsClause(),
                fhc.getWhereClause(), a3, params,
                fhc.getThrowsClause(),
                fhc.getContractClause(),
                Option.<SelfType>none());

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a4.
            }
          }
        } // End scope for a3.
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsGoInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsGoInAnObject(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Decl> yyRepValue1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared3(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Decl v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Decl>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Decl> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.checkAbsMembers(writer, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.TopLevelFnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTopLevelFnDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Modifiers  yyOpValue1;
    FnDecl     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$3 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$3;
    }
    { // Start scope for a1.
      Modifiers a1 = yyOpValue1;

      yyResult = pFnHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderFront a2 = yyResult.semanticValue();

        yyResult = pFnHeaderClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderClause a3 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineExpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Expr a4 = yyResult.semanticValue();

                  if (a1 == null) a1 = Modifiers.None;
                  yyValue = NodeFactory.mkFnDecl(createSpan(yyStart,yyCount), a1, a2, a3, a4);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pInvalidFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pAbsFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.InvalidFnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInvalidFnDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    FnDecl     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
    }

    yyResult = pFnHeaderFront(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FnHeaderFront a2 = yyResult.semanticValue();

      yyResult = pFnHeaderClause(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderClause a3 = yyResult.semanticValue();

        yyResult = ps(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a4 = yyResult.semanticValue();

            Span span = createSpan(yyStart,yyCount);
            log(span, "Invalid top-level declaration.");
            yyValue = NodeFactory.mkFnDecl(span, Modifiers.None, a2, a3, a4);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.FnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Modifiers  yyOpValue1;
    FnDecl     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$2;
    }
    { // Start scope for a1.
      Modifiers a1 = yyOpValue1;

      yyResult = pFnHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderFront a2 = yyResult.semanticValue();

        yyResult = pFnHeaderClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderClause a3 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineExpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Expr a4 = yyResult.semanticValue();

                  if (a1 == null) a1 = Modifiers.None;
                  yyValue = NodeFactory.mkFnDecl(createSpan(yyStart,yyCount), a1, a2, a3, a4);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pAbsFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.AbsFnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsFnDecl(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fAbsFnDecl) 
      yyColumn.chunk3.fAbsFnDecl = pAbsFnDecl$1(yyStart);
    return yyColumn.chunk3.fAbsFnDecl;
  }

  /** Actually parse Function.AbsFnDecl. */
  private Result pAbsFnDecl$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Modifiers  yyOpValue1;
    FnDecl     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$2;
    }
    { // Start scope for a1.
      Modifiers a1 = yyOpValue1;

      yyResult = pAbsFnHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderFront a2 = yyResult.semanticValue();

        yyResult = pFnHeaderClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderClause a3 = yyResult.semanticValue();

          if (a1 == null) a1 = Modifiers.None;
          yyValue = NodeFactory.mkFnDecl(createSpan(yyStart,yyCount), a1, a2, a3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pFnSig(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.FnHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnHeaderFront(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFnHeaderFront) 
      yyColumn.chunk3.fFnHeaderFront = pFnHeaderFront$1(yyStart);
    return yyColumn.chunk3.fFnHeaderFront;
  }

  /** Actually parse Function.FnHeaderFront. */
  private Result pFnHeaderFront$1(final int yyStart) throws IOException {
    Result        yyResult;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNamedFnHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pParameter$OpHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.AbsFnHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsFnHeaderFront(final int yyStart) throws IOException {
    Result        yyResult;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsNamedFnHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pParameter$AbsOpHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.NamedFnHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNamedFnHeaderFront(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<StaticParam> yyOpValue1;
    FnHeaderFront     yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<StaticParam> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pParameter$ValParam(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Param> a3 = yyResult.semanticValue();

            if (a2 == null) a2 = Collections.<StaticParam>emptyList();
            yyValue = new FnHeaderFront(a1, a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.AbsNamedFnHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsNamedFnHeaderFront(final int yyStart) 
    throws IOException {

    Result            yyResult;
    int               yyOption1;
    List<StaticParam> yyOpValue1;
    FnHeaderFront     yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<StaticParam> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pParameter$AbsValParam(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Param> a3 = yyResult.semanticValue();

            if (a2 == null) a2 = Collections.<StaticParam>emptyList();
            yyValue = new FnHeaderFront(a1, a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.FnSig.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnSig(final int yyStart) throws IOException {
    Result     yyResult;
    FnDecl     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IdOrOpOrAnonymousName a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              final Modifiers mods = Modifiers.None;
              final List<Param>  params = Collections.<Param>emptyList();
              if (!(a2 instanceof ArrowType)) {
                Span span = NodeUtil.getSpan(a2);
                log(span, "Abstract function declaration should have an arrow type.");
                Type ty = NodeFactory.makeVoidType(span);
                a2 = NodeFactory.makeArrowType(span, ty, ty);
              }
              Type d = ((ArrowType) a2).getDomain();
              if ( d instanceof TupleType ) {
                TupleType _d = (TupleType)d;
                for (Type argT : _d.getElements()) {
                  Id name = NodeFactory.makeId(NodeUtil.getSpan(argT), "_");
                  params.add(NodeFactory.makeParam(NodeUtil.getSpan(argT),
                  mods, name, argT));
                }
                if (_d.getVarargs().isSome()) {
                  Type argT = _d.getVarargs().unwrap();
                  Id name = NodeFactory.makeId(NodeUtil.getSpan(argT), "_");
                  params.add(NodeFactory.makeVarargsParam(NodeUtil.getSpan(argT),
                  mods, name, argT));
                }
                assert(_d.getKeywords().isEmpty()): "Keyword parameters present"
                + " in a FnSig: " + _d;
              } else {
                Id name = NodeFactory.makeId(NodeUtil.getSpan(d), "_");
                params.add(NodeFactory.makeParam(NodeUtil.getSpan(d), mods, name, d));
              }
              
              /*
              We could do this, if we had a suitable value for bottomExpr:
              for (KeywordType k : d.getKeywords()) {
              params.add(NodeFactory.makeParam(NodeUtil.getSpan(k), mods,
              k.getName(), k.getType(), bottomExpr,
              Option.<Type>none()));
              }
              */
              yyValue = NodeFactory.mkFnDecl(createSpan(yyStart,yyCount), mods, a1,
              params, ((ArrowType)a2).getRange());

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.ValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$ValParam(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = Useful.list(NodeFactory.makeParam(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$Params(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = Collections.<Param>emptyList();
            else            yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.AbsValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$AbsValParam(final int yyStart) 
    throws IOException {

    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$AbsParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = Collections.<Param>emptyList();
            else            yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyValue = Useful.list(NodeFactory.makeAbsParam(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.Parameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Parameter(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameter$Keyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Params(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyRepetition1;
    boolean     yyRepeated1;
    Pair<Param> yyRepValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameter$Parameter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Param a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pParameter$Parameter(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.checkParams(writer, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$commaOrNot(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pParameter$Parameter(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$2, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        log(createSpan(yyStart,yyCount), "Missing comma.");
        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 3.

      yyValue = Useful.list(a1);
      NodeUtil.checkParams(writer, yyValue);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.AbsParameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$AbsParameter(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameter$Keyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared4(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.AbsParams.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$AbsParams(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyRepetition1;
    boolean     yyRepeated1;
    Pair<Param> yyRepValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameter$AbsParameter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Param a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pParameter$AbsParameter(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.checkParams(writer, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$commaOrNot(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pParameter$AbsParameter(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$2, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        log(createSpan(yyStart,yyCount), "Missing comma.");
        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.checkParams(writer, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 3.

      yyValue = Useful.list(a1);
      NodeUtil.checkParams(writer, yyValue);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Keyword(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Param a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeParam(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared4.
   * This nonterminal represents the duplicate productions 
   * Parameter.AbsPlainParam and MethodParam.AbsPlainParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared4(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIsType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a2 = yyResult.semanticValue();

          yyValue = NodeFactory.makeParam(a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeAbsParam(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared5.
   * This nonterminal represents the duplicate productions Parameter.LeftOp 
   * and MethodParam.LeftOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared5(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmapsto(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyCount),
          a1.getText() + "|->");

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared6.
   * This nonterminal represents the duplicate productions Parameter.SingleOp 
   * and MethodParam.SingleOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared6(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=NodeFactory.makeOpUnknown(createSpan(yyStart,yyCount), "^");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pSUM(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=NodeFactory.makeOpBig(createSpan(yyStart,yyCount), "BIG +");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pPROD(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=NodeFactory.makeOpBig(createSpan(yyStart,yyCount),
      "BIG juxtaposition");

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.OpHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$OpHeaderFront(final int yyStart) 
    throws IOException {

    Result        yyResult;
    int           yyOption1;
    Object        yyOpValue1;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared5(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op opa1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for opa2.
              List<StaticParam> opa2 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pParameter$Params(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
              { // Start scope for opa3.
                List<Param> opa3 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared46(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Op opa4 = yyResult.semanticValue();

                    if (opa2 == null) opa2 = Collections.<StaticParam>emptyList();
                    if (opa3 == null) opa3 = Collections.<Param>emptyList();
                    yyValue = NodeUtil.makeOpHeaderFront(writer, createSpan(yyStart,yyCount),
                    opa1, opa4.getText(), Option.<String>wrap(big),
                    opa2, opa3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for opa3.
            } // End scope for opa2.
          }
        }
      } // End scope for big.

      // Nested alternative 2.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$ValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared47(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Object a2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pStaticParams(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<StaticParam> v$el$8 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$8;
                }
              }
              { // Start scope for a3.
                List<StaticParam> a3 = cast(yyOpValue1);

                Op op = (Op)a2;
                if (a3 == null)
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(op), a1);
                else
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(op), a3, a1);

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a3.
            }
          }
        }
      }

      // Nested alternative 3.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$9 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$9;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared6(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op a1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$10 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$10;
              }
            }
            { // Start scope for a2.
              List<StaticParam> a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pParameter$ValParam(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> a3 = yyResult.semanticValue();

                  yyValue = NodeUtil.makeOpHeaderFront(writer, createSpan(yyStart,yyCount),
                  a1, Option.<String>wrap(big),
                  Option.<List<StaticParam>>wrap(a2), a3);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a2.
          }
        }
      } // End scope for big.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared46.
   * This nonterminal represents the duplicate productions 
   * Parameter.OpHeaderFront$$Choice1, Parameter.AbsOpHeaderFront$$Choice1, 
   * MethodParam.OpHeaderFront$$Choice1, 
   * and MethodParam.AbsOpHeaderFront$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared46(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared47.
   * This nonterminal represents the duplicate productions 
   * Parameter.OpHeaderFront$$Choice2 and MethodParam.OpHeaderFront$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared47(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = NodeFactory.makeOpUnknown(createSpan(yyStart,yyCount), "^");

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.AbsOpHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$AbsOpHeaderFront(final int yyStart) 
    throws IOException {

    Result        yyResult;
    int           yyOption1;
    Object        yyOpValue1;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared5(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op opa1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for opa2.
              List<StaticParam> opa2 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pParameter$AbsParams(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
              { // Start scope for opa3.
                List<Param> opa3 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared46(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Op opa4 = yyResult.semanticValue();

                    if (opa2 == null) opa2 = Collections.<StaticParam>emptyList();
                    if (opa3 == null) opa3 = Collections.<Param>emptyList();
                    yyValue = NodeUtil.makeOpHeaderFront(writer, createSpan(yyStart,yyCount),
                    opa1, opa4.getText(),
                    Option.<String>wrap(big), opa2, opa3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for opa3.
            } // End scope for opa2.
          }
        }
      } // End scope for big.

      // Nested alternative 2.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$AbsValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared48(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Object a2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pStaticParams(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<StaticParam> v$el$7 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$7;
                }
              }
              { // Start scope for a3.
                List<StaticParam> a3 = cast(yyOpValue1);

                Op op = (Op)a2;
                if (a3 == null)
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(op), a1);
                else
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(op), a3, a1);

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a3.
            }
          }
        }
      }

      // Nested alternative 3.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$8 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$8;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared6(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op a1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$9 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$9;
              }
            }
            { // Start scope for a2.
              List<StaticParam> a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pParameter$AbsValParam(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> a3 = yyResult.semanticValue();

                  yyValue = NodeUtil.makeOpHeaderFront(writer, createSpan(yyStart,yyCount),
                  a1, Option.<String>wrap(big),
                  Option.<List<StaticParam>>wrap(a2), a3);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a2.
          }
        }
      } // End scope for big.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared48.
   * This nonterminal represents the duplicate productions 
   * Parameter.AbsOpHeaderFront$$Choice2 
   * and MethodParam.AbsOpHeaderFront$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared48(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcaret(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = NodeFactory.makeOpUnknown(createSpan(yyStart,yyCount), "^");

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.MdDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdDecl(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMdDecl) 
      yyColumn.chunk3.fMdDecl = pMdDecl$1(yyStart);
    return yyColumn.chunk3.fMdDecl;
  }

  /** Actually parse Method.MdDecl. */
  private Result pMdDecl$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Modifiers  yyOpValue1;
    FnDecl     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMdDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$2;
    }
    { // Start scope for a1.
      Modifiers a1 = yyOpValue1;

      yyResult = pAbsMdHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderFront a2 = yyResult.semanticValue();

        yyResult = pFnHeaderClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderClause a3 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          NodeUtil.checkSubscriptedAssignment(writer, span, a2, a3);
          yyValue = NodeFactory.mkFnDecl(span, Modifiers.nonNull(a1), a2, a3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.MdDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdDef(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Modifiers  yyOpValue1;
    FnDecl     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      Modifiers a1 = yyOpValue1;

      yyResult = pMdHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderFront a2 = yyResult.semanticValue();

        yyResult = pFnHeaderClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderClause a3 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineExpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Expr a4 = yyResult.semanticValue();

                  Span span = createSpan(yyStart,yyCount);
                  NodeUtil.checkSubscriptedAssignment(writer, span, a2, a3);
                  yyValue = NodeFactory.mkFnDecl(span, Modifiers.nonNull(a1), a2, a3, a4);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.MdHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdHeaderFront(final int yyStart) throws IOException {
    Result        yyResult;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNamedMdHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMethodParam$OpHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.AbsMdHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsMdHeaderFront(final int yyStart) throws IOException {
    Result        yyResult;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsNamedMdHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMethodParam$AbsOpHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.NamedMdHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNamedMdHeaderFront(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<StaticParam> yyOpValue1;
    FnHeaderFront     yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<StaticParam> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pMethodParam$ValParam(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Param> a3 = yyResult.semanticValue();

            if (a2 == null) a2 = Collections.<StaticParam>emptyList();
            yyValue = new FnHeaderFront(a1, a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.AbsNamedMdHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsNamedMdHeaderFront(final int yyStart) 
    throws IOException {

    Result            yyResult;
    int               yyOption1;
    List<StaticParam> yyOpValue1;
    FnHeaderFront     yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<StaticParam> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pMethodParam$AbsValParam(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Param> a3 = yyResult.semanticValue();

            if (a2 == null) a2 = Collections.<StaticParam>emptyList();
            yyValue = new FnHeaderFront(a1, a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.Coercion.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercion(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fCoercion) 
      yyColumn.chunk3.fCoercion = pCoercion$1(yyStart);
    return yyColumn.chunk3.fCoercion;
  }

  /** Actually parse Method.Coercion. */
  private Result pCoercion$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcoerce(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<StaticParam> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = popenparen(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pBindId(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Id a2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pIsTypeOrPattern(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    TypeOrPattern v$el$2 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$2;
                  }
                }
                { // Start scope for a3.
                  TypeOrPattern a3 = cast(yyOpValue1);

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pFnClauses(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        FnHeaderClause a4 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = null;

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pwidens(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            String v$el$3 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;
                            yyOpValue1 = v$el$3;
                          }
                        }
                        { // Start scope for a5.
                          String a5 = cast(yyOpValue1);

                          yyOpValue1 = null;

                          yyResult = pw(yyOption1);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pequals(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pw(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pNoNewlineExpr(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  Expr v$el$4 = yyResult.semanticValue();

                                  yyOption1  = yyResult.index;
                                  yyOpValue1 = v$el$4;
                                }
                              }
                            }
                          }
                          { // Start scope for a6.
                            Expr a6 = cast(yyOpValue1);

                            Span span = createSpan(yyStart,yyCount);
                            if (a1 == null) a1 = Collections.<StaticParam>emptyList();
                            List<Param> params;
                            if (a3 == null) {
                              log(span, "A coercion declaration should explicitly declare its parameter type.");
                              params = Useful.list(NodeFactory.makeParam(a2));
                            } else params = Useful.list(NodeFactory.makeParam(a2, a3));
                            Modifiers mods = Modifiers.possible(a5,Modifiers.Widens);
                            NodeUtil.checkCoercionClauses(writer, span, a4);
                            yyValue = NodeFactory.mkFnDecl(span, mods, NodeFactory.makeId(span,"coerce"),
                            a1, params, a4, Option.<Expr>wrap(a6));

                            return new SemanticValue(yyValue, yyOption1, yyError);
                          } // End scope for a6.
                        } // End scope for a5.
                      }
                    }
                  }
                } // End scope for a3.
              }
            }
          }

          // Nested alternative 2.

          yyResult = pMethodParam$ValParam(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Param> a2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pIsType(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type v$el$5 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$5;
              }
            }
            { // Start scope for a3.
              Type a3 = cast(yyOpValue1);

              yyResult = pFnClauses(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                FnHeaderClause a4 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pwidens(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    String v$el$6 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$6;
                  }
                }
                { // Start scope for a5.
                  String a5 = cast(yyOpValue1);

                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pequals(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pNoNewlineExpr(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Expr v$el$7 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$7;
                        }
                      }
                    }
                  }
                  { // Start scope for a6.
                    Expr a6 = cast(yyOpValue1);

                    Span span = createSpan(yyStart,yyCount);
                    log(span, "A coercion declaration should have exactly one parameter.");
                    if (a4 != null)
                    log(span, "A coercion declaration should not have an explicitly declared return type.");
                    yyValue = NodeFactory.makeFnDecl(span, Modifiers.None,
                    NodeFactory.makeId(span,"coerce"),
                    Collections.<StaticParam>emptyList(),
                    a2, Option.<Type>wrap(a3));

                    return new SemanticValue(yyValue, yyOption1, yyError);
                  } // End scope for a6.
                } // End scope for a5.
              }
            } // End scope for a3.
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.ValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$ValParam(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMethodParam$Params(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = Collections.<Param>emptyList();
            else            yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.AbsValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$AbsValParam(final int yyStart) 
    throws IOException {

    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMethodParam$AbsParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = Collections.<Param>emptyList();
            else            yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.Parameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Parameter(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMethodParam$Keyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pMethodParam$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Params(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyRepetition1;
    boolean     yyRepeated1;
    Pair<Param> yyRepValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMethodParam$Parameter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Param a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pMethodParam$Parameter(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.checkParams(writer, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$commaOrNot(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pMethodParam$Parameter(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$2, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        log(createSpan(yyStart,yyCount), "Missing comma.");
        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 3.

      yyValue = Useful.list(a1);
      NodeUtil.checkParams(writer, yyValue);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.AbsParameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$AbsParameter(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMethodParam$Keyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pMethodParam$AbsParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.AbsParams.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$AbsParams(final int yyStart) 
    throws IOException {

    Result      yyResult;
    int         yyRepetition1;
    boolean     yyRepeated1;
    Pair<Param> yyRepValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMethodParam$AbsParameter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Param a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pMethodParam$AbsParameter(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.checkParams(writer, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$commaOrNot(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pMethodParam$AbsParameter(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<Param>(v$el$2, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Param> a2s = yyRepValue1.reverse();

        log(createSpan(yyStart,yyCount), "Missing comma.");
        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.checkParams(writer, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 3.

      yyValue = Useful.list(a1);
      NodeUtil.checkParams(writer, yyValue);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Keyword(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMethodParam$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Param a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeParam(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.Param.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Param(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pself(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = NodeFactory.makeParam(NodeFactory.makeId(createSpan(yyStart,yyCount),
      "self"));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.AbsParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$AbsParam(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pself(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = NodeFactory.makeParam(NodeFactory.makeId(createSpan(yyStart,yyCount),
      "self"));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared4(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.OpHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$OpHeaderFront(final int yyStart) 
    throws IOException {

    Result        yyResult;
    int           yyOption1;
    Object        yyOpValue1;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared5(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op opa1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for opa2.
              List<StaticParam> opa2 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pMethodParam$Params(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
              { // Start scope for opa3.
                List<Param> opa3 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared46(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Op opa4 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pcolonequals(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = popenparen(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pw(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = 
                                pSubscriptAssignParam(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {
                                Param v$el$6 = yyResult.semanticValue();

                                yyResult = pw(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyResult = pcloseparen(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyOption1  = yyResult.index;
                                    yyOpValue1 = v$el$6;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    { // Start scope for opa5.
                      Param opa5 = cast(yyOpValue1);

                      if (opa2 == null) opa2 = Collections.<StaticParam>emptyList();
                      if (opa3 == null) opa3 = Collections.<Param>emptyList();
                      yyValue = NodeUtil.makeOpHeaderFront(writer, createSpan(yyStart,yyCount),
                      opa1, opa4.getText(),
                      Option.<String>wrap(big), opa2, opa3,
                      !NodeUtil.hasSelfParameter(opa3),
                      Option.<Param>wrap(opa5));

                      return new SemanticValue(yyValue, yyOption1, yyError);
                    } // End scope for opa5.
                  }
                }
              } // End scope for opa3.
            } // End scope for opa2.
          }
        }
      } // End scope for big.

      // Nested alternative 2.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMethodParam$ValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared47(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Object a2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pStaticParams(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<StaticParam> v$el$9 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$9;
                }
              }
              { // Start scope for a3.
                List<StaticParam> a3 = cast(yyOpValue1);

                Op op = (Op)a2;
                if (a3 == null)
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(op), a1);
                else
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(op), a3, a1);

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a3.
            }
          }
        }
      }

      // Nested alternative 3.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$10 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$10;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared6(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op a1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$11 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$11;
              }
            }
            { // Start scope for a2.
              List<StaticParam> a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pMethodParam$ValParam(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> a3 = yyResult.semanticValue();

                  yyValue = NodeUtil.makeOpHeaderFront(writer, createSpan(yyStart,yyCount),
                  a1, Option.<String>wrap(big),
                  Option.<List<StaticParam>>wrap(a2), a3);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a2.
          }
        }
      } // End scope for big.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.AbsOpHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$AbsOpHeaderFront(final int yyStart) 
    throws IOException {

    Result        yyResult;
    int           yyOption1;
    Object        yyOpValue1;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared5(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op opa1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for opa2.
              List<StaticParam> opa2 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pMethodParam$AbsParams(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
              { // Start scope for opa3.
                List<Param> opa3 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared46(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Op opa4 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pcolonequals(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = popenparen(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pw(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = 
                                pAbsSubscriptAssignParam(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {
                                Param v$el$6 = yyResult.semanticValue();

                                yyResult = pw(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyResult = pcloseparen(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyOption1  = yyResult.index;
                                    yyOpValue1 = v$el$6;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    { // Start scope for opa5.
                      Param opa5 = cast(yyOpValue1);

                      if (opa2 == null) opa2 = Collections.<StaticParam>emptyList();
                      if (opa3 == null) opa3 = Collections.<Param>emptyList();
                      yyValue = NodeUtil.makeOpHeaderFront(writer, createSpan(yyStart,yyCount),
                      opa1, opa4.getText(),
                      Option.<String>wrap(big), opa2, opa3,
                      !NodeUtil.hasSelfParameter(opa3),
                      Option.<Param>wrap(opa5));

                      return new SemanticValue(yyValue, yyOption1, yyError);
                    } // End scope for opa5.
                  }
                }
              } // End scope for opa3.
            } // End scope for opa2.
          }
        }
      } // End scope for big.

      // Nested alternative 2.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMethodParam$AbsValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared48(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Object a2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pStaticParams(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<StaticParam> v$el$8 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$8;
                }
              }
              { // Start scope for a3.
                List<StaticParam> a3 = cast(yyOpValue1);

                Op op = (Op)a2;
                if (a3 == null)
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(op), a1);
                else
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(op), a3, a1);

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a3.
            }
          }
        }
      }

      // Nested alternative 3.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$9 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$9;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared6(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op a1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$10 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$10;
              }
            }
            { // Start scope for a2.
              List<StaticParam> a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pMethodParam$AbsValParam(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> a3 = yyResult.semanticValue();

                  yyValue = NodeUtil.makeOpHeaderFront(writer, createSpan(yyStart,yyCount),
                  a1, Option.<String>wrap(big),
                  Option.<List<StaticParam>>wrap(a2), a3);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a2.
          }
        }
      } // End scope for big.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.SubscriptAssignParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSubscriptAssignParam(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMethodParam$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.AbsSubscriptAssignParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsSubscriptAssignParam(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMethodParam$AbsParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Variable.VarDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarDecl(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fVarDecl) 
      yyColumn.chunk4.fVarDecl = pVarDecl$1(yyStart);
    return yyColumn.chunk4.fVarDecl;
  }

  /** Actually parse Variable.VarDecl. */
  private Result pVarDecl$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Modifiers  yyOpValue1;
    VarDecl    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      Modifiers a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pVariable$VarMayTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValue> a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pInitVal(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            com.sun.fortress.useful.Pair<Expr,Boolean> a3 = yyResult.semanticValue();

            a2 = NodeFactory.makeLvs(writer, a2, Option.<Modifiers>wrap(a1), a3.getB());
            yyValue = NodeFactory.makeVarDecl(writer, createSpan(yyStart,yyCount), a2,
            Option.<Expr>some(a3.getA()));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pBindIdOrBindIdTuple(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Id> a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice2 = yyResult.index;

          // Nested alternative 1.

          yyResult = pequals(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr a3 = yyResult.semanticValue();

                List<LValue> lvs = NodeFactory.makeLvs(writer, NodeFactory.ids2Lvs(a2),
                Option.<Modifiers>wrap(a1),
                Option.<TypeOrPattern>none(), false);
                yyValue = NodeFactory.makeVarDecl(writer, createSpan(yyStart,yyCount),
                lvs, Option.<Expr>some(a3));

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyResult = pSymbol$colon(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice3 = yyResult.index;

              // Nested alternative 1.

              yyResult = pNoNewlineType(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pellipses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pInitVal(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        com.sun.fortress.useful.Pair<Expr,Boolean> a4 = yyResult.semanticValue();

                        List<LValue> lvs = NodeFactory.makeLvs(writer, NodeFactory.ids2Lvs(a2),
                        Option.<Modifiers>wrap(a1),
                        Option.<TypeOrPattern>some(a3), a4.getB());
                        yyValue = NodeFactory.makeVarDecl(writer, createSpan(yyStart,yyCount), lvs,
                        Option.<Expr>some(a4.getA()));

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pNoNewlineTupleType(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TupleType a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pInitVal(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    com.sun.fortress.useful.Pair<Expr,Boolean> a4 = yyResult.semanticValue();

                    Span span = createSpan(yyStart,yyCount);
                    List<Type> tys = a3.getElements();
                    if (a2.size() != tys.size())
                    log(span, "Mismatched numbers of variables and types.");
                    List<LValue> lvs = NodeFactory.makeLvs(writer, NodeFactory.ids2Lvs(a2),
                    Option.<Modifiers>wrap(a1),
                    tys, a4.getB());
                    yyValue = NodeFactory.makeVarDecl(writer, span, lvs,
                    Option.<Expr>some(a4.getA()));

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Variable.VarMayTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariable$VarMayTypes(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    boolean      yyRepeated1;
    Pair<LValue> yyRepValue1;
    List<LValue> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVariable$VarMayType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LValue a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pVariable$VarMayType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LValue a1 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pVariable$VarMayType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    LValue v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = new Pair<LValue>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<LValue> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSymbol$commaOrNot(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pVariable$VarMayType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    LValue v$el$2 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = new Pair<LValue>(v$el$2, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<LValue> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                log(createSpan(yyStart,yyCount), "Missing comma.");
                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Variable.VarMayType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariable$VarMayType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fVariable$VarMayType) 
      yyColumn.chunk4.fVariable$VarMayType = pVariable$VarMayType$1(yyStart);
    return yyColumn.chunk4.fVariable$VarMayType;
  }

  /** Actually parse Variable.VarMayType. */
  private Result pVariable$VarMayType$1(final int yyStart) 
    throws IOException {

    Result        yyResult;
    int           yyOption1;
    TypeOrPattern yyOpValue1;
    LValue        yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIsTypeOrPattern(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TypeOrPattern v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        TypeOrPattern a2 = yyOpValue1;

        if (a2 == null)
        yyValue = NodeFactory.makeLValue(createSpan(yyStart,yyCount),a1);
        else
        yyValue = NodeFactory.makeLValue(createSpan(yyStart,yyCount),a1,a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Variable.InitVal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInitVal(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fInitVal) 
      yyColumn.chunk4.fInitVal = pInitVal$1(yyStart);
    return yyColumn.chunk4.fInitVal;
  }

  /** Actually parse Variable.InitVal. */
  private Result pInitVal$1(final int yyStart) throws IOException {
    Result                                     yyResult;
    com.sun.fortress.useful.Pair<Expr,Boolean> yyValue;
    ParseError                                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInitVal$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          boolean isMutable = a1.equals(":=") || a1.equals("\u2254");
          yyValue = new com.sun.fortress.useful.Pair<Expr,Boolean>(a2, isMutable);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.InitVal$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInitVal$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pequals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ':':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = ":=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\u2254':
        {
          yyValue = "\u2254";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("init val expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Variable.AbsVarDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsVarDecl(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fAbsVarDecl) 
      yyColumn.chunk4.fAbsVarDecl = pAbsVarDecl$1(yyStart);
    return yyColumn.chunk4.fAbsVarDecl;
  }

  /** Actually parse Variable.AbsVarDecl. */
  private Result pAbsVarDecl$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Modifiers  yyOpValue1;
    VarDecl    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      Modifiers a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pNoNewlineVarWTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValue> a2 = yyResult.semanticValue();

        a2 = NodeFactory.makeLvs(writer, a2, Option.<Modifiers>wrap(a1), false);
        yyValue = NodeFactory.makeVarDecl(writer, createSpan(yyStart,yyCount), a2,
        Option.<Expr>none());

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pBindIdOrBindIdTuple(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Id> a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$colon(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice2 = yyResult.index;

              // Nested alternative 1.

              yyResult = pNoNewlineType(yyChoice2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pellipses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<LValue> lvs = NodeFactory.makeLvs(writer, NodeFactory.ids2Lvs(a2),
                    Option.<Modifiers>wrap(a1),
                    Option.<TypeOrPattern>some(a3), false);
                    yyValue = NodeFactory.makeVarDecl(writer, createSpan(yyStart,yyCount),
                    lvs, Option.<Expr>none());

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pNoNewlineTupleType(yyChoice2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TupleType a3 = yyResult.semanticValue();

                Span span = createSpan(yyStart,yyCount);
                List<Type> tys = a3.getElements();
                if (a2.size() != tys.size())
                log(span, "Mismatched numbers of variables and types.");
                List<LValue> lvs = NodeFactory.makeLvs(writer, NodeFactory.ids2Lvs(a2),
                Option.<Modifiers>wrap(a1), tys, false);
                yyValue = NodeFactory.makeVarDecl(writer, span, lvs, Option.<Expr>none());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.Pattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPattern(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fPattern) 
      yyColumn.chunk4.fPattern = pPattern$1(yyStart);
    return yyColumn.chunk4.fPattern;
  }

  /** Actually parse MayNewlineHeader.Pattern. */
  private Result pPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Pattern    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPatternValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PatternArgs a2 = yyResult.semanticValue();

          yyValue = NodeFactory.makePattern(createSpan(yyStart,yyCount), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyPredMatched = false;

    yyPredResult = p$$Shared49(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pPatternValParam(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PatternArgs a1 = yyResult.semanticValue();

        yyPredMatched = false;

        yyPredResult = p$$Shared50(yyResult.index);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = NodeFactory.makePattern(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("pattern expected", yyStart);
        }
      }
    } else {
      yyError = yyError.select("pattern expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared49.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.Pattern$$Choice1 
   * and com.sun.fortress.parser.templateparser.TemplateParser.NoNewlinePattern$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared49(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared49) 
      yyColumn.chunk4.f$$Shared49 = p$$Shared49$1(yyStart);
    return yyColumn.chunk4.f$$Shared49;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared49. */
  private Result p$$Shared49$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pType$TupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared50.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.Pattern$$Choice2 
   * and com.sun.fortress.parser.templateparser.TemplateParser.NoNewlinePattern$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared50(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared50) 
      yyColumn.chunk4.f$$Shared50 = p$$Shared50$1(yyStart);
    return yyColumn.chunk4.f$$Shared50;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared50. */
  private Result p$$Shared50$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '-':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('>' == yyC) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
          break;

        case '\u2192':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyResult = pDOT(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pslash(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case 'p':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('e' == yyC) {

                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('r' == yyC) {

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select(" expected", yyStart);
                    }
                  }
                }
              }
            }
          }
          break;

        case 's':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('q' == yyC) {

                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('u' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('a' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('r' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('e' == yyC) {

                                final int yyChoice2 = yyIndex;

                                // Nested alternative 1.

                                yyPredMatched = false;

                                yyPredResult = pidrest(yyChoice2);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyValue = null;

                                  return new SemanticValue(yyValue, yyChoice2, yyError);
                                } else {
                                  yyError = yyError.select(" expected", yyStart);
                                }

                                // Nested alternative 2.

                                yyC = character(yyChoice2);
                                if (-1 != yyC) {
                                  yyIndex = yyChoice2 + 1;
                                  if ('d' == yyC) {

                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = null;

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select(" expected", yyStart);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          break;

        case 'c':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('u' == yyC) {

                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('b' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;

                      switch (yyC) {
                      case 'i':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('c' == yyC) {

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = null;

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select(" expected", yyStart);
                              }
                            }
                          }
                        }
                        break;

                      case 'e':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('d' == yyC) {

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = null;

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select(" expected", yyStart);
                              }
                            }
                          }
                        }
                        break;

                      default:
                        /* No match. */
                      }
                    }
                  }
                }
              }
            }
          }
          break;

        case 'i':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('n' == yyC) {

                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('v' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('r' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('s' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('e' == yyC) {

                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = null;

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select(" expected", yyStart);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.PatternValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternValParam(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyOption1;
    List<PatternBinding> yyOpValue1;
    PatternArgs          yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPatternParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<PatternBinding> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<PatternBinding> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null)
            yyValue = NodeFactory.makePatternArgs(createSpan(yyStart,yyCount));
            else yyValue = NodeFactory.makePatternArgs(createSpan(yyStart,yyCount), a1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.TypeOrPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeOrPattern(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fTypeOrPattern) 
      yyColumn.chunk4.fTypeOrPattern = pTypeOrPattern$1(yyStart);
    return yyColumn.chunk4.fTypeOrPattern;
  }

  /** Actually parse MayNewlineHeader.TypeOrPattern. */
  private Result pTypeOrPattern$1(final int yyStart) throws IOException {
    Result        yyResult;
    TypeOrPattern yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IsPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIsPattern(final int yyStart) throws IOException {
    Result     yyResult;
    Pattern    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$colon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPattern(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IsTypeOrPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIsTypeOrPattern(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fIsTypeOrPattern) 
      yyColumn.chunk4.fIsTypeOrPattern = pIsTypeOrPattern$1(yyStart);
    return yyColumn.chunk4.fIsTypeOrPattern;
  }

  /** Actually parse MayNewlineHeader.IsTypeOrPattern. */
  private Result pIsTypeOrPattern$1(final int yyStart) throws IOException {
    Result        yyResult;
    TypeOrPattern yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIsPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIsType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.PatternParams.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternParams(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyRepetition1;
    Pair<Object>         yyRepValue1;
    List<PatternBinding> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pPatternParam(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<PatternBinding> v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Object>(v$el$1, yyRepValue1);
              continue;
            }
          }
        }
      }
      break;
    }
    { // Start scope for a1s.
      Pair<List<PatternBinding>> a1s = cast(yyRepValue1.reverse());

      yyResult = pPatternKeyword(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PatternBinding a2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pw(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pPatternKeyword(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  PatternBinding v$el$2 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<Object>(v$el$2, yyRepValue1);
                  continue;
                }
              }
            }
          }
          break;
        }
        { // Start scope for a3s.
          Pair<PatternBinding> a3s = cast(yyRepValue1.reverse());

          yyValue = new ArrayList<PatternBinding>();
          for (List<PatternBinding> pb: a1s.list())
          yyValue = Useful.concat(yyValue, pb);
          yyValue = Useful.list(yyValue, a2);
          yyValue = Useful.concat(yyValue, a3s.list());

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for a3s.
      }
    } // End scope for a1s.

    // Alternative 2.

    yyResult = pPatternParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<PatternBinding> a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pPatternParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<PatternBinding> v$el$3 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Object>(v$el$3, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<List<PatternBinding>> a2s = cast(yyRepValue1.reverse());

        yyValue = Useful.list(a1);
        for (List<PatternBinding> pb: a2s.list())
        yyValue = Useful.concat(yyValue, pb);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.PatternParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternParam(final int yyStart) throws IOException {
    Result               yyResult;
    List<PatternBinding> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPatternPlainParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PatternBinding a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPatternValParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PatternArgs a1 = yyResult.semanticValue();

      yyValue = a1.getPatterns();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.PatternKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternKeyword(final int yyStart) throws IOException {
    Result         yyResult;
    PatternBinding yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPatternPlainParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PatternBinding a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makePatternKeyword(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.PatternPlainParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternPlainParam(final int yyStart) throws IOException {
    Result         yyResult;
    Result         yyPredResult;
    boolean        yyPredMatched;
    PatternBinding yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIsTypeOrPattern(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TypeOrPattern a2 = yyResult.semanticValue();

          yyValue = NodeFactory.makePlainPattern(createSpan(yyStart,yyCount),
          a1, Modifiers.None,
          Option.<TypeOrPattern>some(a2));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pattern a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeNestedPattern(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyPredMatched = false;

    yyPredResult = pBindId(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pType$Type(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Type a1 = yyResult.semanticValue();

        yyValue = NodeFactory.makeTypePattern(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("pattern plain param expected", yyStart);
    }

    // Alternative 4.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makePlainPattern(createSpan(yyStart,yyCount),
      a1, Modifiers.None,
      Option.<TypeOrPattern>none());

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.NoNewlinePattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlinePattern(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fNoNewlinePattern) 
      yyColumn.chunk4.fNoNewlinePattern = pNoNewlinePattern$1(yyStart);
    return yyColumn.chunk4.fNoNewlinePattern;
  }

  /** Actually parse MayNewlineHeader.NoNewlinePattern. */
  private Result pNoNewlinePattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Pattern    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPatternValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PatternArgs a2 = yyResult.semanticValue();

          yyValue = NodeFactory.makePattern(createSpan(yyStart,yyCount), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyPredMatched = false;

    yyPredResult = p$$Shared49(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pPatternValParam(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PatternArgs a1 = yyResult.semanticValue();

        yyPredMatched = false;

        yyPredResult = p$$Shared50(yyResult.index);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = NodeFactory.makePattern(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("no newline pattern expected", yyStart);
        }
      }
    } else {
      yyError = yyError.select("no newline pattern expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IsType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIsType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fIsType) 
      yyColumn.chunk5.fIsType = pIsType$1(yyStart);
    return yyColumn.chunk5.fIsType;
  }

  /** Actually parse MayNewlineHeader.IsType. */
  private Result pIsType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$colon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$Type(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.WhereConstraintList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereConstraintList(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyRepetition1;
    Pair<WhereConstraint> yyRepValue1;
    List<WhereConstraint> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWhereConstraint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WhereConstraint a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pWhereConstraint(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                WhereConstraint v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<WhereConstraint>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<WhereConstraint> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.WhereConstraint.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereConstraint(final int yyStart) throws IOException {
    Result          yyResult;
    WhereConstraint yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdOrOpName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IdOrOp a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtends(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<BaseType> a2 = yyResult.semanticValue();

          yyValue = NodeFactory.makeWhereExtends(writer, createSpan(yyStart,yyCount),
          a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pTypeAlias(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeAlias a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeWhereTypeAlias(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pcoerces(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$Type(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeWhereCoerces(createSpan(yyStart,yyCount), a1, a2,
              true, false);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pwidens(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$Type(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeWhereCoerces(createSpan(yyStart,yyCount), a1, a2,
              false, true);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pUnitConstraint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pQualifiedName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeWhereEquals(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 6.

    yyResult = pIntConstraint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pBoolExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BoolExpr a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      if ( a1 instanceof BoolConstraint )
      yyValue = NodeFactory.makeBoolConstraintExpr(span, (BoolConstraint)a1);
      else {
        log(span, "Invalid boolean where constraint.");
        BoolConstraint bc =
        NodeFactory.makeBoolUnaryOp(span, false, a1,
        NodeFactory.makeOpInfix(span, "NOT"));
        yyValue = NodeFactory.makeBoolConstraintExpr(span, bc);
      }

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pwidens(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = por(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcoerces(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pType$Type(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Type a2 = yyResult.semanticValue();

                      yyValue = NodeFactory.makeWhereCoerces(createSpan(yyStart,yyCount), a1, a2,
                      true, true);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.UnitConstraint.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnitConstraint(final int yyStart) throws IOException {
    int            yyC;
    int            yyIndex;
    Result         yyResult;
    int            yyBase;
    UnitConstraint yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('o' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('l' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('s' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyResult = pw(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pequals(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyResult = pw(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pIdOrOpName(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      IdOrOp a1 = yyResult.semanticValue();

                                      yyValue = NodeFactory.makeUnitConstraint(writer, createSpan(yyStart,yyCount), a1);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pIdOrOpName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IdOrOp a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('d' == yyC) {
              yyIndex = yyResult.index + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('m' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('s' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('i' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('o' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('n' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('l' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyC = character(yyIndex);
                                if ('e' == yyC) {
                                  yyIndex = yyIndex + 1;

                                  yyC = character(yyIndex);
                                  if ('s' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyC = character(yyIndex);
                                    if ('s' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyValue = NodeFactory.makeUnitConstraint(writer, createSpan(yyStart,yyCount), a1);

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("\"dimensionless\" expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("\"dimensionless\" expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("\"dimensionless\" expected", yyBase);
                                }
                              } else {
                                yyError = yyError.select("\"dimensionless\" expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("\"dimensionless\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"dimensionless\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"dimensionless\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"dimensionless\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"dimensionless\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"dimensionless\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"dimensionless\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"dimensionless\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"dimensionless\" expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("unit constraint expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IntConstraint.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntConstraint(final int yyStart) throws IOException {
    Result        yyResult;
    IntConstraint yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IntExpr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = plessthanequal(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "<=");
              yyValue = NodeFactory.makeIntConstraint(createSpan(yyStart,yyCount), a1, a2, op);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = plessthan(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "<");
              yyValue = NodeFactory.makeIntConstraint(createSpan(yyStart,yyCount), a1, a2, op);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 3.

        yyResult = pgreaterthanequal(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), ">=");
              yyValue = NodeFactory.makeIntConstraint(createSpan(yyStart,yyCount), a1, a2, op);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 4.

        yyResult = pgreaterthan(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), ">");
              yyValue = NodeFactory.makeIntConstraint(createSpan(yyStart,yyCount), a1, a2, op);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 5.

        yyResult = pequals(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "=");
              yyValue = NodeFactory.makeIntConstraint(createSpan(yyStart,yyCount), a1, a2, op);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IntVal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntVal(final int yyStart) throws IOException {
    Result     yyResult;
    IntExpr    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IntLiteralExpr a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeIntBase(createSpan(yyStart,yyCount), false, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeIntRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IntExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntExpr(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyRepetition1;
    Pair<Action<IntExpr>> yyRepValue1;
    IntExpr               yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSumExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IntExpr seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pIntExprTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<IntExpr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<IntExpr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<IntExpr>> list = yyRepValue1.reverse();

        yyValue = (IntExpr)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IntExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<IntExpr> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pSymbol$plus(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSumExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final IntExpr a1 = yyResult.semanticValue();

            yyValue = new Action<IntExpr>() {
              public IntExpr run(IntExpr base) {
                Span span = NodeUtil.spanTwo(NodeUtil.getSpan(a1),
                createSpan(yyStart,yyCount));
                Op plus = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "+");
                return NodeFactory.makeIntBinaryOp(span, (IntExpr)base, a1, plus);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pminus(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSumExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final IntExpr a1 = yyResult.semanticValue();

            yyValue = new Action<IntExpr>() {
              public IntExpr run(IntExpr base) {
                Op minus = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "-");
                Span span = NodeUtil.spanTwo(NodeUtil.getSpan(a1),
                createSpan(yyStart,yyCount));
                return NodeFactory.makeIntBinaryOp(span, (IntExpr)base, a1, minus);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.SumExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSumExpr(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyRepetition1;
    Pair<Action<IntExpr>> yyRepValue1;
    IntExpr               yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMulExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IntExpr seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pProductIntExpr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<IntExpr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<IntExpr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<IntExpr>> list = yyRepValue1.reverse();

        yyValue = (IntExpr)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.ProductIntExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProductIntExpr(final int yyStart) throws IOException {
    Result          yyResult;
    Action<IntExpr> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared51(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pMulExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntExpr a1 = yyResult.semanticValue();

        yyValue = new Action<IntExpr>() {
          public IntExpr run(IntExpr base) {
            Op product = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), " ");
            Span span = NodeUtil.spanTwo(NodeUtil.getSpan(a1),
            createSpan(yyStart,yyCount));
            return NodeFactory.makeIntBinaryOp(span, (IntExpr)base, a1, product);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared51.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.ProductIntExpr$$Choice1 
   * and com.sun.fortress.parser.templateparser.TemplateParser.ProductUnitExpr$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared51(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDOT(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pSpacing$Space(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.MulExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMulExpr(final int yyStart) throws IOException {
    Result     yyResult;
    IntExpr    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntBase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IntExpr a1 = yyResult.semanticValue();

      yyResult = pcaret(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIntVal(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IntExpr a2 = yyResult.semanticValue();

          Op exponent = NodeFactory.makeOpInfix(NodeUtil.getSpan(a2), "^");
          yyValue = NodeFactory.makeIntBinaryOp(createSpan(yyStart,yyCount),
          a1, a2, exponent);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pIntBase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IntBase.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntBase(final int yyStart) throws IOException {
    Result     yyResult;
    IntExpr    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntVal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIntExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IntExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolExpr(final int yyStart) throws IOException {
    Result     yyResult;
    BoolExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOpBool(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makeBoolExpr(writer,
      Resolver.resolveOps(writer, span, a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.OpBool.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOpBool(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fOpBool) 
      yyColumn.chunk5.fOpBool = pOpBool$1(yyStart);
    return yyColumn.chunk5.fOpBool;
  }

  /** Actually parse MayNewlineHeader.OpBool. */
  private Result pOpBool$1(final int yyStart) throws IOException {
    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pBoolPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolPrimary(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fBoolPrimary) 
      yyColumn.chunk5.fBoolPrimary = pBoolPrimary$1(yyStart);
    return yyColumn.chunk5.fBoolPrimary;
  }

  /** Actually parse MayNewlineHeader.BoolPrimary. */
  private Result pBoolPrimary$1(final int yyStart) throws IOException {
    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolPrimaryFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pBoolPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pBoolPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pOp(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pwr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pOpBool(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              PureList<PrecedenceOpExpr> a3 = yyResult.semanticValue();

              yyValue = a3.cons((PrecedenceOpExpr)new LooseInfix(a2)).cons(new RealExpr(a1));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }

      // Nested alternative 3.

      yyValue = PureList.make((PrecedenceOpExpr)new RealExpr(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolPrefix(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fBoolPrefix) 
      yyColumn.chunk5.fBoolPrefix = pBoolPrefix$1(yyStart);
    return yyColumn.chunk5.fBoolPrefix;
  }

  /** Actually parse MayNewlineHeader.BoolPrefix. */
  private Result pBoolPrefix$1(final int yyStart) throws IOException {
    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pOpBool(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOpBool(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolPrimaryFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolPrimaryFront(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;
            String a1 = "true";

            yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;
              String a1 = "false";

              yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(NodeUtil.getSpan(a1), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOpBool(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount);
              yyValue = ExprFactory.makeInParentheses(Resolver.resolveOps(writer, span, a1));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("bool primary front expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.UnitVal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnitVal(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    UnitExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('o' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('l' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('s' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;
                              String a1 = "dimensionless";

                              Span span = createSpan(yyStart,yyCount);
                              yyValue = NodeFactory.makeUnitRef(span, false, NodeFactory.makeId(span, a1));

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeUnitRef(createSpan(yyStart,yyCount), false, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unit val expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.UnitExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnitExpr(final int yyStart) throws IOException {
    Result                 yyResult;
    int                    yyRepetition1;
    Pair<Action<UnitExpr>> yyRepValue1;
    UnitExpr               yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMulDivUnit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      UnitExpr seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pUnitExprTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<UnitExpr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<UnitExpr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<UnitExpr>> list = yyRepValue1.reverse();

        yyValue = (UnitExpr)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.UnitExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnitExprTail(final int yyStart) throws IOException {
    Result           yyResult;
    Action<UnitExpr> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared51(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pMulDivUnit(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final UnitExpr a1 = yyResult.semanticValue();

        yyValue = new Action<UnitExpr>() {
          public UnitExpr run(UnitExpr base) {
            Span span = NodeUtil.spanTwo(NodeUtil.getSpan(a1),
            createSpan(yyStart,yyCount));
            Op product = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), " ");
            return NodeFactory.makeUnitBinaryOp(span, false, (UnitExpr)base,
            a1, product);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pQuotientUnitExpr$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pMulDivUnit(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final UnitExpr a1 = yyResult.semanticValue();

        yyValue = new Action<UnitExpr>() {
          public UnitExpr run(UnitExpr base) {
            Span span = NodeUtil.spanTwo(NodeUtil.getSpan(a1),
            createSpan(yyStart,yyCount));
            Op quotient = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "/");
            return NodeFactory.makeUnitBinaryOp(span, false, (UnitExpr)base,
            a1, quotient);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.QuotientUnitExpr$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQuotientUnitExpr$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pslash(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("quotient unit expr expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("quotient unit expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.MulDivUnit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMulDivUnit(final int yyStart) throws IOException {
    Result     yyResult;
    UnitExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnitBase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      UnitExpr a1 = yyResult.semanticValue();

      yyResult = pcaret(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnitVal(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          UnitExpr a2 = yyResult.semanticValue();

          Op exponent = NodeFactory.makeOpInfix(NodeUtil.getSpan(a2), "^");
          yyValue = NodeFactory.makeUnitBinaryOp(createSpan(yyStart,yyCount), false,
          a1, a2, exponent);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pUnitBase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.UnitBase.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnitBase(final int yyStart) throws IOException {
    Result     yyResult;
    UnitExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnitVal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnitExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          UnitExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.Requires.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRequires(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Expr> yyOpValue1;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prequires(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popencurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExprList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Expr> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a1.
            List<Expr> a1 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = (a1 == null) ? Collections.<Expr>emptyList() : a1;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a1.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.Ensures.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnsures(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyOption1;
    List<EnsuresClause> yyOpValue1;
    List<EnsuresClause> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pensures(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popencurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pEnsuresClauseList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<EnsuresClause> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a1.
            List<EnsuresClause> a1 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = (a1 == null) ? Collections.<EnsuresClause>emptyList() : a1;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a1.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.EnsuresClauseList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnsuresClauseList(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyRepetition1;
    Pair<EnsuresClause> yyRepValue1;
    List<EnsuresClause> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEnsuresClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      EnsuresClause a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEnsuresClause(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                EnsuresClause v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<EnsuresClause>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<EnsuresClause> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.EnsuresClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnsuresClause(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    Expr          yyOpValue1;
    EnsuresClause yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pprovided(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Expr a2 = yyOpValue1;

        yyValue = NodeFactory.makeEnsuresClause(createSpan(yyStart,yyCount), a1,
        Option.<Expr>wrap(a2));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.Invariant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInvariant(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Expr> yyOpValue1;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pinvariant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popencurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExprList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Expr> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a1.
            List<Expr> a1 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = (a1 == null) ? Collections.<Expr>emptyList() : a1;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a1.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.StaticArgs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArgs(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fStaticArgs) 
      yyColumn.chunk5.fStaticArgs = pStaticArgs$1(yyStart);
    return yyColumn.chunk5.fStaticArgs;
  }

  /** Actually parse MayNewlineHeader.StaticArgs. */
  private Result pStaticArgs$1(final int yyStart) throws IOException {
    Result          yyResult;
    List<StaticArg> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popendoublesquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosedoublesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.StaticArgList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArgList(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    Pair<StaticArg> yyRepValue1;
    List<StaticArg> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStaticArg(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticArg a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticArg(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                StaticArg v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<StaticArg>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<StaticArg> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.StaticArg.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fStaticArg) 
      yyColumn.chunk5.fStaticArg = pStaticArg$1(yyStart);
    return yyColumn.chunk5.fStaticArg;
  }

  /** Actually parse MayNewlineHeader.StaticArg. */
  private Result pStaticArg$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    StaticArg  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyPredResult = pStaticArg$$Choice1(yyResult.index);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyValue = NodeFactory.makeOpArg(NodeUtil.getSpan(a1),
        a1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyPredMatched = false;

    yyPredResult = pStaticArg$$Choice2(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pIntExpr(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        IntExpr a1 = yyResult.semanticValue();

        yyValue = NodeFactory.makeIntArg(NodeUtil.getSpan(a1), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("static arg expected", yyStart);
    }

    // Alternative 3.

    yyPredMatched = false;

    yyPredResult = pStaticArg$$Choice3(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pBoolExpr(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        BoolExpr a1 = yyResult.semanticValue();

        yyValue = NodeFactory.makeBoolArg(NodeUtil.getSpan(a1), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("static arg expected", yyStart);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;
            String a1 = "true";

            Span span = createSpan(yyStart,yyCount);
            yyValue = NodeFactory.makeBoolArg(span, NodeFactory.makeBoolBase(span, false, true));

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;
              String a1 = "false";

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeBoolArg(span, NodeFactory.makeBoolBase(span, false, false));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Alternative 6.

    yyPredMatched = false;

    yyPredResult = pStaticArg$$Choice4(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pType$Type(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Type a1 = yyResult.semanticValue();

        yyValue = NodeFactory.makeTypeArg(NodeUtil.getSpan(a1), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("static arg expected", yyStart);
    }

    // Alternative 7.

    yyResult = pUnitExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      UnitExpr a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeUnitArg(NodeUtil.getSpan(a1), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("static arg expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.StaticArg$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pcomma(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pclosedoublesquare(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.StaticArg$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg$$Choice2(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pclosedoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = p$$Shared7(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pcomma(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 4.

        yyResult = popendoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 5.

        yyResult = pSymbol$opensquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 6.

        yyResult = prightarrow(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 7.

        yyResult = pOR(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 8.

        yyResult = pAND(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 9.

        yyResult = pIMPLIES(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 10.

        yyResult = pequals(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'U':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('i' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('t' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('y' == yyC) {

                          yyValue = null;

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'd':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('i' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('m' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('n' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('s' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('i' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('o' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('n' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('l' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('e' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('s' == yyC) {

                                                      yyC = 
                                                        character(yyIndex);
                                                      if (-1 != yyC) {
                                                        yyIndex = yyIndex + 1;
                                                        if ('s' == yyC) {

                                                          yyValue = null;

                                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 't':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('r' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('l' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('s' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyValue = null;

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("static arg expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.StaticArg$$Choice3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg$$Choice3(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pclosedoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = p$$Shared7(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pcomma(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 4.

        yyResult = popendoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 5.

        yyResult = pSymbol$opensquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 6.

        yyResult = prightarrow(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'U':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('i' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('t' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('y' == yyC) {

                          yyValue = null;

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'd':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('i' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('m' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('n' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('s' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('i' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('o' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('n' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('l' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('e' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('s' == yyC) {

                                                      yyC = 
                                                        character(yyIndex);
                                                      if (-1 != yyC) {
                                                        yyIndex = yyIndex + 1;
                                                        if ('s' == yyC) {

                                                          yyValue = null;

                                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("static arg expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.StaticArg$$Choice4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg$$Choice4(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pDOT(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pslash(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pper(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 4.

        yyResult = p$$Shared13(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('o' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('l' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('s' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("static arg expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.ExtendsWhere.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtendsWhere(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fExtendsWhere) 
      yyColumn.chunk5.fExtendsWhere = pExtendsWhere$1(yyStart);
    return yyColumn.chunk5.fExtendsWhere;
  }

  /** Actually parse NoNewlineHeader.ExtendsWhere. */
  private Result pExtendsWhere$1(final int yyStart) throws IOException {
    Result               yyResult;
    List<TraitTypeWhere> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pextends(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pTraitTypeWhere(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TraitTypeWhere a1 = yyResult.semanticValue();

          yyValue = Useful.list(a1);
          NodeUtil.validTraitTypeWheres(writer, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = popencurly(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pTraitTypeWhere(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              TraitTypeWhere a1 = yyResult.semanticValue();

              yyResult = pExtendsWhere$$Star1(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<TraitTypeWhere> a2s = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosecurly(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = Useful.cons(a1, a2s.list());
                    NodeUtil.validTraitTypeWheres(writer, yyValue);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ExtendsWhere$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtendsWhere$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fExtendsWhere$$Star1) 
      yyColumn.chunk5.fExtendsWhere$$Star1 = pExtendsWhere$$Star1$1(yyStart);
    return yyColumn.chunk5.fExtendsWhere$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.ExtendsWhere$$Star1. */
  private Result pExtendsWhere$$Star1$1(final int yyStart) 
    throws IOException {

    Result               yyResult;
    Pair<TraitTypeWhere> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pTraitTypeWhere(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            TraitTypeWhere v$el$1 = yyResult.semanticValue();

            yyResult = pExtendsWhere$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<TraitTypeWhere> v$2 = yyResult.semanticValue();

              yyValue = new Pair<TraitTypeWhere>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.TraitTypeWhere.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypeWhere(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fTraitTypeWhere) 
      yyColumn.chunk5.fTraitTypeWhere = pTraitTypeWhere$1(yyStart);
    return yyColumn.chunk5.fTraitTypeWhere;
  }

  /** Actually parse NoNewlineHeader.TraitTypeWhere. */
  private Result pTraitTypeWhere$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    WhereClause    yyOpValue1;
    TraitTypeWhere yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TraitTypeWithError(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BaseType a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pWhere(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WhereClause v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        WhereClause a2 = yyOpValue1;

        Option<WhereClause> where;
        if (a2 == null)
        where = Option.<WhereClause>none();
        else {
          where = Option.<WhereClause>some(a2);
          NodeUtil.checkWhereClauses(writer, a2);
        }
        yyValue = NodeFactory.makeTraitTypeWhere(createSpan(yyStart,yyCount),
        a1, where);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Extends.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtends(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fExtends) 
      yyColumn.chunk5.fExtends = pExtends$1(yyStart);
    return yyColumn.chunk5.fExtends;
  }

  /** Actually parse NoNewlineHeader.Extends. */
  private Result pExtends$1(final int yyStart) throws IOException {
    Result         yyResult;
    List<BaseType> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pextends(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Dominates.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDominates(final int yyStart) throws IOException {
    Result         yyResult;
    List<BaseType> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdominates(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Bounds.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBounds(final int yyStart) throws IOException {
    Result               yyResult;
    List<List<BaseType>> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExtends(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<BaseType> a = yyResult.semanticValue();

      List<List<BaseType>> l = new ArrayList<List<BaseType>>();
      l.add(a);
      yyValue = l;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pDominates(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<BaseType> a = yyResult.semanticValue();

      List<List<BaseType>> l = new ArrayList<List<BaseType>>();
      List<BaseType> dummy = new ArrayList<BaseType>();
      l.add(dummy);
      l.add(a);
      yyValue = l;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Excludes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExcludes(final int yyStart) throws IOException {
    Result         yyResult;
    List<BaseType> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexcludes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.TraitTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypes(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTraitTypes) 
      yyColumn.chunk6.fTraitTypes = pTraitTypes$1(yyStart);
    return yyColumn.chunk6.fTraitTypes;
  }

  /** Actually parse NoNewlineHeader.TraitTypes. */
  private Result pTraitTypes$1(final int yyStart) throws IOException {
    Result         yyResult;
    List<BaseType> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TraitTypeWithError(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BaseType a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);
      NodeUtil.validTraitTypes(writer, yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType$TraitTypeWithError(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BaseType a1 = yyResult.semanticValue();

          yyResult = pTraitTypes$$Star1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<BaseType> a2s = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());
                NodeUtil.validTraitTypes(writer, yyValue);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.TraitTypes$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypes$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTraitTypes$$Star1) 
      yyColumn.chunk6.fTraitTypes$$Star1 = pTraitTypes$$Star1$1(yyStart);
    return yyColumn.chunk6.fTraitTypes$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.TraitTypes$$Star1. */
  private Result pTraitTypes$$Star1$1(final int yyStart) throws IOException {
    Result         yyResult;
    Pair<BaseType> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineType$TraitTypeWithError(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            BaseType v$el$1 = yyResult.semanticValue();

            yyResult = pTraitTypes$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<BaseType> v$2 = yyResult.semanticValue();

              yyValue = new Pair<BaseType>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Comprises.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComprises(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Comprises  yyOpValue1;
    Comprises  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomprises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pComprisingTypes(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<NamedType> a1 = yyResult.semanticValue();

          yyValue = new Comprises(createSpan(yyStart,yyCount), a1);
          NodeUtil.validTraitTypes(writer, Useful.list(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = popencurly(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAbsComprisingTypeList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Comprises v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a1.
            Comprises a1 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                if (a1 == null) {
                  Span span = createSpan(yyStart,yyCount);
                  log(span, "Comprises clauses should not be empty.");
                  yyValue = new Comprises(span, Collections.<NamedType>emptyList(), false);
                } else yyValue = a1;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a1.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.AbsComprisingTypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsComprisingTypeList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    String     yyOpValue1;
    Comprises  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pellipses(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Comprises(createSpan(yyStart,yyCount),
      Collections.<NamedType>emptyList(), true);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pComprisingTypeList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<NamedType> a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pellipses(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        String a2 = yyOpValue1;

        yyValue = new Comprises(createSpan(yyStart,yyCount), a1, a2 != null);
        NodeUtil.validTraitTypes(writer, a1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.ComprisingTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComprisingTypes(final int yyStart) throws IOException {
    Result          yyResult;
    List<NamedType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComprisingTypeWithError(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NamedType a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);
      NodeUtil.validTraitTypes(writer, yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pComprisingTypeList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.ComprisingTypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComprisingTypeList(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fComprisingTypeList) 
      yyColumn.chunk6.fComprisingTypeList = pComprisingTypeList$1(yyStart);
    return yyColumn.chunk6.fComprisingTypeList;
  }

  /** Actually parse NoNewlineHeader.ComprisingTypeList. */
  private Result pComprisingTypeList$1(final int yyStart) throws IOException {
    Result          yyResult;
    List<NamedType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComprisingTypeWithError(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NamedType a1 = yyResult.semanticValue();

      yyResult = pComprisingTypeList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NamedType> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());
        NodeUtil.validTraitTypes(writer, yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ComprisingTypeList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComprisingTypeList$$Star1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fComprisingTypeList$$Star1) 
      yyColumn.chunk6.fComprisingTypeList$$Star1 = pComprisingTypeList$$Star1$1(yyStart);
    return yyColumn.chunk6.fComprisingTypeList$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.ComprisingTypeList$$Star1. */
  private Result pComprisingTypeList$$Star1$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    Pair<NamedType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pComprisingTypeWithError(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            NamedType v$el$1 = yyResult.semanticValue();

            yyResult = pComprisingTypeList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<NamedType> v$2 = yyResult.semanticValue();

              yyValue = new Pair<NamedType>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.ComprisingTypeWithError.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComprisingTypeWithError(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fComprisingTypeWithError) 
      yyColumn.chunk6.fComprisingTypeWithError = pComprisingTypeWithError$1(yyStart);
    return yyColumn.chunk6.fComprisingTypeWithError;
  }

  /** Actually parse NoNewlineHeader.ComprisingTypeWithError. */
  private Result pComprisingTypeWithError$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    NamedType  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TraitTypeWithError(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeVarType(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Where.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhere(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyRepetition1;
    Pair<WhereBinding>    yyRepValue1;
    int                   yyOption1;
    List<WhereConstraint> yyOpValue1;
    WhereClause           yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pwhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = popendoublesquare(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pWhereBinding(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              WhereBinding a1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pWhereBinding(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        WhereBinding v$el$1 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = 
                          new Pair<WhereBinding>(v$el$1, yyRepValue1);
                        continue;
                      }
                    }
                  }
                }
                break;
              }
              { // Start scope for a2s.
                Pair<WhereBinding> a2s = yyRepValue1.reverse();

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosedoublesquare(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = popencurly(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pWhereConstraintList(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            List<WhereConstraint> v$el$2 = yyResult.semanticValue();

                            yyResult = pw(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pclosecurly(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyOption1  = yyResult.index;
                                yyOpValue1 = v$el$2;
                              }
                            }
                          }
                        }
                      }
                    }
                    { // Start scope for a3.
                      List<WhereConstraint> a3 = yyOpValue1;

                      List<WhereBinding> bindings = Useful.cons(a1, a2s.list());
                      if (a3 == null)
                      yyValue = NodeFactory.makeWhereClause(createSpan(yyStart,yyCount),
                      bindings,
                      Collections.<WhereConstraint>emptyList());
                      else
                      yyValue = NodeFactory.makeWhereClause(createSpan(yyStart,yyCount),
                      bindings, a3);

                      return new SemanticValue(yyValue, yyOption1, yyError);
                    } // End scope for a3.
                  }
                }
              } // End scope for a2s.
            }
          }
        }

        // Nested alternative 2.

        yyResult = popencurly(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pWhereConstraintList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WhereConstraint> a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosecurly(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = NodeFactory.makeWhereClause(createSpan(yyStart,yyCount),
                  Collections.<WhereBinding>emptyList(), a1);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.WhereBinding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereBinding(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<BaseType> yyOpValue1;
    WhereBinding   yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pnat(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp a1 = yyResult.semanticValue();

          yyValue = NodeFactory.makeWhereBinding(writer, createSpan(yyStart,yyCount),
          a1, new KindNat());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp a1 = yyResult.semanticValue();

          yyValue = NodeFactory.makeWhereBinding(writer, createSpan(yyStart,yyCount),
          a1, new KindInt());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pbool(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp a1 = yyResult.semanticValue();

          yyValue = NodeFactory.makeWhereBinding(writer, createSpan(yyStart,yyCount),
          a1, new KindBool());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = punit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp a1 = yyResult.semanticValue();

          yyValue = NodeFactory.makeWhereBinding(writer, createSpan(yyStart,yyCount),
          a1, new KindUnit());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pIdOrOpName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IdOrOp a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtends(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<BaseType> a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = a2;
        }
      }
      { // Start scope for a2.
        List<BaseType> a2 = yyOpValue1;

        if (a2 == null) a2 = Collections.<BaseType>emptyList();
        yyValue = NodeFactory.makeWhereBinding(writer, createSpan(yyStart,yyCount),
        a1, a2, new KindType());

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative <ErrorProduction>.

    yyResult = popendoublesquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      log(span, "White square bracket is not a valid where-clause binding.");
      yyValue = NodeFactory.makeWhereBinding(writer, span,
      NodeFactory.bogusId(span),
      new KindType());

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.FnHeaderClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnHeaderClause(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fFnHeaderClause) 
      yyColumn.chunk6.fFnHeaderClause = pFnHeaderClause$1(yyStart);
    return yyColumn.chunk6.fFnHeaderClause;
  }

  /** Actually parse NoNewlineHeader.FnHeaderClause. */
  private Result pFnHeaderClause$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Type           yyOpValue1;
    FnHeaderClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNoNewlineIsTypeOrZilch(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Type v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      Type a1 = yyOpValue1;

      yyResult = pFnClauses(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderClause a2 = yyResult.semanticValue();

        NodeUtil.checkWhereClauses(writer, a2.getWhereClause());
        yyValue = new FnHeaderClause(a2.getThrowsClause(), a2.getWhereClause(),
        a2.getContractClause(), Option.<Type>wrap(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.FnClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnClauses(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fFnClauses) 
      yyColumn.chunk6.fFnClauses = pFnClauses$1(yyStart);
    return yyColumn.chunk6.fFnClauses;
  }

  /** Actually parse NoNewlineHeader.FnClauses. */
  private Result pFnClauses$1(final int yyStart) throws IOException {
    Result         yyResult;
    FnHeaderClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFnClauses$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<FnHeaderClause> a1s = yyResult.semanticValue();

      yyValue = NodeFactory.makeFnClauses(writer, createSpan(yyStart,yyCount),
      a1s.list());

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.FnClauses$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnClauses$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fFnClauses$$Star1) 
      yyColumn.chunk6.fFnClauses$$Star1 = pFnClauses$$Star1$1(yyStart);
    return yyColumn.chunk6.fFnClauses$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.FnClauses$$Star1. */
  private Result pFnClauses$$Star1$1(final int yyStart) throws IOException {
    Result               yyResult;
    Pair<FnHeaderClause> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFnClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FnHeaderClause v$el$1 = yyResult.semanticValue();

      yyResult = pFnClauses$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<FnHeaderClause> v$2 = yyResult.semanticValue();

        yyValue = new Pair<FnHeaderClause>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.FnClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnClause(final int yyStart) throws IOException {
    Result         yyResult;
    FnHeaderClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pThrows(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Type> a1 = yyResult.semanticValue();

        yyValue = NodeFactory.makeThrowsClause(Option.<List<Type>>some(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pWhere(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        WhereClause a1 = yyResult.semanticValue();

        yyValue = NodeFactory.makeWhereClause(Option.<WhereClause>some(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pRequires(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Expr> a1 = yyResult.semanticValue();

        yyValue = NodeFactory.makeRequiresClause(Option.<List<Expr>>some(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pEnsures(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<EnsuresClause> a1 = yyResult.semanticValue();

        yyValue = NodeFactory.makeEnsuresClause(Option.<List<EnsuresClause>>some(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 5.

      yyResult = pInvariant(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Expr> a1 = yyResult.semanticValue();

        yyValue = NodeFactory.makeInvariantsClause(Option.<List<Expr>>some(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 6.

      yyResult = pExtendsWhere(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        log(createSpan(yyStart,yyCount),
        "Extends clauses should come before throws/where/contract clauses.");
        yyValue = NodeFactory.makeWhereClause(Option.<WhereClause>none());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Throws.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pThrows(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fThrows) 
      yyColumn.chunk6.fThrows = pThrows$1(yyStart);
    return yyColumn.chunk6.fThrows;
  }

  /** Actually parse NoNewlineHeader.Throws. */
  private Result pThrows$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pthrows(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = popencurly(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = Collections.<Type>emptyList();

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pTraitTypes(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Mods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMods(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    boolean         yyRepeated1;
    Pair<Modifiers> yyRepValue1;
    Modifiers       yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pMod(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifiers v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifiers>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifiers> a1s = yyRepValue1.reverse();

      yyValue = NodeUtil.checkModifiers(writer, createSpan(yyStart,yyCount),
      a1s.list());

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Mod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifiers  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pabstract(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Abstract;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = patomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Atomic;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pgetter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Getter;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = phidden(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Hidden;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pio(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.IO;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = poverride(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Override;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pprivate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Private;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = psettable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Settable;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = psetter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Setter;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = ptest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Test;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 11.

    yyResult = pvalue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Value;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 12.

    yyResult = pvar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Var;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 13.

    yyResult = pwrapped(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Modifiers.Wrapped;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.StaticParams.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticParams(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fStaticParams) 
      yyColumn.chunk6.fStaticParams = pStaticParams$1(yyStart);
    return yyColumn.chunk6.fStaticParams;
  }

  /** Actually parse NoNewlineHeader.StaticParams. */
  private Result pStaticParams$1(final int yyStart) throws IOException {
    Result            yyResult;
    List<StaticParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popendoublesquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          StaticParam a1 = yyResult.semanticValue();

          yyResult = pStaticParams$$Star1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<StaticParam> a2s = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosedoublesquare(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.StaticParams$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticParams$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fStaticParams$$Star1) 
      yyColumn.chunk7.fStaticParams$$Star1 = pStaticParams$$Star1$1(yyStart);
    return yyColumn.chunk7.fStaticParams$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.StaticParams$$Star1. */
  private Result pStaticParams$$Star1$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<StaticParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticParam(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            StaticParam v$el$1 = yyResult.semanticValue();

            yyResult = pStaticParams$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<StaticParam> v$2 = yyResult.semanticValue();

              yyValue = new Pair<StaticParam>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.StaticParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticParam(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fStaticParam) 
      yyColumn.chunk7.fStaticParam = pStaticParam$1(yyStart);
    return yyColumn.chunk7.fStaticParam;
  }

  /** Actually parse NoNewlineHeader.StaticParam. */
  private Result pStaticParam$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    Object      yyOpValue1;
    StaticParam yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pVariance(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pnat(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIdOrOpName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            IdOrOp a2 = yyResult.semanticValue();

            yyValue = NodeFactory.makeStaticParamId(writer, createSpan(yyStart,yyCount),
            a1, a2, new KindNat());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pint(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIdOrOpName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            IdOrOp a2 = yyResult.semanticValue();

            yyValue = NodeFactory.makeStaticParamId(writer, createSpan(yyStart,yyCount),
            a1, a2, new KindInt());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyResult = pbool(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIdOrOpName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            IdOrOp a2 = yyResult.semanticValue();

            yyValue = NodeFactory.makeStaticParamId(writer, createSpan(yyStart,yyCount),
            a1, a2, new KindBool());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pdim(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp a1 = yyResult.semanticValue();

          yyValue = NodeFactory.makeStaticParamId(writer, createSpan(yyStart,yyCount),
          null, a1, new KindDim());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = punit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pSymbol$colon(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineType(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Type v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
              }
            }
          }
          { // Start scope for a2.
            Type a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pabsorbs(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = punit(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    String v$el$3 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$3;
                  }
                }
              }
            }
            { // Start scope for a3.
              String a3 = cast(yyOpValue1);

              boolean absorbs = (a3 == null) ? false : true;
              yyValue = NodeFactory.makeStaticParamId(writer, createSpan(yyStart,yyCount),
              null, a1, Collections.<BaseType>emptyList(), Collections.<BaseType>emptyList(),
              Option.<Type>wrap(a2), absorbs,
              new KindUnit());

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Alternative 4.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a1 = yyResult.semanticValue();

          yyValue = NodeFactory.makeStaticParam(createSpan(yyStart,yyCount), null, a1,
          Collections.<BaseType>emptyList(), Collections.<BaseType>emptyList(),
          Option.<Type>none(), false,
          new KindOp());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pVariance(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$4 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$4;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pIdOrOpName(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        IdOrOp a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExtends(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<BaseType> a3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pabsorbs(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = punit(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    String v$el$5 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$5;
                  }
                }
              }
            }
            { // Start scope for a4.
              String a4 = cast(yyOpValue1);

              boolean absorbs = (a4 == null) ? false : true;
              yyValue = NodeFactory.makeStaticParamId(writer, createSpan(yyStart,yyCount),
              a1, a2, a3, Collections.<BaseType>emptyList(),Option.<Type>none(),
              absorbs, new KindType());

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a4.
          }
        }
      }

      // Nested alternative 2.

      yyResult = pId(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBounds(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<List<BaseType>> v$el$6 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$6;
          }
        }
        { // Start scope for a3.
          List<List<BaseType>> a3 = cast(yyOpValue1);

          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pabsorbs(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = punit(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  String v$el$7 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$7;
                }
              }
            }
          }
          { // Start scope for a4.
            String a4 = cast(yyOpValue1);

            List<BaseType> eextends = Collections.<BaseType>emptyList();
            List<BaseType> dominates = Collections.<BaseType>emptyList();
            if (a3 != null) {
              if (a3.size() == 2) dominates = a3.get(1);
              else eextends = a3.get(0);
            }
            boolean absorbs = (a4 == null) ? false : true;
            yyValue = NodeFactory.makeStaticParamId(writer, createSpan(yyStart,yyCount),
            a1, a2, eextends, dominates,Option.<Type>none(),
            absorbs, new KindType());

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a4.
        } // End scope for a3.
      }

      // Nested alternative 3.

      yyResult = p$$Shared14(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a2 = yyResult.semanticValue();

        yyValue = NodeFactory.makeStaticParamId(writer, createSpan(yyStart,yyCount),
        a1, a2, Collections.<BaseType>emptyList(), Collections.<BaseType>emptyList(),Option.<Type>none(),
        false, new KindType());

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Alternative <ErrorProduction>.

    yyResult = popendoublesquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      log(span, "White square bracket is not a valid static parameter.");
      yyValue = NodeFactory.makeStaticParamId(writer, span, null,
      NodeFactory.bogusId(span),
      new KindNat());

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Variance.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariance(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('c' == yyC) {

        yyC = character(yyIndex);
        if (-1 != yyC) {
          yyIndex = yyIndex + 1;
          if ('o' == yyC) {

            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              switch (yyC) {
              case 'n':
                {
                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('t' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('r' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('a' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('v' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('a' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('r' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('i' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('a' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('n' == yyC) {

                                                      yyC = 
                                                        character(yyIndex);
                                                      if (-1 != yyC) {
                                                        yyIndex = yyIndex + 1;
                                                        if ('t' == yyC) {

                                                          yyPredMatched = false;

                                                          yyPredResult = 
                                                            pidrest(yyIndex);
                                                          if (yyPredResult.hasValue()) {

                                                            yyPredMatched = true;
                                                          }

                                                          if (! yyPredMatched) {

                                                            yyValue = "contravariant";

                                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                                          } else {
                                                            yyError = yyError.select("variance expected", yyStart);
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                break;

              case 'v':
                {
                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('a' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('r' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('i' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('a' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('n' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('t' == yyC) {

                                          yyPredMatched = false;

                                          yyPredResult = pidrest(yyIndex);
                                          if (yyPredResult.hasValue()) {

                                            yyPredMatched = true;
                                          }

                                          if (! yyPredMatched) {

                                            yyValue = "covariant";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          } else {
                                            yyError = yyError.select("variance expected", yyStart);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("variance expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.DimUnitDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimUnitDecl(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fDimUnitDecl) 
      yyColumn.chunk7.fDimUnitDecl = pDimUnitDecl$1(yyStart);
    return yyColumn.chunk7.fDimUnitDecl;
  }

  /** Actually parse OtherDecl.DimUnitDecl. */
  private Result pDimUnitDecl$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    Object            yyOpValue1;
    List<DimUnitDecl> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdim(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineType(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Type v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
            }
          }
          { // Start scope for a2.
            Type a2 = cast(yyOpValue1);

            final int yyChoice1 = yyOption1;

            // Nested alternative 1.

            yyResult = ps(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared52(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pIdOrOpName(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    IdOrOp a4 = yyResult.semanticValue();

                    yyResult = pDimUnitDecl$$Star1(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Pair<Id> a5s = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pequals(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pNoNewlineExpr(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Expr v$el$6 = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$6;
                            }
                          }
                        }
                      }
                      { // Start scope for a6.
                        Expr a6 = cast(yyOpValue1);

                        Span span = createSpan(yyStart,yyCount);
                        DimDecl dim;
                        Type ty;
                        boolean si_unit = (a3.equals("SI_unit")) ? true : false;
                        List<Id> ids = new ArrayList<Id>();
                        for (Id a5Elt : a5s.list()) ids.add(a5Elt);
                        if ( a1 instanceof Id ) {
                          dim = NodeFactory.makeDimDecl(span, (Id)a1, Option.<Type>wrap(a2));
                          ty = NodeFactory.makeVarType(NodeUtil.getSpan(a1), (Id)a1);
                        } else {
                          log(span, a1 + " is not a valid dimension name.");
                          Id id = NodeFactory.bogusId(span);
                          dim = NodeFactory.makeDimDecl(span, id, Option.<Type>wrap(a2));
                          ty = NodeFactory.makeVarType(NodeUtil.getSpan(a1), id);
                        }
                        if ( a4 instanceof Id ) {
                          ids.add((Id)a4);
                        } else {
                          log(span, a4 + " is not a valid unit name.");
                          ids.add(NodeFactory.bogusId(span));
                        }
                        UnitDecl unit = NodeFactory.makeUnitDecl(span, si_unit, ids,
                        Option.<Type>some(ty),
                        Option.<Expr>wrap(a6));
                        yyValue = Useful.list(dim, unit);

                        return new SemanticValue(yyValue, yyOption1, yyError);
                      } // End scope for a6.
                    }
                  }
                }
              }
            }

            // Nested alternative 2.

            yyOption1  = yyChoice1;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pdefault(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pIdOrOpName(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    IdOrOp v$el$7 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$7;
                  }
                }
              }
            }
            { // Start scope for a3.
              IdOrOp a3 = cast(yyOpValue1);

              Span span = createSpan(yyStart,yyCount);
              Id dimId;
              if ( a1 instanceof Id ) {
                dimId = (Id)a1;
              } else {
                log(span, a1 + " is not a valid dimension name.");
                dimId = NodeFactory.bogusId(span);
              }
              Id unitId;
              if ( a3 instanceof Id ) {
                unitId = (Id)a3;
              } else {
                log(span, a3 + " is not a valid unit name.");
                unitId = NodeFactory.bogusId(span);
              }
              yyValue = Useful.list((DimUnitDecl)NodeFactory.makeDimDecl(span, dimId,
              Option.<Type>wrap(a2),
              Option.<Id>wrap(unitId)));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared52(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp a2 = yyResult.semanticValue();

          yyResult = pDimUnitDecl$$Star2(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<Id> a3s = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSymbol$colon(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pNoNewlineType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Type v$el$12 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$12;
                  }
                }
              }
            }
            { // Start scope for a4.
              Type a4 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pequals(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pNoNewlineExpr(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expr v$el$13 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$13;
                    }
                  }
                }
              }
              { // Start scope for a5.
                Expr a5 = cast(yyOpValue1);

                Span span = createSpan(yyStart,yyCount);
                boolean si_unit = (a1.equals("SI_unit")) ? true : false;
                List<Id> ids = new ArrayList<Id>();
                if ( a2 instanceof Id )
                ids.add((Id)a2);
                else {
                  log(span, a2 + " is not a valid unit name.");
                  ids.add(NodeFactory.bogusId(span));
                }
                for (Id a3Elt : a3s.list()) ids.add(a3Elt);
                yyValue = Useful.list((DimUnitDecl)NodeFactory.makeUnitDecl(span, si_unit, ids,
                Option.<Type>wrap(a4),
                Option.<Expr>wrap(a5)));

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a5.
            } // End scope for a4.
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared52.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.DimUnitDecl$$Choice1 
   * and com.sun.fortress.parser.templateparser.TemplateParser.DimUnitDecl$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared52(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.f$$Shared52) 
      yyColumn.chunk7.f$$Shared52 = p$$Shared52$1(yyStart);
    return yyColumn.chunk7.f$$Shared52;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared52. */
  private Result p$$Shared52$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'u':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('i' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('t' == yyC) {

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = "unit";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select(" expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'S':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('I' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('_' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('u' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('n' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('i' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('t' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "SI_unit";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select(" expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.DimUnitDecl$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimUnitDecl$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fDimUnitDecl$$Star1) 
      yyColumn.chunk7.fDimUnitDecl$$Star1 = pDimUnitDecl$$Star1$1(yyStart);
    return yyColumn.chunk7.fDimUnitDecl$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.DimUnitDecl$$Star1. */
  private Result pDimUnitDecl$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pwr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id v$el$4 = yyResult.semanticValue();

        yyResult = pDimUnitDecl$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> v$5 = yyResult.semanticValue();

          yyValue = new Pair<Id>(v$el$4, v$5);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.DimUnitDecl$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimUnitDecl$$Star2(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fDimUnitDecl$$Star2) 
      yyColumn.chunk7.fDimUnitDecl$$Star2 = pDimUnitDecl$$Star2$1(yyStart);
    return yyColumn.chunk7.fDimUnitDecl$$Star2;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.DimUnitDecl$$Star2. */
  private Result pDimUnitDecl$$Star2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pwr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id v$el$10 = yyResult.semanticValue();

        yyResult = pDimUnitDecl$$Star2(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> v$11 = yyResult.semanticValue();

          yyValue = new Pair<Id>(v$el$10, v$11);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.TypeAlias.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeAlias(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fTypeAlias) 
      yyColumn.chunk7.fTypeAlias = pTypeAlias$1(yyStart);
    return yyColumn.chunk7.fTypeAlias;
  }

  /** Actually parse OtherDecl.TypeAlias. */
  private Result pTypeAlias$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<StaticParam> yyOpValue1;
    TypeAlias         yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptype(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticParams(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticParam> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<StaticParam> a2 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pequals(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pNoNewlineType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Type a3 = yyResult.semanticValue();

                    Span span = createSpan(yyStart,yyCount);
                    if (a2 == null) a2 = Collections.<StaticParam>emptyList();
                    Id id;
                    if ( a1 instanceof Id )
                    id = (Id)a1;
                    else {
                      log(span, a1 + " is not a valid type name.");
                      id = NodeFactory.bogusId(span);
                    }
                    yyValue = NodeFactory.makeTypeAlias(span, id, a2, a3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.TestDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTestDecl(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fTestDecl) 
      yyColumn.chunk7.fTestDecl = pTestDecl$1(yyStart);
    return yyColumn.chunk7.fTestDecl;
  }

  /** Actually parse OtherDecl.TestDecl. */
  private Result pTestDecl$1(final int yyStart) throws IOException {
    Result     yyResult;
    TestDecl   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pSymbol$opensquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineExpr$GeneratorClauseList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<GeneratorClause> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = p$$Shared7(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pequals(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pNoNewlineExpr(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Expr a3 = yyResult.semanticValue();

                              Span span = createSpan(yyStart,yyCount);
                              Id id;
                              if ( a1 instanceof Id )
                              id = (Id)a1;
                              else {
                                log(span, a1 + " is not a valid test name.");
                                id = NodeFactory.bogusId(span);
                              }
                              yyValue = NodeFactory.makeTestDecl(span, id, a2, a3);

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.PropertyDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPropertyDecl(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fPropertyDecl) 
      yyColumn.chunk7.fPropertyDecl = pPropertyDecl$1(yyStart);
    return yyColumn.chunk7.fPropertyDecl;
  }

  /** Actually parse OtherDecl.PropertyDecl. */
  private Result pPropertyDecl$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    PropertyDecl yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pproperty(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp v$el$1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a1.
        IdOrOp a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pFORALL(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pParameter$ValParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Param> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
        { // Start scope for a2.
          List<Param> a2 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              Option<Id> id;
              if ( a1 == null )
              id = Option.<Id>none();
              else {
                if ( a1 instanceof Id )
                id = Option.<Id>some((Id)a1);
                else {
                  log(span, a1 + " is not a valid test name.");
                  id = Option.<Id>none();
                }
              }
              if (a2 == null) a2 = Collections.<Param>emptyList();
              yyValue = NodeFactory.makePropertyDecl(span, id, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a2.
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.GrammarDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGrammarDef(final int yyStart) throws IOException {
    Result                  yyResult;
    int                     yyRepetition1;
    Pair<GrammarMemberDecl> yyRepValue1;
    int                     yyOption1;
    List<Id>                yyOpValue1;
    GrammarDecl             yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pnative(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pgrammar(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pbr(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pNonterminalDecl(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    GrammarMemberDecl v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = 
                      new Pair<GrammarMemberDecl>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
                break;
              }
              { // Start scope for a2s.
                Pair<GrammarMemberDecl> a2s = yyRepValue1.reverse();

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pend(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = new GrammarDecl(makeSpanInfo(yyStart,yyCount), a1,
                    Collections.<Id>emptyList(), a2s.list(),
                    Collections.<TransformerDecl>emptyList(),
                    /* native */ true);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a2s.
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pgrammar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pGrammarExtends(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Id> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a2.
            List<Id> a2 = yyOpValue1;

            yyRepetition1 = yyOption1;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pbr(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNonterminalDef(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  GrammarMemberDecl v$el$3 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = 
                    new Pair<GrammarMemberDecl>(v$el$3, yyRepValue1);
                  continue;
                }
              }
              break;
            }
            { // Start scope for a3s.
              Pair<GrammarMemberDecl> a3s = yyRepValue1.reverse();

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pend(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  if ( a2 == null) a2 = Collections.<Id>emptyList();
                  yyValue = new GrammarDecl(makeSpanInfo(yyStart,yyCount), a1, a2, a3s.list(),
                  Collections.<TransformerDecl>emptyList(),
                  /* native */ false);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a3s.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.GrammarExtends.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGrammarExtends(final int yyStart) throws IOException {
    Result     yyResult;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pextends(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pQualifiedNames(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.QualifiedNames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedNames(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Id>   yyRepValue1;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pQualifiedName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pQualifiedName(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Id v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = new Pair<Id>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<Id> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSymbol$commaOrNot(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pQualifiedName(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Id v$el$2 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = new Pair<Id>(v$el$2, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<Id> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                log(createSpan(yyStart,yyCount), "Missing comma.");
                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 3.

          yyResult = pw(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = Useful.list(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.NonterminalDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonterminalDef(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<SyntaxDecl>  yyRepValue1;
    int               yyOption1;
    BaseType          yyOpValue1;
    GrammarMemberDecl yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id name = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSyntax$bar(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcolonequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pSyntaxExtensionDef(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  SyntaxDecl a1 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = Pair.empty();
                  while (true) {

                    yyResult = pw(yyRepetition1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pSyntaxExtensionDefOr(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        SyntaxDecl v$el$2 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = 
                          new Pair<SyntaxDecl>(v$el$2, yyRepValue1);
                        continue;
                      }
                    }
                    break;
                  }
                  { // Start scope for a2s.
                    Pair<SyntaxDecl> a2s = yyRepValue1.reverse();

                    List<SyntaxDecl> syntaxDefs = a2s.list();
                    syntaxDefs.add(0, a1);
                    yyValue = new NonterminalExtensionDef(makeSpanInfo(yyStart,yyCount), name,
                    syntaxDefs);

                    return new SemanticValue(yyValue, yyRepetition1, yyError);
                  } // End scope for a2s.
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pNonterminalHeader(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NonterminalHeader header = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSyntax$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$TraitType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              BaseType v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
          { // Start scope for astType.
            BaseType astType = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcolonequals(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pSyntaxDef(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    SyntaxDecl a1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = Pair.empty();
                    while (true) {

                      yyResult = pw(yyRepetition1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pSyntaxDefOr(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          SyntaxDecl v$el$4 = yyResult.semanticValue();

                          yyRepetition1 = yyResult.index;
                          yyRepValue1   = 
                            new Pair<SyntaxDecl>(v$el$4, yyRepValue1);
                          continue;
                        }
                      }
                      break;
                    }
                    { // Start scope for a2s.
                      Pair<SyntaxDecl> a2s = yyRepValue1.reverse();

                      List<SyntaxDecl> syntaxDefs = a2s.list();
                      syntaxDefs.add(0, a1);
                      yyValue = new NonterminalDef(makeSpanInfo(yyStart,yyCount),
                      header.getName(), syntaxDefs, header,
                      Option.<BaseType>wrap(astType));

                      return new SemanticValue(yyValue, yyRepetition1, yyError);
                    } // End scope for a2s.
                  }
                }
              }
            }
          } // End scope for astType.
        }
      }
    }

    // Alternative 3.

    yyResult = pNonterminalDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.NonterminalDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonterminalDecl(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fNonterminalDecl) 
      yyColumn.chunk7.fNonterminalDecl = pNonterminalDecl$1(yyStart);
    return yyColumn.chunk7.fNonterminalDecl;
  }

  /** Actually parse Syntax.NonterminalDecl. */
  private Result pNonterminalDecl$1(final int yyStart) throws IOException {
    Result            yyResult;
    GrammarMemberDecl yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNonterminalHeader(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NonterminalHeader header = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSyntax$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$TraitType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              BaseType astType = yyResult.semanticValue();

              yyValue = new NonterminalDef(makeSpanInfo(yyStart,yyCount),
              header.getName(),
              Collections.<SyntaxDecl>emptyList(), header,
              Option.<BaseType>wrap(astType));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.NonterminalHeader.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonterminalHeader(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fNonterminalHeader) 
      yyColumn.chunk8.fNonterminalHeader = pNonterminalHeader$1(yyStart);
    return yyColumn.chunk8.fNonterminalHeader;
  }

  /** Actually parse Syntax.NonterminalHeader. */
  private Result pNonterminalHeader$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    Object            yyOpValue1;
    NonterminalHeader yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pprivate(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      yyResult = pId(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id name = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSyntax$Params(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<NonterminalParameter> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for params.
          List<NonterminalParameter> params = cast(yyOpValue1);

          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticParams(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticParam> v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
          { // Start scope for staticParams.
            List<StaticParam> staticParams = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pSyntax$colon(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pType$Type(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type v$el$4 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$4;
              }
            }
            { // Start scope for type.
              Type type = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pWhere(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  WhereClause v$el$5 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$5;
                }
              }
              { // Start scope for whereClauses.
                WhereClause whereClauses = cast(yyOpValue1);

                Modifiers mod = (a1 == null) ? Modifiers.None : Modifiers.Private;
                if (params == null) params = Collections.<NonterminalParameter>emptyList();
                if (staticParams == null) staticParams = Collections.<StaticParam>emptyList();
                if (whereClauses != null) NodeUtil.checkWhereClauses(writer, whereClauses);
                yyValue = new NonterminalHeader(makeSpanInfo(yyStart, yyCount),
                mod, name, params, staticParams,
                Option.<Type>wrap(type),
                Option.<WhereClause>wrap(whereClauses));

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for whereClauses.
            } // End scope for type.
          } // End scope for staticParams.
        } // End scope for params.
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$Params(final int yyStart) throws IOException {
    Result                     yyResult;
    int                        yyRepetition1;
    boolean                    yyRepeated1;
    Pair<NonterminalParameter> yyRepValue1;
    List<NonterminalParameter> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSyntax$Param(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          NonterminalParameter a1 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pSyntax$Param(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    NonterminalParameter v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = 
                      new Pair<NonterminalParameter>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<NonterminalParameter> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSymbol$commaOrNot(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pSyntax$Param(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    NonterminalParameter v$el$2 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = 
                      new Pair<NonterminalParameter>(v$el$2, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<NonterminalParameter> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                log(createSpan(yyStart,yyCount), "Missing comma.");
                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 3.

          yyResult = pw(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = Useful.list(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Param.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$Param(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fSyntax$Param) 
      yyColumn.chunk8.fSyntax$Param = pSyntax$Param$1(yyStart);
    return yyColumn.chunk8.fSyntax$Param;
  }

  /** Actually parse Syntax.Param. */
  private Result pSyntax$Param$1(final int yyStart) throws IOException {
    Result               yyResult;
    NonterminalParameter yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pSyntax$colon(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$TraitType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BaseType a2 = yyResult.semanticValue();

          yyValue = new NonterminalParameter(makeSpanInfo(yyStart,yyCount),
          a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SyntaxDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxDef(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fSyntaxDef) 
      yyColumn.chunk8.fSyntaxDef = pSyntaxDef$1(yyStart);
    return yyColumn.chunk8.fSyntaxDef;
  }

  /** Actually parse Syntax.SyntaxDef. */
  private Result pSyntaxDef$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    String     yyOpValue1;
    SyntaxDecl yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pprivate(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for mods.
      String mods = yyOpValue1;

      yyResult = pSyntaxSymbols(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<SyntaxSymbol> a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pseparator(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pPreTransformerDecl(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TransformerDecl a2 = yyResult.semanticValue();

                yyValue = NodeFactory.makeSyntaxDef(createSpan(yyStart,yyCount),
                Option.<String>wrap(mods), a1, a2);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    } // End scope for mods.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SyntaxExtensionDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxExtensionDef(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fSyntaxExtensionDef) 
      yyColumn.chunk8.fSyntaxExtensionDef = pSyntaxExtensionDef$1(yyStart);
    return yyColumn.chunk8.fSyntaxExtensionDef;
  }

  /** Actually parse Syntax.SyntaxExtensionDef. */
  private Result pSyntaxExtensionDef$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    SyntaxDecl yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSyntaxDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pSuperChoiceModifier(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$2 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
    }
    { // Start scope for mods.
      String mods = yyOpValue1;

      yyResult = pId(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id nt = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('f' == yyC) {
            yyIndex = yyResult.index + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('o' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('m' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pw(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pId(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Id grammar = yyResult.semanticValue();

                      yyValue = NodeFactory.makeSuperSyntaxDef(createSpan(yyStart,yyCount),
                      Option.<String>wrap(mods), nt,
                      grammar);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                } else {
                  yyError = yyError.select("\"from\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"from\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"from\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"from\" expected", yyBase);
          }
        }
      }
    } // End scope for mods.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SyntaxDefOr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxDefOr(final int yyStart) throws IOException {
    Result     yyResult;
    SyntaxDecl yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSyntax$bar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSyntaxDef(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SyntaxExtensionDefOr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxExtensionDefOr(final int yyStart) throws IOException {
    Result     yyResult;
    SyntaxDecl yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSyntax$bar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSyntaxExtensionDef(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SuperChoiceModifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSuperChoiceModifier(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'p':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('r' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('i' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('v' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('a' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('t' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('e' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "private";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("super choice modifier expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'w':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('i' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('t' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('h' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('o' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('u' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('t' == yyC) {

                                  yyValue = "without";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("super choice modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.PreTransformerDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreTransformerDecl(final int yyStart) throws IOException {
    Result          yyResult;
    TransformerDecl yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPreTransformer(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Transformer transformer = yyResult.semanticValue();

      yyValue = new PreTransformerDef(makeSpanInfo(yyStart,yyCount),
      transformer);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.PreTransformer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreTransformer(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fPreTransformer) 
      yyColumn.chunk8.fPreTransformer = pPreTransformer$1(yyStart);
    return yyColumn.chunk8.fPreTransformer;
  }

  /** Actually parse Syntax.PreTransformer. */
  private Result pPreTransformer$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    Id          yyOpValue1;
    Transformer yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id pvar = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pof(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pCaseTransformerClauses(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<CaseTransformerClause> clauses = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pend(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyValue = new CaseTransformer(makeSpanInfo(yyStart,yyCount),
                      pvar, clauses);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pId(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for nt.
      Id nt = yyOpValue1;

      yyResult = pleftDelimiter(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pAnythingButRightDelimiter(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a1 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = prightDelimiter(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                Span span = createSpan(yyStart,yyCount);
                if (nt == null) nt = NodeFactory.makeId(span, "Expr"); // ????? -- Sukyoung
                yyValue = new UnparsedTransformer(NodeFactory.makeSpanInfo(span), a1, nt);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    } // End scope for nt.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.CaseTransformerClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseTransformerClauses(final int yyStart) 
    throws IOException {

    Result                      yyResult;
    int                         yyRepetition1;
    Pair<CaseTransformerClause> yyRepValue1;
    List<CaseTransformerClause> yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCaseTransformerClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CaseTransformerClause a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pCaseTransformerClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            CaseTransformerClause v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = 
              new Pair<CaseTransformerClause>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<CaseTransformerClause> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.CaseTransformerClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseTransformerClause(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fCaseTransformerClause) 
      yyColumn.chunk8.fCaseTransformerClause = pCaseTransformerClause$1(yyStart);
    return yyColumn.chunk8.fCaseTransformerClause;
  }

  /** Actually parse Syntax.CaseTransformerClause. */
  private Result pCaseTransformerClause$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    int                   yyOption1;
    List<Id>              yyOpValue1;
    CaseTransformerClause yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id c = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = popenparen(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBindIdList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Id> v$el$1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$1;
                  }
                }
              }
            }
          }
        }
        { // Start scope for gaps.
          List<Id> gaps = yyOpValue1;

          yyResult = pseparator(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pPreTransformer(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Transformer transformer = yyResult.semanticValue();

                if (gaps == null) gaps = Collections.<Id>emptyList();
                yyValue = new CaseTransformerClause(makeSpanInfo(yyStart,yyCount),
                c, gaps, transformer);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        } // End scope for gaps.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.AnythingButRightDelimiter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnythingButRightDelimiter(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ']':
          {
            yyPredMatched = false;

            yyC = character(yyIndex);
            if ('>' == yyC) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyRepetition1 = yyIndex;
              continue;
            } else {
              yyError = yyError.select("anything but right delimiter expected", yyStart);
            }
          }
          break;

        default:
          {
            yyRepetition1 = yyIndex;
            continue;
          }
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SyntaxSymbols.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxSymbols(final int yyStart) throws IOException {
    Result                   yyResult;
    Result                   yyPredResult;
    int                      yyRepetition1;
    Pair<List<SyntaxSymbol>> yyRepValue1;
    List<SyntaxSymbol>       yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSyntaxSymbol(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SyntaxSymbol a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSymbs(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<SyntaxSymbol> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<List<SyntaxSymbol>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<List<SyntaxSymbol>> a2s = yyRepValue1.reverse();

        yyPredResult = pw(yyRepetition1);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pseparator(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            List<SyntaxSymbol> ls = Useful.list(a1);
            for ( List<SyntaxSymbol> sl: a2s.list() ) ls.addAll(sl);
            yyValue = ls;

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }
        }
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SyntaxSymbolsX.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxSymbolsX(final int yyStart) throws IOException {
    Result                   yyResult;
    int                      yyRepetition1;
    Pair<List<SyntaxSymbol>> yyRepValue1;
    List<SyntaxSymbol>       yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSyntaxSymbol(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SyntaxSymbol a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSymbs(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<SyntaxSymbol> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<List<SyntaxSymbol>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<List<SyntaxSymbol>> a2s = yyRepValue1.reverse();

        List<SyntaxSymbol> ls = Useful.list(a1);
        for ( List<SyntaxSymbol> sl: a2s.list() ) ls.addAll(sl);
        yyValue = ls;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Symbs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbs(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fSymbs) 
      yyColumn.chunk8.fSymbs = pSymbs$1(yyStart);
    return yyColumn.chunk8.fSymbs;
  }

  /** Actually parse Syntax.Symbs. */
  private Result pSymbs$1(final int yyStart) throws IOException {
    Result             yyResult;
    List<SyntaxSymbol> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbs$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<SyntaxSymbol> a1s = yyResult.semanticValue();

      yyResult = pSyntaxSymbol(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        SyntaxSymbol a2 = yyResult.semanticValue();

        yyValue = Useful.list(a1s.list(), a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Symbs$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbs$$Plus1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fSymbs$$Plus1) 
      yyColumn.chunk8.fSymbs$$Plus1 = pSymbs$$Plus1$1(yyStart);
    return yyColumn.chunk8.fSymbs$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.Symbs$$Plus1. */
  private Result pSymbs$$Plus1$1(final int yyStart) throws IOException {
    Result             yyResult;
    Pair<SyntaxSymbol> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpaceOrBreakline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SyntaxSymbol v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pSymbs$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<SyntaxSymbol> v$2 = yyResult.semanticValue();

        yyValue = new Pair<SyntaxSymbol>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<SyntaxSymbol>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SpaceOrBreakline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpaceOrBreakline(final int yyStart) throws IOException {
    Result       yyResult;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSyntax$sr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new WhitespaceSymbol(makeSpanInfo(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pbreakline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new BreaklineSymbol(makeSpanInfo(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SyntaxSymbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxSymbol(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fSyntaxSymbol) 
      yyColumn.chunk8.fSyntaxSymbol = pSyntaxSymbol$1(yyStart);
    return yyColumn.chunk8.fSyntaxSymbol;
  }

  /** Actually parse Syntax.SyntaxSymbol. */
  private Result pSyntaxSymbol$1(final int yyStart) throws IOException {
    Result       yyResult;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbolMod(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          SyntaxSymbol a1 = yyResult.semanticValue();

          if (a1 instanceof NoWhitespaceSymbol) {
            SyntaxSymbol tmp = ((NoWhitespaceSymbol) a1).getSymbol();
            yyValue = new NoWhitespaceSymbol(makeSpanInfo(yyStart,yyCount),
            new NotPredicateSymbol(a1.getInfo(), tmp));
          } else yyValue = new NotPredicateSymbol(makeSpanInfo(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pAnd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbolMod(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          SyntaxSymbol a1 = yyResult.semanticValue();

          if (a1 instanceof NoWhitespaceSymbol) {
            SyntaxSymbol tmp = ((NoWhitespaceSymbol) a1).getSymbol();
            yyValue = new NoWhitespaceSymbol(makeSpanInfo(yyStart,yyCount),
            new AndPredicateSymbol(a1.getInfo(), tmp));
          }
          else yyValue = new AndPredicateSymbol(makeSpanInfo(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pSymbolMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SymbolMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbolMod(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fSymbolMod) 
      yyColumn.chunk8.fSymbolMod = pSymbolMod$1(yyStart);
    return yyColumn.chunk8.fSymbolMod;
  }

  /** Actually parse Syntax.SymbolMod. */
  private Result pSymbolMod$1(final int yyStart) throws IOException {
    Result       yyResult;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSingle(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SyntaxSymbol a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pquestionmark(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        if ( a1 instanceof NoWhitespaceSymbol ) {
          SyntaxSymbol tmp = ((NoWhitespaceSymbol)a1).getSymbol();
          yyValue = new NoWhitespaceSymbol(makeSpanInfo(yyStart,yyCount),
          new OptionalSymbol(a1.getInfo(), tmp));
        } else yyValue = new OptionalSymbol(makeSpanInfo(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pSyntax$star(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        if ( a1 instanceof NoWhitespaceSymbol ) {
          SyntaxSymbol tmp = ((NoWhitespaceSymbol)a1).getSymbol();
          yyValue = new NoWhitespaceSymbol(makeSpanInfo(yyStart,yyCount),
          new RepeatSymbol(a1.getInfo(), tmp));
        } else yyValue = new RepeatSymbol(makeSpanInfo(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pSyntax$plus(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        if ( a1 instanceof NoWhitespaceSymbol ) {
          SyntaxSymbol tmp = ((NoWhitespaceSymbol)a1).getSymbol();
          yyValue = new NoWhitespaceSymbol(makeSpanInfo(yyStart,yyCount),
          new RepeatOneOrMoreSymbol(a1.getInfo(), tmp));
        } else yyValue = new RepeatOneOrMoreSymbol(makeSpanInfo(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSingle(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Single.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingle(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fSingle) 
      yyColumn.chunk9.fSingle = pSingle$1(yyStart);
    return yyColumn.chunk9.fSingle;
  }

  /** Actually parse Syntax.Single. */
  private Result pSingle$1(final int yyStart) throws IOException {
    Result       yyResult;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGroupSymbol(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pBaseSymbol(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SyntaxSymbol a1 = yyResult.semanticValue();

      SpanInfo info = makeSpanInfo(yyStart,yyCount);
      if ( a1 instanceof NoWhitespaceSymbol ) {
        List<SyntaxSymbol> tmp =
        Useful.list(((NoWhitespaceSymbol) a1).getSymbol());
        yyValue = new NoWhitespaceSymbol(info, new GroupSymbol(info, tmp));
      } else yyValue = new GroupSymbol(info, Useful.list(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.BaseSymbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBaseSymbol(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Id           yyOpValue1;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pId(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id v$el$1 = yyResult.semanticValue();

      yyResult = pSyntax$colon(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      Id a1 = yyOpValue1;

      yyResult = pSyntax$Symbol(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        SyntaxSymbol a2 = yyResult.semanticValue();

        if (a1 != null) {
          if (a2 instanceof NoWhitespaceSymbol) {
            SyntaxSymbol tmp = ((NoWhitespaceSymbol) a2).getSymbol();
            yyValue = new NoWhitespaceSymbol(makeSpanInfo(yyStart,yyCount),
            new PrefixedSymbol(a2.getInfo(), a1, tmp));
          } else yyValue = new PrefixedSymbol(makeSpanInfo(yyStart,yyCount), a1, a2);
        } else yyValue = a2;

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.GroupSymbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGroupSymbol(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyBase;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pw(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSyntaxSymbolsX(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<SyntaxSymbol> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('}' == yyC) {
              yyIndex = yyResult.index + 1;

              yyValue = new GroupSymbol(makeSpanInfo(yyStart, yyCount), a1);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"}\" expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("group symbol expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$Symbol(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    String       yyOpValue1;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pItem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SyntaxSymbol a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = phash(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for a2.
        String a2 = yyOpValue1;

        if (a2 == null) yyValue = a1;
        else yyValue = new NoWhitespaceSymbol(makeSpanInfo(yyStart,yyCount), a1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Item.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pItem(final int yyStart) throws IOException {
    Result                yyResult;
    Result                yyPredResult;
    boolean               yyPredMatched;
    int                   yyRepetition1;
    Pair<CharacterSymbol> yyRepValue1;
    SyntaxSymbol          yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pw(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredResult = pseparator(yyPredResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }
    }

    if (! yyPredMatched) {

      yyResult = pItemText(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a = yyResult.semanticValue();

        yyValue = new ItemSymbol(makeSpanInfo(yyStart,yyCount), a);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("item expected", yyStart);
    }

    // Alternative 2.

    yyResult = pSyntax$opensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCharacterClass(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          CharacterSymbol v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<CharacterSymbol>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a1s.
        Pair<CharacterSymbol> a1s = yyRepValue1.reverse();

        yyResult = p$$Shared7(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new CharacterClassSymbol(makeSpanInfo(yyStart,yyCount),
          a1s.list());

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for a1s.
    }

    // Alternative 3.

    yyResult = punderscore(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new AnyCharacterSymbol(makeSpanInfo(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pTab(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new TabSymbol(makeSpanInfo(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pFormfeed(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new FormfeedSymbol(makeSpanInfo(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pReturn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new CarriageReturnSymbol(makeSpanInfo(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pSyntax$Newline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new NewlineSymbol(makeSpanInfo(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pSyntax$Space(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new WhitespaceSymbol(makeSpanInfo(yyStart,yyCount), " ");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pBackspace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new BackspaceSymbol(makeSpanInfo(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.CharacterClass.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterClass(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    String          yyOpValue1;
    CharacterSymbol yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pChar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pSyntax$colon(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pChar(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        String a2 = yyOpValue1;

        if (a2 != null)
        yyValue = new CharacterInterval(makeSpanInfo(yyStart,yyCount), a1, a2);
        else yyValue = new CharSymbol(makeSpanInfo(yyStart,yyCount), a1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Char.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pChar(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fChar) 
      yyColumn.chunk9.fChar = pChar$1(yyStart);
    return yyColumn.chunk9.fChar;
  }

  /** Actually parse Syntax.Char. */
  private Result pChar$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTab(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "\t";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pFormfeed(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "\f";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pReturn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "\r";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pSyntax$Newline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "\n";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pSyntax$Space(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = " ";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pBackspace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "\u2408";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = putf16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.ItemText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pItemText(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pSpecialSymbols(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = putf16(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        while (true) {

          yyResult = putf16(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            continue;
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    } else {
      yyError = yyError.select("item text expected", yyStart);
    }

    // Alternative 2.

    yyResult = pSpecialSymbols(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      while (true) {

        yyResult = putf16(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          continue;
        }
        break;
      }

      if (yyRepeated1) {

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.utf16.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result putf16(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.futf16) 
      yyColumn.chunk9.futf16 = putf16$1(yyStart);
    return yyColumn.chunk9.futf16;
  }

  /** Actually parse Syntax.utf16. */
  private Result putf16$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('`' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = pSpecialChars(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pSpecialSymbols(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyPredMatched = false;

    yyPredResult = pSpecialChars(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        if (('\u0000' <= yyC) && (yyC <= '\uffff')) {

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    } else {
      yyError = yyError.select("utf16 expected", yyStart);
    }

    // Done.
    yyError = yyError.select("utf16 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SpecialChars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpecialChars(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fSpecialChars) 
      yyColumn.chunk9.fSpecialChars = pSpecialChars$1(yyStart);
    return yyColumn.chunk9.fSpecialChars;
  }

  /** Actually parse Syntax.SpecialChars. */
  private Result pSpecialChars$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('\n' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyPredMatched = false;

          yyC = character(yyChoice1);
          if ('\n' == yyC) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyChoice1, yyError);
          } else {
            yyError = yyError.select("special chars expected", yyStart);
          }
        }
        break;

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u2028':
      case '\u2029':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '?':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '#':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '+':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '*':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '`':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '|':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("special chars expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SpecialSymbols.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpecialSymbols(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fSpecialSymbols) 
      yyColumn.chunk9.fSpecialSymbols = pSpecialSymbols$1(yyStart);
    return yyColumn.chunk9.fSpecialSymbols;
  }

  /** Actually parse Syntax.SpecialSymbols. */
  private Result pSpecialSymbols$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'T':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('A' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('B' == yyC) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case 'F':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('O' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('R' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('M' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('F' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('E' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('E' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('D' == yyC) {

                                      yyValue = null;

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'R':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('E' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('T' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('U' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('R' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('N' == yyC) {

                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'N':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'E':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('W' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('L' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('I' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('N' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('E' == yyC) {

                                    yyValue = null;

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'O':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('T' == yyC) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'S':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('P' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('A' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('C' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('E' == yyC) {

                          yyValue = null;

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'B':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('A' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('C' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('K' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('S' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('P' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('A' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('C' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('E' == yyC) {

                                          yyValue = null;

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'A':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('N' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('D' == yyC) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('>' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("special symbols expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.bar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$bar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("bar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.hash.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result phash(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('#' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = "#";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("hash expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.colon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$colon(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("colon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.plus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$plus(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("plus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.questionmark.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pquestionmark(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('?' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("questionmark expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.star.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$star(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("star expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.opensquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$opensquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("opensquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared7.
   * This nonterminal represents the duplicate productions Syntax.closesquare 
   * and Symbol.closesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared7(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.separator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pseparator(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("separator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.leftDelimiter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftDelimiter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('[' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("left delimiter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.rightDelimiter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightDelimiter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("right delimiter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.And.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnd(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('A' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('N' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('D' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("and expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Backspace.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBackspace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('B' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('A' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('C' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('K' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('S' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('P' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('A' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('C' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('E' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("backspace expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Formfeed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormfeed(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('F' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('O' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('R' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('M' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('F' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('E' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('E' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('D' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("formfeed expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Newline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$Newline(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('N' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('E' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('W' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('L' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('I' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('N' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('E' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("newline expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Not.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNot(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('N' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('O' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('T' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("not expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Return.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pReturn(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('R' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('E' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('T' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('U' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('R' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('N' == yyC) {
                yyIndex = yyIndex + 1;

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("return expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$Space(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('S' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('P' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('A' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('C' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('E' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Tab.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTab(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('T' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('A' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('B' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("tab expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.sr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$sr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pspace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pspace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.breakline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbreakline(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('\n' == yyC) {

              yyValue = "\r\n";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyPredMatched = false;

          yyC = character(yyChoice1);
          if ('\n' == yyC) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "\r";

            return new SemanticValue(yyValue, yyChoice1, yyError);
          } else {
            yyError = yyError.select("breakline expected", yyStart);
          }
        }
        break;

      case '\n':
        {
          yyValue = "\n";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u2028':
      case '\u2029':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("breakline expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$Type(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fType$Type) 
      yyColumn.chunk9.fType$Type = pType$Type$1(yyStart);
    return yyColumn.chunk9.fType$Type;
  }

  /** Actually parse Type.Type. */
  private Result pType$Type$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyOption1;
    Expr       yyOpValue1;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pone(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyOption1  = yyStart;

      yyResult = pio(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      yyResult = pType$TypePrimary(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pin(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression$Expr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = yyOpValue1;

          Type ty = TypeResolver.resolveOps(a1);
          Span span = NodeUtil.getSpan(ty);
          if (a2 == null)
          yyValue = ty;
          else {
            if (ty instanceof TaggedDimType) {
              TaggedDimType _ty = (TaggedDimType)ty;
              yyValue = NodeFactory.makeTaggedDimType(span, false,
              _ty.getElemType(),
              _ty.getDimExpr(),
              Option.<Expr>some(a2));
            } else {
              log(span, "A dimension type is expected.");
              yyValue = ty;
            }
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    } else {
      yyError = yyError.select("type expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.OpType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$OpType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fType$OpType) 
      yyColumn.chunk9.fType$OpType = pType$OpType$1(yyStart);
    return yyColumn.chunk9.fType$OpType;
  }

  /** Actually parse Type.OpType. */
  private Result pType$OpType$1(final int yyStart) throws IOException {
    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$TypePrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pType$TypePrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypePrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypePrimary(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fType$TypePrimary) 
      yyColumn.chunk9.fType$TypePrimary = pType$TypePrimary$1(yyStart);
    return yyColumn.chunk9.fType$TypePrimary;
  }

  /** Actually parse Type.TypePrimary. */
  private Result pType$TypePrimary$1(final int yyStart) throws IOException {
    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$TypePrimaryFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealType(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealType(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pType$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealType(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 3.

      yyValue = PureList.make((PostfixOpExpr)new RealType(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypePrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypePrefix(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fType$TypePrefix) 
      yyColumn.chunk9.fType$TypePrefix = pType$TypePrefix$1(yyStart);
    return yyColumn.chunk9.fType$TypePrefix;
  }

  /** Actually parse Type.TypePrefix. */
  private Result pType$TypePrefix$1(final int yyStart) throws IOException {
    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared12(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pType$TypePrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    int                     yyOption1;
    List<Type>              yyOpValue1;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared10(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pThrows(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Type> v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
        { // Start scope for a3.
          List<Type> a3 = yyOpValue1;

          yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1, NodeFactory.makeEffect(Option.<List<Type>>wrap(a3))));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }

      // Nested alternative 2.

      yyResult = pType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pThrows(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Type> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<Type> a3 = yyOpValue1;

          yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1, NodeFactory.makeEffect(Option.<List<Type>>wrap(a3))));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }
    }

    // Alternative 2.

    yyResult = p$$Shared11(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = p$$Shared13(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pType$TypePrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyValue = PureList.make((PostfixOpExpr)new Postfix(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.LooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$LooseInfix(final int yyStart) throws IOException {
    Result                  yyResult;
    int                     yyOption1;
    List<Type>              yyOpValue1;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared10(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pType$TypePrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Type> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a3.
            List<Type> a3 = yyOpValue1;

            yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1, NodeFactory.makeEffect(Option.<List<Type>>wrap(a3))));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }

        // Nested alternative 2.

        yyResult = pType$TypePrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Type> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a3.
            List<Type> a3 = yyOpValue1;

            yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1, NodeFactory.makeEffect(Option.<List<Type>>wrap(a3))));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared11(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pType$TypePrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pType$TypePrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypePrimaryFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypePrimaryFront(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    boolean            yyRepeated1;
    Pair<Action<Type>> yyRepValue1;
    Type               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$TypeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pType$TypeTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<Type> v$el$2 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Action<Type>>(v$el$2, yyRepValue1);
          continue;
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Action<Type>> list = yyRepValue1.reverse();

        yyValue = (Type)apply(list, (Type)seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Alternative 2.

    yyResult = pType$TypeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypeFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypeFront(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fType$TypeFront) 
      yyColumn.chunk9.fType$TypeFront = pType$TypeFront$1(yyStart);
    return yyColumn.chunk9.fType$TypeFront;
  }

  /** Actually parse Type.TypeFront. */
  private Result pType$TypeFront$1(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$ParenthesizedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pType$Domain(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pType$TupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pone(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = NodeFactory.makeDimBase(createSpan(yyStart,1), false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.ParenthesizedType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$ParenthesizedType(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fType$ParenthesizedType) 
      yyColumn.chunk10.fType$ParenthesizedType = pType$ParenthesizedType$1(yyStart);
    return yyColumn.chunk10.fType$ParenthesizedType;
  }

  /** Actually parse Type.ParenthesizedType. */
  private Result pType$ParenthesizedType$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$Type(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.Domain.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$Domain(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<Object> yyRepValue1;
    int          yyOption1;
    Type         yyOpValue1;
    Type         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pType$Type(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type v$el$1 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<Object>(v$el$1, yyRepValue1);
                  continue;
                }
              }
            }
          }
          break;
        }
        { // Start scope for a1s.
          Pair<Type> a1s = cast(yyRepValue1.reverse());

          final int yyChoice1 = yyRepetition1;

          // Nested alternative 1.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pType$Type(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type v$el$2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$2;
                    }
                  }
                }
              }
            }
          }
          { // Start scope for a2.
            Type a2 = yyOpValue1;

            yyResult = pType$KeywordType(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              KeywordType a3 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pType$KeywordType(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        KeywordType v$el$3 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = new Pair<Object>(v$el$3, yyRepValue1);
                        continue;
                      }
                    }
                  }
                }
                break;
              }
              { // Start scope for a4s.
                Pair<KeywordType> a4s = cast(yyRepValue1.reverse());

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<KeywordType> ts3 = a4s.list();
                    ts3.add(0, a3);
                    yyValue = NodeFactory.makeDomain(createSpan(yyStart,yyCount),
                    a1s.list(), Option.<Type>wrap(a2), ts3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a4s.
            }
          } // End scope for a2.

          // Nested alternative 2.

          yyResult = pType$Type(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = NodeFactory.makeDomain(createSpan(yyStart,yyCount),
                    Useful.list(a1s.list()),
                    Option.<Type>some(a2),
                    Collections.<KeywordType>emptyList());

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        } // End scope for a1s.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.KeywordType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$KeywordType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fType$KeywordType) 
      yyColumn.chunk10.fType$KeywordType = pType$KeywordType$1(yyStart);
    return yyColumn.chunk10.fType$KeywordType;
  }

  /** Actually parse Type.KeywordType. */
  private Result pType$KeywordType$1(final int yyStart) throws IOException {
    Result      yyResult;
    KeywordType yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$Type(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeKeywordType(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TupleType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TupleType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fType$TupleType) 
      yyColumn.chunk10.fType$TupleType = pType$TupleType$1(yyStart);
    return yyColumn.chunk10.fType$TupleType;
  }

  /** Actually parse Type.TupleType. */
  private Result pType$TupleType$1(final int yyStart) throws IOException {
    Result     yyResult;
    TupleType  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$Type(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pType$TypeList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Type> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyValue = NodeFactory.makeTupleType(createSpan(yyStart,yyCount),
                      Useful.cons(a1, a2));

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypeList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Type> yyRepValue1;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pType$Type(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Type>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Type> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared26.
   * This nonterminal represents the duplicate productions Type.TypeRef 
   * and NoNewlineType.TypeRef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared26(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.f$$Shared26) 
      yyColumn.chunk10.f$$Shared26 = p$$Shared26$1(yyStart);
    return yyColumn.chunk10.f$$Shared26;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared26. */
  private Result p$$Shared26$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('U' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('y' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue = NodeFactory.makeDimBase(createSpan(yyStart,yyCount), false);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makeTraitType(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyValue = NodeFactory.makeVarType(createSpan(yyStart,yyCount), a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared14(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeVarType(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared8.
   * This nonterminal represents the duplicate productions Type.VoidType 
   * and NoNewlineType.VoidType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared8(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.f$$Shared8) 
      yyColumn.chunk10.f$$Shared8 = p$$Shared8$1(yyStart);
    return yyColumn.chunk10.f$$Shared8;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared8. */
  private Result p$$Shared8$1(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = NodeFactory.makeVoidType(createSpan(yyStart,yyCount));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypeTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypeTail(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<ExtentRange> yyRepValue1;
    int               yyOption1;
    Indices           yyOpValue1;
    Action<Type>      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$opensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$ArraySize(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Indices v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        final Indices a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared7(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Action<Type>() {
              public Type run(Type base) {
                Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
                createSpan(yyStart,yyCount));
                if (NodeUtil.isExponentiation((Type)base)) {
                  log(span, "An exponentiation/vector type/array type should " +
                  "not be immediately followed by a left square bracket.");
                  return base;
                } else
                return NodeFactory.makeArrayType(span, (Type)base,
                Option.<Indices>wrap(a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = phasW(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Boolean a1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pIntExpr(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final IntExpr a2 = yyResult.semanticValue();

          yyValue = new Action<Type>() {
            public Type run(Type base) {
              Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
              createSpan(yyStart,yyCount));
              if ( a1.booleanValue() )
              log(span, "Space is not allowed immediately after '^'.");
              if ( NodeUtil.isExponentiation((Type)base) ||
              NodeUtil.isExponentiation(a2) ) {
                log(span, "An exponentiation should not be immediately " +
                "followed by an exponentiation.");
                return base;
              } else if (base instanceof DimExpr) {
                return NodeFactory.makeDimExponent(span, false, (DimExpr)base,
                a2);
              } else { // !(base instanceof DimExpr)
                return NodeFactory.makeDimExponent(span, false, (Type)base, a2);
              }
          }};

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = popenparen(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$ExtentRange(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final ExtentRange a2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcross(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pType$ExtentRange(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        final ExtentRange v$el$1 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = 
                          new Pair<ExtentRange>(v$el$1, yyRepValue1);
                        continue;
                      }
                    }
                  }
                }
                break;
              }
              { // Start scope for a3s.
                final Pair<ExtentRange> a3s = yyRepValue1.reverse();

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = new Action<Type>() {
                      public Type run(Type base) {
                        Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
                        createSpan(yyStart,yyCount));
                        if ( a1.booleanValue() )
                        log(span, "Space is not allowed immediately after '^'.");
                        if ( NodeUtil.isExponentiation((Type)base) ) {
                          log(span, "An exponentiation should not be immediately " +
                          "followed by an exponentiation.");
                          return base;
                        } else
                        return NodeFactory.makeMatrixType(span, (Type)base, a2,
                        a3s.list());
                    }};

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a3s.
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$MayParenthesizedOpType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final PureList<PostfixOpExpr> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = new Action<Type>() {
                public Type run(Type base) {
                  DimExpr dim = TypeResolver.resolveOpsDim(a1);
                  Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
                  createSpan(yyStart,yyCount));
                  return NodeFactory.makeTaggedDimType(span, false, (Type)base,
                  NodeFactory.makeInParentheses(dim),
                  Option.<Expr>none());
              }};

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Id a1 = yyResult.semanticValue();

      yyValue = new Action<Type>() {
        public Type run(Type base) {
          Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
          NodeUtil.getSpan(a1));
          return NodeFactory.makeTaggedDimType(span, false, (Type)base,
          NodeFactory.makeDimRef(NodeUtil.getSpan(a1), a1),
          Option.<Expr>none());
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.ArraySize.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$ArraySize(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fType$ArraySize) 
      yyColumn.chunk10.fType$ArraySize = pType$ArraySize$1(yyStart);
    return yyColumn.chunk10.fType$ArraySize;
  }

  /** Actually parse Type.ArraySize. */
  private Result pType$ArraySize$1(final int yyStart) throws IOException {
    Result     yyResult;
    Indices    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$ExtentRange(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExtentRange a1 = yyResult.semanticValue();

      yyResult = pType$ArraySize$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ExtentRange> a2s = yyResult.semanticValue();

        yyValue = NodeFactory.makeIndices(createSpan(yyStart,yyCount),
        Useful.cons(a1, a2s.list()));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Type.ArraySize$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$ArraySize$$Star1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fType$ArraySize$$Star1) 
      yyColumn.chunk10.fType$ArraySize$$Star1 = pType$ArraySize$$Star1$1(yyStart);
    return yyColumn.chunk10.fType$ArraySize$$Star1;
  }

  /** Actually parse Type.ArraySize$$Star1. */
  private Result pType$ArraySize$$Star1$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<ExtentRange> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType$ExtentRange(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            ExtentRange v$el$1 = yyResult.semanticValue();

            yyResult = pType$ArraySize$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<ExtentRange> v$2 = yyResult.semanticValue();

              yyValue = new Pair<ExtentRange>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.ExtentRange.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$ExtentRange(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fType$ExtentRange) 
      yyColumn.chunk10.fType$ExtentRange = pType$ExtentRange$1(yyStart);
    return yyColumn.chunk10.fType$ExtentRange;
  }

  /** Actually parse Type.ExtentRange. */
  private Result pType$ExtentRange$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    StaticArg   yyOpValue1;
    ExtentRange yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pStaticArg(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticArg v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      StaticArg a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = ppound(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArg(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            StaticArg v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a2.
          StaticArg a2 = yyOpValue1;

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpInfix(span, "#");
          yyValue = NodeFactory.makeExtentRange(span,
          Option.<StaticArg>wrap(a1),
          Option.<StaticArg>wrap(a2),
          Option.<Op>wrap(op));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }

      // Nested alternative 2.

      yyResult = pSymbol$colon(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArg(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            StaticArg v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
        }
        { // Start scope for a2.
          StaticArg a2 = yyOpValue1;

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpInfix(span, ":");
          yyValue = NodeFactory.makeExtentRange(span,
          Option.<StaticArg>wrap(a1),
          Option.<StaticArg>wrap(a2),
          Option.<Op>wrap(op));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pStaticArg(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticArg a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeExtentRange(createSpan(yyStart,yyCount),
      Option.<StaticArg>none(),
      Option.<StaticArg>some(a1),
      Option.<Op>none());

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.MayParenthesizedOpType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$MayParenthesizedOpType(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$OpType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pType$OpType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared10.
   * This nonterminal represents the duplicate productions Type.TypeInfixOp 
   * and NoNewlineType.TypeInfixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared10(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.f$$Shared10) 
      yyColumn.chunk10.f$$Shared10 = p$$Shared10$1(yyStart);
    return yyColumn.chunk10.f$$Shared10;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared10. */
  private Result p$$Shared10$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightarrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpInfix(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared11.
   * This nonterminal represents the duplicate productions Type.DimInfixOp 
   * and NoNewlineType.DimInfixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared11(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.f$$Shared11) 
      yyColumn.chunk10.f$$Shared11 = p$$Shared11$1(yyStart);
    return yyColumn.chunk10.f$$Shared11;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared11. */
  private Result p$$Shared11$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared11$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpInfix(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared11$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared11$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDOT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pslash(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "per";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select(" expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared12.
   * This nonterminal represents the duplicate productions Type.DimPrefixOp 
   * and NoNewlineType.DimPrefixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared12(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.f$$Shared12) 
      yyColumn.chunk11.f$$Shared12 = p$$Shared12$1(yyStart);
    return yyColumn.chunk11.f$$Shared12;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared12. */
  private Result p$$Shared12$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared12$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpPrefix(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared12$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared12$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('q' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('a' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('r' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('e' == yyC) {

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "square";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select(" expected", yyStart);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'c':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('u' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('b' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('i' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('c' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = "cubic";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select(" expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'i':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('v' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('r' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('s' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('e' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "inverse";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select(" expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared13.
   * This nonterminal represents the duplicate productions Type.DimPostfixOp 
   * and NoNewlineType.DimPostfixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared13(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.f$$Shared13) 
      yyColumn.chunk11.f$$Shared13 = p$$Shared13$1(yyStart);
    return yyColumn.chunk11.f$$Shared13;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared13. */
  private Result p$$Shared13$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared13$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpPostfix(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared13$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared13$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('q' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('a' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('r' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('e' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('d' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "squared";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select(" expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'c':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('u' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('b' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('d' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = "cubed";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select(" expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TraitType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TraitType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fType$TraitType) 
      yyColumn.chunk11.fType$TraitType = pType$TraitType$1(yyStart);
    return yyColumn.chunk11.fType$TraitType;
  }

  /** Actually parse Type.TraitType. */
  private Result pType$TraitType$1(final int yyStart) throws IOException {
    Result     yyResult;
    BaseType   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$TraitTypeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type seed = yyResult.semanticValue();

      yyResult = pType$TraitType$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Type>> list = yyResult.semanticValue();

        yyValue = (BaseType)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Type.TraitType$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TraitType$$Plus1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fType$TraitType$$Plus1) 
      yyColumn.chunk11.fType$TraitType$$Plus1 = pType$TraitType$$Plus1$1(yyStart);
    return yyColumn.chunk11.fType$TraitType$$Plus1;
  }

  /** Actually parse Type.TraitType$$Plus1. */
  private Result pType$TraitType$$Plus1$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    Pair<Action<Type>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$TraitTypeTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Type> v$el$2 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType$TraitType$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Type>> v$3 = yyResult.semanticValue();

        yyValue = new Pair<Action<Type>>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Action<Type>>(v$el$2);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TraitTypeFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TraitTypeFront(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$ParenthesizedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pType$TupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TraitTypeTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TraitTypeTail(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<ExtentRange> yyRepValue1;
    int               yyOption1;
    Indices           yyOpValue1;
    Action<Type>      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$opensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$ArraySize(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Indices v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        final Indices a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared7(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Action<Type>() {
              public Type run(Type base) {
                Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
                createSpan(yyStart,yyCount));
                if (NodeUtil.isExponentiation((Type)base)) {
                  log(span,
                  "An exponentiation/vector type/array type should not be " +
                  "immediately followed by a left square bracket.");
                  return base;
                } else
                return NodeFactory.makeArrayType(span, (Type)base,
                Option.<Indices>wrap(a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = phasW(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Boolean a1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pIntExpr(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final IntExpr a2 = yyResult.semanticValue();

          yyValue = new Action<Type>() {
            public Type run(Type base) {
              Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
              createSpan(yyStart,yyCount));
              if ( a1.booleanValue() )
              log(span, "Space is not allowed immediately after '^'.");
              if ( NodeUtil.isExponentiation((Type)base) ||
              NodeUtil.isExponentiation(a2) ) {
                log(span, "An exponentiation should not be immediately " +
                "followed by an exponentiation.");
                return base;
              } else
              return TypeResolver.makeMatrixType(span, (Type)base, a2);
          }};

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = popenparen(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$ExtentRange(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final ExtentRange a2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcross(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pType$ExtentRange(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        final ExtentRange v$el$1 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = 
                          new Pair<ExtentRange>(v$el$1, yyRepValue1);
                        continue;
                      }
                    }
                  }
                }
                break;
              }
              { // Start scope for a3s.
                final Pair<ExtentRange> a3s = yyRepValue1.reverse();

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = new Action<Type>() {
                      public Type run(Type base) {
                        Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
                        createSpan(yyStart,yyCount));
                        if ( a1.booleanValue() )
                        log(span, "Space is not allowed immediately after '^'.");
                        if ( NodeUtil.isExponentiation((Type)base) ) {
                          log(span, "An exponentiation should not be immediately " +
                          "followed by an exponentiation.");
                          return base;
                        } else
                        return NodeFactory.makeMatrixType(span, (Type)base,
                        a2, a3s.list());
                    }};

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a3s.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared14.
   * This nonterminal represents the duplicate productions Type.SelfTypeId 
   * and NoNewlineType.SelfTypeId.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared14(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.f$$Shared14) 
      yyColumn.chunk11.f$$Shared14 = p$$Shared14$1(yyStart);
    return yyColumn.chunk11.f$$Shared14;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared14. */
  private Result p$$Shared14$1(final int yyStart) throws IOException {
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelf(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeId(createSpan(yyStart,yyCount),a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$Type(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fNoNewlineType$Type) 
      yyColumn.chunk11.fNoNewlineType$Type = pNoNewlineType$Type$1(yyStart);
    return yyColumn.chunk11.fNoNewlineType$Type;
  }

  /** Actually parse NoNewlineType.Type. */
  private Result pNoNewlineType$Type$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyOption1;
    Expr       yyOpValue1;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pone(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyOption1  = yyStart;

      yyResult = pio(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      yyResult = pNoNewlineType$TypePrimary(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pin(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression$Expr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = yyOpValue1;

          Type ty = TypeResolver.resolveOps(a1);
          Span span = NodeUtil.getSpan(ty);
          if (a2 == null)
          yyValue = ty;
          else {
            if (ty instanceof TaggedDimType) {
              TaggedDimType _ty = (TaggedDimType)ty;
              yyValue = NodeFactory.makeTaggedDimType(span, false,
              _ty.getElemType(),
              _ty.getDimExpr(),
              Option.<Expr>some(a2));
            } else {
              log(span, "A dimension type is expected.");
              yyValue = ty;
            }
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    } else {
      yyError = yyError.select("type expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.OpType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$OpType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fNoNewlineType$OpType) 
      yyColumn.chunk11.fNoNewlineType$OpType = pNoNewlineType$OpType$1(yyStart);
    return yyColumn.chunk11.fNoNewlineType$OpType;
  }

  /** Actually parse NoNewlineType.OpType. */
  private Result pNoNewlineType$OpType$1(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TypePrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineType$TypePrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypePrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypePrimary(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fNoNewlineType$TypePrimary) 
      yyColumn.chunk11.fNoNewlineType$TypePrimary = pNoNewlineType$TypePrimary$1(yyStart);
    return yyColumn.chunk11.fNoNewlineType$TypePrimary;
  }

  /** Actually parse NoNewlineType.TypePrimary. */
  private Result pNoNewlineType$TypePrimary$1(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TypePrimaryFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineType$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealType(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealType(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineType$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealType(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 3.

      yyValue = PureList.make((PostfixOpExpr)new RealType(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypePrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypePrefix(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fNoNewlineType$TypePrefix) 
      yyColumn.chunk11.fNoNewlineType$TypePrefix = pNoNewlineType$TypePrefix$1(yyStart);
    return yyColumn.chunk11.fNoNewlineType$TypePrefix;
  }

  /** Actually parse NoNewlineType.TypePrefix. */
  private Result pNoNewlineType$TypePrefix$1(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared12(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineType$TypePrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    int                     yyOption1;
    List<Type>              yyOpValue1;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared10(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = ps(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pThrows(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Type> v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
        { // Start scope for a3.
          List<Type> a3 = yyOpValue1;

          yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1, NodeFactory.makeEffect(Option.<List<Type>>wrap(a3))));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }

      // Nested alternative 2.

      yyResult = pNoNewlineType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = ps(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pThrows(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Type> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<Type> a3 = yyOpValue1;

          yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1, NodeFactory.makeEffect(Option.<List<Type>>wrap(a3))));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }
    }

    // Alternative 2.

    yyResult = p$$Shared11(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = p$$Shared13(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineType$TypePrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyValue = PureList.make((PostfixOpExpr)new Postfix(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.LooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$LooseInfix(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    int                     yyOption1;
    List<Type>              yyOpValue1;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared10(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pSpacing$sr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineType$TypePrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = ps(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Type> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a3.
            List<Type> a3 = yyOpValue1;

            yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1, NodeFactory.makeEffect(Option.<List<Type>>wrap(a3))));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }

        // Nested alternative 2.

        yyResult = pNoNewlineType$TypePrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = ps(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Type> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a3.
            List<Type> a3 = yyOpValue1;

            yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1, NodeFactory.makeEffect(Option.<List<Type>>wrap(a3))));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared11(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pSpacing$sr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineType$TypePrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineType$TypePrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypePrimaryFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypePrimaryFront(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    boolean            yyRepeated1;
    Pair<Action<Type>> yyRepValue1;
    Type               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TypeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pNoNewlineType$TypeTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<Type> v$el$2 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Action<Type>>(v$el$2, yyRepValue1);
          continue;
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Action<Type>> list = yyRepValue1.reverse();

        yyValue = (Type)apply(list, (Type)seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Alternative 2.

    yyResult = pNoNewlineType$TypeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypeFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypeFront(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fNoNewlineType$TypeFront) 
      yyColumn.chunk11.fNoNewlineType$TypeFront = pNoNewlineType$TypeFront$1(yyStart);
    return yyColumn.chunk11.fNoNewlineType$TypeFront;
  }

  /** Actually parse NoNewlineType.TypeFront. */
  private Result pNoNewlineType$TypeFront$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$ParenthesizedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineType$Domain(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pNoNewlineType$TupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pone(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = NodeFactory.makeDimBase(createSpan(yyStart,1), false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.ParenthesizedType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$ParenthesizedType(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fNoNewlineType$ParenthesizedType) 
      yyColumn.chunk12.fNoNewlineType$ParenthesizedType = pNoNewlineType$ParenthesizedType$1(yyStart);
    return yyColumn.chunk12.fNoNewlineType$ParenthesizedType;
  }

  /** Actually parse NoNewlineType.ParenthesizedType. */
  private Result pNoNewlineType$ParenthesizedType$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType$Type(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.Domain.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$Domain(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<Object> yyRepValue1;
    int          yyOption1;
    Type         yyOpValue1;
    Type         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pNoNewlineType$Type(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type v$el$1 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<Object>(v$el$1, yyRepValue1);
                  continue;
                }
              }
            }
          }
          break;
        }
        { // Start scope for a1s.
          Pair<Type> a1s = cast(yyRepValue1.reverse());

          final int yyChoice1 = yyRepetition1;

          // Nested alternative 1.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pNoNewlineType$Type(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type v$el$2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$2;
                    }
                  }
                }
              }
            }
          }
          { // Start scope for a2.
            Type a2 = yyOpValue1;

            yyResult = pNoNewlineType$KeywordType(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              KeywordType a3 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pNoNewlineType$KeywordType(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        KeywordType v$el$3 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = new Pair<Object>(v$el$3, yyRepValue1);
                        continue;
                      }
                    }
                  }
                }
                break;
              }
              { // Start scope for a4s.
                Pair<KeywordType> a4s = cast(yyRepValue1.reverse());

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<KeywordType> ts3 = a4s.list();
                    ts3.add(0, a3);
                    yyValue = NodeFactory.makeDomain(createSpan(yyStart,yyCount),
                    a1s.list(), Option.<Type>wrap(a2), ts3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a4s.
            }
          } // End scope for a2.

          // Nested alternative 2.

          yyResult = pNoNewlineType$Type(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = NodeFactory.makeDomain(createSpan(yyStart,yyCount),
                    Useful.list(a1s.list()),
                    Option.<Type>some(a2),
                    Collections.<KeywordType>emptyList());

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        } // End scope for a1s.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.KeywordType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$KeywordType(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fNoNewlineType$KeywordType) 
      yyColumn.chunk12.fNoNewlineType$KeywordType = pNoNewlineType$KeywordType$1(yyStart);
    return yyColumn.chunk12.fNoNewlineType$KeywordType;
  }

  /** Actually parse NoNewlineType.KeywordType. */
  private Result pNoNewlineType$KeywordType$1(final int yyStart) 
    throws IOException {

    Result      yyResult;
    KeywordType yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineType$Type(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeKeywordType(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TupleType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TupleType(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fNoNewlineType$TupleType) 
      yyColumn.chunk12.fNoNewlineType$TupleType = pNoNewlineType$TupleType$1(yyStart);
    return yyColumn.chunk12.fNoNewlineType$TupleType;
  }

  /** Actually parse NoNewlineType.TupleType. */
  private Result pNoNewlineType$TupleType$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    TupleType  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType$Type(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineType$TypeList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Type> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyValue = NodeFactory.makeTupleType(createSpan(yyStart,yyCount),
                      Useful.cons(a1, a2));

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypeList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Type> yyRepValue1;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineType$Type(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Type>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Type> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypeTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypeTail(final int yyStart) 
    throws IOException {

    Result            yyResult;
    int               yyRepetition1;
    Pair<ExtentRange> yyRepValue1;
    int               yyOption1;
    Indices           yyOpValue1;
    Action<Type>      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$opensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType$ArraySize(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Indices v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        final Indices a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared7(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Action<Type>() {
              public Type run(Type base) {
                Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
                createSpan(yyStart,yyCount));
                if (NodeUtil.isExponentiation((Type)base)) {
                  log(span, "An exponentiation/vector type/array type should " +
                  "not be immediately followed by a left square bracket.");
                  return base;
                } else
                return NodeFactory.makeArrayType(span, (Type)base,
                Option.<Indices>wrap(a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = phasW(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Boolean a1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pIntExpr(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final IntExpr a2 = yyResult.semanticValue();

          yyValue = new Action<Type>() {
            public Type run(Type base) {
              Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
              createSpan(yyStart,yyCount));
              if ( a1.booleanValue() )
              log(span, "Space is not allowed immediately after '^'.");
              if ( NodeUtil.isExponentiation((Type)base) ||
              NodeUtil.isExponentiation(a2) ) {
                log(span, "An exponentiation should not be immediately " +
                "followed by an exponentiation.");
                return base;
              } else if (base instanceof DimExpr) {
                return NodeFactory.makeDimExponent(span, false, (DimExpr)base,
                a2);
              } else { // !(base instanceof DimExpr)
                return NodeFactory.makeDimExponent(span, false, (Type)base, a2);
              }
          }};

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = popenparen(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineType$ExtentRange(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final ExtentRange a2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcross(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pNoNewlineType$ExtentRange(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        final ExtentRange v$el$1 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = 
                          new Pair<ExtentRange>(v$el$1, yyRepValue1);
                        continue;
                      }
                    }
                  }
                }
                break;
              }
              { // Start scope for a3s.
                final Pair<ExtentRange> a3s = yyRepValue1.reverse();

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = new Action<Type>() {
                      public Type run(Type base) {
                        Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
                        createSpan(yyStart,yyCount));
                        if ( a1.booleanValue() )
                        log(span, "Space is not allowed immediately after '^'.");
                        if ( NodeUtil.isExponentiation((Type)base) ) {
                          log(span, "An exponentiation should not be immediately " +
                          "followed by an exponentiation.");
                          return base;
                        } else
                        return NodeFactory.makeMatrixType(span, (Type)base, a2,
                        a3s.list());
                    }};

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a3s.
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType$MayParenthesizedOpType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final PureList<PostfixOpExpr> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = new Action<Type>() {
                public Type run(Type base) {
                  DimExpr dim = TypeResolver.resolveOpsDim(a1);
                  Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
                  createSpan(yyStart,yyCount));
                  return NodeFactory.makeTaggedDimType(span, false, (Type)base,
                  NodeFactory.makeInParentheses(dim),
                  Option.<Expr>none());
              }};

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Id a1 = yyResult.semanticValue();

      yyValue = new Action<Type>() {
        public Type run(Type base) {
          Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
          NodeUtil.getSpan(a1));
          return NodeFactory.makeTaggedDimType(span, false, (Type)base,
          NodeFactory.makeDimRef(NodeUtil.getSpan(a1), a1),
          Option.<Expr>none());
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.ArraySize.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$ArraySize(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fNoNewlineType$ArraySize) 
      yyColumn.chunk12.fNoNewlineType$ArraySize = pNoNewlineType$ArraySize$1(yyStart);
    return yyColumn.chunk12.fNoNewlineType$ArraySize;
  }

  /** Actually parse NoNewlineType.ArraySize. */
  private Result pNoNewlineType$ArraySize$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Indices    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$ExtentRange(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExtentRange a1 = yyResult.semanticValue();

      yyResult = pNoNewlineType$ArraySize$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ExtentRange> a2s = yyResult.semanticValue();

        yyValue = NodeFactory.makeIndices(createSpan(yyStart,yyCount),
        Useful.cons(a1, a2s.list()));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineType.ArraySize$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$ArraySize$$Star1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fNoNewlineType$ArraySize$$Star1) 
      yyColumn.chunk12.fNoNewlineType$ArraySize$$Star1 = pNoNewlineType$ArraySize$$Star1$1(yyStart);
    return yyColumn.chunk12.fNoNewlineType$ArraySize$$Star1;
  }

  /** Actually parse NoNewlineType.ArraySize$$Star1. */
  private Result pNoNewlineType$ArraySize$$Star1$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<ExtentRange> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineType$ExtentRange(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            ExtentRange v$el$1 = yyResult.semanticValue();

            yyResult = pNoNewlineType$ArraySize$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<ExtentRange> v$2 = yyResult.semanticValue();

              yyValue = new Pair<ExtentRange>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.ExtentRange.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$ExtentRange(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fNoNewlineType$ExtentRange) 
      yyColumn.chunk12.fNoNewlineType$ExtentRange = pNoNewlineType$ExtentRange$1(yyStart);
    return yyColumn.chunk12.fNoNewlineType$ExtentRange;
  }

  /** Actually parse NoNewlineType.ExtentRange. */
  private Result pNoNewlineType$ExtentRange$1(final int yyStart) 
    throws IOException {

    Result      yyResult;
    int         yyOption1;
    StaticArg   yyOpValue1;
    ExtentRange yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pStaticArg(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticArg v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      StaticArg a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = ppound(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArg(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            StaticArg v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a2.
          StaticArg a2 = yyOpValue1;

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpInfix(span, "#");
          yyValue = NodeFactory.makeExtentRange(span,
          Option.<StaticArg>wrap(a1),
          Option.<StaticArg>wrap(a2),
          Option.<Op>wrap(op));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }

      // Nested alternative 2.

      yyResult = pSymbol$colon(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArg(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            StaticArg v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
        }
        { // Start scope for a2.
          StaticArg a2 = yyOpValue1;

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpInfix(span, ":");
          yyValue = NodeFactory.makeExtentRange(span,
          Option.<StaticArg>wrap(a1),
          Option.<StaticArg>wrap(a2),
          Option.<Op>wrap(op));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pStaticArg(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticArg a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeExtentRange(createSpan(yyStart,yyCount),
      Option.<StaticArg>none(),
      Option.<StaticArg>some(a1),
      Option.<Op>none());

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.MayParenthesizedOpType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$MayParenthesizedOpType(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType$OpType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pNoNewlineType$OpType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TraitTypeTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TraitTypeTail(final int yyStart) 
    throws IOException {

    Result            yyResult;
    int               yyRepetition1;
    Pair<ExtentRange> yyRepValue1;
    int               yyOption1;
    Indices           yyOpValue1;
    Action<Type>      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$opensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType$ArraySize(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Indices v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        final Indices a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared7(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Action<Type>() {
              public Type run(Type base) {
                Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
                createSpan(yyStart,yyCount));
                if (NodeUtil.isExponentiation((Type)base)) {
                  log(span,
                  "An exponentiation/vector type/array type should not be " +
                  "immediately followed by a left square bracket.");
                  return base;
                } else
                return NodeFactory.makeArrayType(span, (Type)base,
                Option.<Indices>wrap(a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = phasW(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Boolean a1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pIntExpr(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final IntExpr a2 = yyResult.semanticValue();

          yyValue = new Action<Type>() {
            public Type run(Type base) {
              Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
              createSpan(yyStart,yyCount));
              if ( a1.booleanValue() )
              log(span, "Space is not allowed immediately after '^'.");
              if ( NodeUtil.isExponentiation((Type)base) ||
              NodeUtil.isExponentiation(a2) ) {
                log(span, "An exponentiation should not be immediately " +
                "followed by an exponentiation.");
                return base;
              } else
              return TypeResolver.makeMatrixType(span, (Type)base, a2);
          }};

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = popenparen(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineType$ExtentRange(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final ExtentRange a2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcross(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pNoNewlineType$ExtentRange(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        final ExtentRange v$el$1 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = 
                          new Pair<ExtentRange>(v$el$1, yyRepValue1);
                        continue;
                      }
                    }
                  }
                }
                break;
              }
              { // Start scope for a3s.
                final Pair<ExtentRange> a3s = yyRepValue1.reverse();

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = new Action<Type>() {
                      public Type run(Type base) {
                        Span span = NodeUtil.spanTwo(NodeUtil.getSpan((Type)base),
                        createSpan(yyStart,yyCount));
                        if ( a1.booleanValue() )
                        log(span, "Space is not allowed immediately after '^'.");
                        if ( NodeUtil.isExponentiation((Type)base) ) {
                          log(span, "An exponentiation should not be immediately " +
                          "followed by an exponentiation.");
                          return base;
                        } else
                        return NodeFactory.makeMatrixType(span, (Type)base,
                        a2, a3s.list());
                    }};

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a3s.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TraitTypeWithError.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TraitTypeWithError(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fNoNewlineType$TraitTypeWithError) 
      yyColumn.chunk12.fNoNewlineType$TraitTypeWithError = pNoNewlineType$TraitTypeWithError$1(yyStart);
    return yyColumn.chunk12.fNoNewlineType$TraitTypeWithError;
  }

  /** Actually parse NoNewlineType.TraitTypeWithError. */
  private Result pNoNewlineType$TraitTypeWithError$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    BaseType   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TraitTypeFrontWithError(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type seed = yyResult.semanticValue();

      yyResult = pNoNewlineType$TraitTypeWithError$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Type>> list = yyResult.semanticValue();

        yyValue = (BaseType)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pNoNewlineType$TypeRefWithError(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineType.TraitTypeWithError$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TraitTypeWithError$$Plus1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fNoNewlineType$TraitTypeWithError$$Plus1) 
      yyColumn.chunk12.fNoNewlineType$TraitTypeWithError$$Plus1 = pNoNewlineType$TraitTypeWithError$$Plus1$1(yyStart);
    return yyColumn.chunk12.fNoNewlineType$TraitTypeWithError$$Plus1;
  }

  /** Actually parse NoNewlineType.TraitTypeWithError$$Plus1. */
  private Result pNoNewlineType$TraitTypeWithError$$Plus1$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    Pair<Action<Type>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TraitTypeTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Type> v$el$2 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineType$TraitTypeWithError$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Type>> v$3 = yyResult.semanticValue();

        yyValue = new Pair<Action<Type>>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Action<Type>>(v$el$2);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TraitTypeFrontWithError.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TraitTypeFrontWithError(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$ParenthesizedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineType$TupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pNoNewlineType$TypeRefWithError(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypeRefWithError.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypeRefWithError(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fNoNewlineType$TypeRefWithError) 
      yyColumn.chunk12.fNoNewlineType$TypeRefWithError = pNoNewlineType$TypeRefWithError$1(yyStart);
    return yyColumn.chunk12.fNoNewlineType$TypeRefWithError;
  }

  /** Actually parse NoNewlineType.TypeRefWithError. */
  private Result pNoNewlineType$TypeRefWithError$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('U' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('y' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue = NodeFactory.makeDimBase(createSpan(yyStart,yyCount), false);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makeTraitType(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyValue = NodeFactory.makeVarType(createSpan(yyStart,yyCount), a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 3.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      yyValue = NodeFactory.makeVarType(createSpan(yyStart,yyCount),
      a1.getText());

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("type ref with error expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.NoNewlineTupleType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineTupleType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fNoNewlineTupleType) 
      yyColumn.chunk12.fNoNewlineTupleType = pNoNewlineTupleType$1(yyStart);
    return yyColumn.chunk12.fNoNewlineTupleType;
  }

  /** Actually parse NoNewlineType.NoNewlineTupleType. */
  private Result pNoNewlineTupleType$1(final int yyStart) throws IOException {
    Result     yyResult;
    TupleType  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.NoNewlineExtentRange.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExtentRange(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fNoNewlineExtentRange) 
      yyColumn.chunk13.fNoNewlineExtentRange = pNoNewlineExtentRange$1(yyStart);
    return yyColumn.chunk13.fNoNewlineExtentRange;
  }

  /** Actually parse NoNewlineType.NoNewlineExtentRange. */
  private Result pNoNewlineExtentRange$1(final int yyStart) 
    throws IOException {

    Result      yyResult;
    ExtentRange yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$ExtentRange(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.NoNewlineType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fNoNewlineType) 
      yyColumn.chunk13.fNoNewlineType = pNoNewlineType$1(yyStart);
    return yyColumn.chunk13.fNoNewlineType;
  }

  /** Actually parse NoNewlineType.NoNewlineType. */
  private Result pNoNewlineType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyOption1;
    Expr       yyOpValue1;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pone(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyOption1  = yyStart;

      yyResult = pio(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      yyResult = pNoNewlineType$TypePrimary(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pin(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = yyOpValue1;

          Type ty = TypeResolver.resolveOps(a1);
          if (a2 == null)
          yyValue = ty;
          else {
            if (ty instanceof TaggedDimType) {
              TaggedDimType _ty = (TaggedDimType)ty;
              yyValue = NodeFactory.makeTaggedDimType(NodeUtil.getSpan(_ty),
              false, _ty.getElemType(),
              _ty.getDimExpr(),
              Option.<Expr>some(a2));
            } else {
              log(NodeUtil.getSpan(ty), "A dimension type is expected.");
              yyValue = ty;
            }
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    } else {
      yyError = yyError.select("no newline type expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$Expr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fExpression$Expr) 
      yyColumn.chunk13.fExpression$Expr = pExpression$Expr$1(yyStart);
    return yyColumn.chunk13.fExpression$Expr;
  }

  /** Actually parse Expression.Expr. */
  private Result pExpression$Expr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = p$$Shared53(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> list = yyResult.semanticValue();

        yyValue = (Expr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared53.
   * This nonterminal represents the duplicate productions 
   * Expression.Expr$$Star1 and NoSpaceExpr.Expr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared53(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.f$$Shared53) 
      yyColumn.chunk13.f$$Shared53 = p$$Shared53$1(yyStart);
    return yyColumn.chunk13.f$$Shared53;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared53. */
  private Result p$$Shared53$1(final int yyStart) throws IOException {
    Result             yyResult;
    Pair<Action<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared27(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expr> v$el$1 = yyResult.semanticValue();

      yyResult = p$$Shared53(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$ExprFront(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <AssignExpr>.

    yyResult = pExpression$AssignExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Flow>.

    yyResult = pExpression$FlowExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pLooseJuxtGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pFnExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pfn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pBindId(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Type> v$el$8 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$8;
            }
          }
          { // Start scope for a2.
            List<Type> a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pmatch(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pExpression$Expr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr a3 = yyResult.semanticValue();

                    yyValue = ExprFactory.makeFnExpr(createSpan(yyStart,yyCount),
                    Useful.list(NodeFactory.makeParam(a1)),
                    Option.<Type>none(),
                    Option.<List<Type>>wrap(a2), a3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = popenparen(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pParameter$Params(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Param> v$el$9 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$9;
            }
          }
          { // Start scope for a1.
            List<Param> a1 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pIsType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Type v$el$10 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$10;
                  }
                }
                { // Start scope for a2.
                  Type a2 = cast(yyOpValue1);

                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pThrows(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<Type> v$el$11 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$11;
                    }
                  }
                  { // Start scope for a3.
                    List<Type> a3 = cast(yyOpValue1);

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pmatch(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pExpression$Expr(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            Expr a4 = yyResult.semanticValue();

                            if (a1 == null) a1 = Collections.<Param>emptyList();
                            yyValue = ExprFactory.makeFnExpr(createSpan(yyStart,yyCount), a1,
                            Option.<Type>wrap(a2),
                            Option.<List<Type>>wrap(a3), a4);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      }
                    }
                  } // End scope for a3.
                } // End scope for a2.
              }
            }
          } // End scope for a1.
        }

        // Nested alternative 3.

        yyResult = pParameter$ValParam(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIsType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }
          }


          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }
          }

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyResult = pmatch(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpression$Expr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  Span span = createSpan(yyStart,yyCount);
                  log(span, "Parentheses are required around the parameter of an anonymous function expression.");
                  yyValue = ExprFactory.makeVoidLiteralExpr(span);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }

            // Nested alternative 2.

            yyResult = pExpression$Expr(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount);
              log(span, "Anonymous function expression is missing \"=>\".");
              yyValue = ExprFactory.makeVoidLiteralExpr(span);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared27.
   * This nonterminal represents the duplicate productions 
   * Expression.ExprTail and NoSpaceExpr.ExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared27(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pDoubleStar(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new Action<Expr>() {
          public Expr run(Expr base) {
            return new _EllipsesExpr(NodeFactory.makeExprInfo(createSpan(yyStart,yyCount)), base);
        }};

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = ptyped(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType$Type(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return ExprFactory.makeAsExpr(createSpan(yyStart,yyCount),
                (Expr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyResult = pasif(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType$Type(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return ExprFactory.makeAsIfExpr(createSpan(yyStart,yyCount),
                (Expr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.AssignExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$AssignExpr(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fExpression$AssignExpr) 
      yyColumn.chunk13.fExpression$AssignExpr = pExpression$AssignExpr$1(yyStart);
    return yyColumn.chunk13.fExpression$AssignExpr;
  }

  /** Actually parse Expression.AssignExpr. */
  private Result pExpression$AssignExpr$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared36(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Lhs> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<FunctionalRef> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = ExprFactory.makeAssignment(createSpan(yyStart,yyCount),
              a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared36.
   * This nonterminal represents the duplicate productions 
   * Expression.AssignLefts, NoNewlineExpr.AssignLefts, 
   * and NoSpaceExpr.AssignLefts.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared36(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.f$$Shared36) 
      yyColumn.chunk13.f$$Shared36 = p$$Shared36$1(yyStart);
    return yyColumn.chunk13.f$$Shared36;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared36. */
  private Result p$$Shared36$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Lhs>  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared32(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Lhs a1 = yyResult.semanticValue();

          yyResult = p$$Shared36$$Star1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<Lhs> a2s = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared32(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Lhs a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared36$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared36$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.f$$Shared36$$Star1) 
      yyColumn.chunk13.f$$Shared36$$Star1 = p$$Shared36$$Star1$1(yyStart);
    return yyColumn.chunk13.f$$Shared36$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared36$$Star1. */
  private Result p$$Shared36$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Lhs>  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared32(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Lhs v$el$1 = yyResult.semanticValue();

            yyResult = p$$Shared36$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Lhs> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Lhs>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared32.
   * This nonterminal represents the duplicate productions 
   * Expression.AssignLeft, NoNewlineExpr.AssignLeft, 
   * and NoSpaceExpr.AssignLeft.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared32(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.f$$Shared32) 
      yyColumn.chunk13.f$$Shared32 = p$$Shared32$1(yyStart);
    return yyColumn.chunk13.f$$Shared32;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared32. */
  private Result p$$Shared32$1(final int yyStart) throws IOException {
    Result     yyResult;
    Lhs        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared29(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = p$$Shared32$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> list = yyResult.semanticValue();

        Expr left = (Expr)apply(list, seed);
        if (left instanceof Lhs) yyValue = (Lhs)left;
        else {
          Span span = NodeUtil.getSpan(left);
          log(span,
          "The left-hand side of the assignment expression is not valid.");
          yyValue = ExprFactory.makeVarRef(span, NodeFactory.bogusId(span));
        }

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(NodeUtil.getSpan(a1), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared32$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared32$$Plus1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.f$$Shared32$$Plus1) 
      yyColumn.chunk13.f$$Shared32$$Plus1 = p$$Shared32$$Plus1$1(yyStart);
    return yyColumn.chunk13.f$$Shared32$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared32$$Plus1. */
  private Result p$$Shared32$$Plus1$1(final int yyStart) throws IOException {
    Result             yyResult;
    Pair<Action<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared28(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expr> v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = p$$Shared32$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Action<Expr>>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared28.
   * This nonterminal represents the duplicate productions 
   * Expression.AssignLeftTail, NoNewlineExpr.AssignLeftTail, 
   * and NoSpaceExpr.AssignLeftTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared28(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<StaticArg> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        final List<StaticArg> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExprList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<Expr> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          final List<Expr> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pRightEncloser(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Op a4 = yyResult.semanticValue();

              yyValue = new Action<Expr>() {
                public Expr run(Expr base) {
                  Span span = NodeUtil.spanTwo(base, a4);
                  List<StaticArg> sargs =
                  (a2 == null) ? Collections.<StaticArg>emptyList() : a2;
                  List<Expr> es = (a3 == null) ? Collections.<Expr>emptyList() : a3;
                  Op op = NodeFactory.makeEnclosing(NodeUtil.spanTwo(a1,a4),
                  a1.getText(), a4.getText(), true, false);
                  return ExprFactory.makeSubscriptExpr(span, base, es,
                  Option.<Op>some(op), sargs);
              }};

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = p$$Shared54(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Id a1 = yyResult.semanticValue();

        yyValue = new Action<Expr>() {
          public Expr run(Expr base) {
            Span span = NodeUtil.spanTwo(base, a1);
            if ( NodeUtil.isKeyword(a1) )
            log(span, "Keyword " + a1 + " cannot be used as an identifier.");
            return ExprFactory.makeFieldRef(span, base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared54.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared18$$Choice1, 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared33$$Choice1, 
   * and com.sun.fortress.parser.templateparser.TemplateParser.$$Shared34$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared54(final int yyStart) throws IOException {
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pReserved(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExpr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fExpression$OpExpr) 
      yyColumn.chunk13.fExpression$OpExpr = pExpression$OpExpr$1(yyStart);
    return yyColumn.chunk13.fExpression$OpExpr;
  }

  /** Actually parse Expression.OpExpr. */
  private Result pExpression$OpExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <FIRST>.

    yyResult = pExpression$OpExprNoEnc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = Resolver.resolveOps(writer, span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = Resolver.resolveOps(writer, span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(NodeUtil.getSpan(a1), a1));
      yyValue = Resolver.resolveOps(writer, span, PureList.make(e));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprNoEnc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprNoEnc(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fExpression$OpExprNoEnc) 
      yyColumn.chunk14.fExpression$OpExprNoEnc = pExpression$OpExprNoEnc$1(yyStart);
    return yyColumn.chunk14.fExpression$OpExprNoEnc;
  }

  /** Actually parse Expression.OpExprNoEnc. */
  private Result pExpression$OpExprNoEnc$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative <FIRST>.

    yyResult = pExpression$OpExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$OpExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      Op op = NodeFactory.makeOpUnknown(span, "^");
      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(span, op));
      yyValue = PureList.make(e);
      log(span, "^ is always an infix operator but used as a nofix operator.");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(NodeUtil.getSpan(a1), a1));
      yyValue = PureList.make(e);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.TightInfixRight.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$TightInfixRight(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue = PureList.make((PrecedenceOpExpr)new Right(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LeftLooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$LeftLooseInfix(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fExpression$LeftLooseInfix) 
      yyColumn.chunk14.fExpression$LeftLooseInfix = pExpression$LeftLooseInfix$1(yyStart);
    return yyColumn.chunk14.fExpression$LeftLooseInfix;
  }

  /** Actually parse Expression.LeftLooseInfix. */
  private Result pExpression$LeftLooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprLeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprLeftEncloser(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fExpression$OpExprLeftEncloser) 
      yyColumn.chunk14.fExpression$OpExprLeftEncloser = pExpression$OpExprLeftEncloser$1(yyStart);
    return yyColumn.chunk14.fExpression$OpExprLeftEncloser;
  }

  /** Actually parse Expression.OpExprLeftEncloser. */
  private Result pExpression$OpExprLeftEncloser$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pExpression$OpExprNoEnc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new Left(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprPrimary(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fExpression$OpExprPrimary) 
      yyColumn.chunk14.fExpression$OpExprPrimary = pExpression$OpExprPrimary$1(yyStart);
    return yyColumn.chunk14.fExpression$OpExprPrimary;
  }

  /** Actually parse Expression.OpExprPrimary. */
  private Result pExpression$OpExprPrimary$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared42(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<Expr> a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$TightInfixRight(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue = PureList.make((PrecedenceOpExpr)new RealExpr(ExprFactory.buildPrimary(a1)));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprPrefix(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fExpression$OpExprPrefix) 
      yyColumn.chunk14.fExpression$OpExprPrefix = pExpression$OpExprPrefix$1(yyStart);
    return yyColumn.chunk14.fExpression$OpExprPrefix;
  }

  /** Actually parse Expression.OpExprPrefix. */
  private Result pExpression$OpExprPrefix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(op));
          log(span, "^ is always an infix operator but used as a prefix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(op));
          log(span, "^ is always an infix operator but used as a prefix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(op));
          log(span, "^ is always an infix operator but used as a prefix operator.");

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(op));
          log(span, "^ is always an infix operator but used as a postfix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(op));
          log(span, "^ is always an infix operator but used as a postfix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(op));
          log(span, "^ is always an infix operator but used as a postfix operator.");

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      Span span = createSpan(yyStart,yyCount);
      Op op = NodeFactory.makeOpUnknown(span, "^");
      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(op));
      log(span, "^ is always an infix operator but used as a postfix operator.");

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 3.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$LooseInfix(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fExpression$LooseInfix) 
      yyColumn.chunk14.fExpression$LooseInfix = pExpression$LooseInfix$1(yyStart);
    return yyColumn.chunk14.fExpression$LooseInfix;
  }

  /** Actually parse Expression.LooseInfix. */
  private Result pExpression$LooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared42.
   * This nonterminal represents the duplicate productions 
   * Expression.Primary, NoNewlineExpr.Primary, and NoSpaceExpr.Primary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared42(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.f$$Shared42) 
      yyColumn.chunk14.f$$Shared42 = p$$Shared42$1(yyStart);
    return yyColumn.chunk14.f$$Shared42;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared42. */
  private Result p$$Shared42$1(final int yyStart) throws IOException {
    Result         yyResult;
    Result         yyPredResult;
    PureList<Expr> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared41(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final PureList<Expr> a1 = yyResult.semanticValue();

      yyResult = p$$Shared42$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<PureList<Expr>> a2s = yyResult.semanticValue();

        yyPredResult = p$$Shared42$$Choice1(yyResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          List<Expr> es = new ArrayList<Expr>();
          for (PureList<Expr> elist : Useful.cons(a1, a2s.list())) {
            es.add(ExprFactory.buildPrimary(elist));
          }
          yyValue = PureList.make((Expr)ExprFactory.makeTupleExpr(createSpan(yyStart,yyCount), es));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared41(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared42$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared42$$Plus1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.f$$Shared42$$Plus1) 
      yyColumn.chunk14.f$$Shared42$$Plus1 = p$$Shared42$$Plus1$1(yyStart);
    return yyColumn.chunk14.f$$Shared42$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared42$$Plus1. */
  private Result p$$Shared42$$Plus1$1(final int yyStart) throws IOException {
    Result               yyResult;
    Pair<PureList<Expr>> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared41(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final PureList<Expr> v$el$2 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = p$$Shared42$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Pair<PureList<Expr>> v$3 = yyResult.semanticValue();

              yyValue = new Pair<PureList<Expr>>(v$el$2, v$3);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<PureList<Expr>>(v$el$2);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared42$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared42$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      while (true) {

        yyResult = pWhitespace(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          continue;
        }
        break;
      }

      if (yyRepeated1) {

        yyValue = null;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }

      // Nested alternative 2.

      yyResult = ps(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pSpacing$Newline(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 2.

        yyBase = yyChoice2;
        yyC    = character(yyBase);
        if (';' == yyC) {
          yyIndex = yyChoice2 + 1;

          yyResult = pw(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("\";\" expected", yyBase);
        }
      }

      // Nested alternative 3.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pcomma(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pRightEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared41.
   * This nonterminal represents the duplicate productions 
   * Expression.PrimaryItem, NoNewlineExpr.PrimaryItem, 
   * and NoSpaceExpr.PrimaryItem.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared41(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.f$$Shared41) 
      yyColumn.chunk14.f$$Shared41 = p$$Shared41$1(yyStart);
    return yyColumn.chunk14.f$$Shared41;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared41. */
  private Result p$$Shared41$1(final int yyStart) throws IOException {
    Result         yyResult;
    PureList<Expr> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared41$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr a1 = yyResult.semanticValue();

      yyValue = PureList.make(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared41$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared41$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared39(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared40(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared39.
   * This nonterminal represents the duplicate productions 
   * Expression.LeftAssociatedPrimary, NoNewlineExpr.LeftAssociatedPrimary, 
   * and NoSpaceExpr.LeftAssociatedPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared39(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    boolean            yyRepeated1;
    Pair<Action<Expr>> yyRepValue1;
    Expr               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared19(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final List<Id> a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<StaticArg> a2 = yyResult.semanticValue();

          yyResult = p$$Shared22(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expr a3 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = p$$Shared30(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Action<Expr> v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Action<Expr>>(v$el$1, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for a4s.
              final Pair<Action<Expr>> a4s = yyRepValue1.reverse();

              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = p$$Shared37(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Action<Expr> v$el$2 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<Action<Expr>>(v$el$2, yyRepValue1);
                  continue;
                }
                break;
              }
              { // Start scope for a5s.
                final Pair<Action<Expr>> a5s = yyRepValue1.reverse();

                Id last = IterUtil.last(a1);
                Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
                Span span = NodeUtil.spanTwo(receiver, a3);
                Expr e1 = ExprFactory.makeMethodInvocation(span, receiver, last, a2, a3);
                Expr e2 = (Expr)apply(a4s, e1);
                yyValue = (Expr)apply(a5s, e2);

                return new SemanticValue(yyValue, yyRepetition1, yyError);
              } // End scope for a5s.
            } // End scope for a4s.
          }
        }
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = p$$Shared21(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Action<Expr> v$el$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Action<Expr>>(v$el$3, yyRepValue1);
          continue;
        }
        break;
      }

      if (yyRepeated1) {
        final Pair<Action<Expr>> a2s = yyRepValue1.reverse();

        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = p$$Shared30(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Action<Expr> v$el$4 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Action<Expr>>(v$el$4, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a3s.
          final Pair<Action<Expr>> a3s = yyRepValue1.reverse();

          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = p$$Shared37(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Action<Expr> v$el$5 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Expr>>(v$el$5, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for a4s.
            final Pair<Action<Expr>> a4s = yyRepValue1.reverse();

            Id last = IterUtil.last(a1);
            Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
            Expr e1 = ExprFactory.makeFieldRef(NodeUtil.spanTwo(receiver, last),
            receiver, last);
            Expr e2 = (Expr)apply(a2s, e1);
            Expr e3 = (Expr)apply(a3s, e2);
            yyValue = (Expr)apply(a4s, e3);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for a4s.
        } // End scope for a3s.
      }

      // Nested alternative 3.

      yyResult = p$$Shared22(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expr a2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = p$$Shared30(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Action<Expr> v$el$6 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Action<Expr>>(v$el$6, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a3s.
          final Pair<Action<Expr>> a3s = yyRepValue1.reverse();

          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = p$$Shared37(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Action<Expr> v$el$7 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Expr>>(v$el$7, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for a4s.
            final Pair<Action<Expr>> a4s = yyRepValue1.reverse();

            Id last = IterUtil.last(a1);
            Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
            Expr e1 = ExprFactory.makeMethodInvocation(NodeUtil.spanTwo(receiver, a2),
            receiver, last, a2);
            Expr e2 = (Expr)apply(a3s, e1);
            yyValue = (Expr)apply(a4s, e2);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for a4s.
        } // End scope for a3s.
      }

      // Nested alternative 4.

      yyRepetition1 = yyChoice1;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = p$$Shared37(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Action<Expr> v$el$8 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Expr>>(v$el$8, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        final Pair<Action<Expr>> a2s = yyRepValue1.reverse();

        Id last = IterUtil.last(a1);
        Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
        Expr e1 = ExprFactory.makeFieldRef(NodeUtil.spanTwo(receiver, last),
        receiver, last);
        yyValue = (Expr)apply(a2s, e1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Alternative 2.

    yyResult = p$$Shared29(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = p$$Shared21(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Action<Expr> v$el$9 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Expr>>(v$el$9, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        final Pair<Action<Expr>> a2s = yyRepValue1.reverse();

        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = p$$Shared30(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Action<Expr> v$el$10 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Action<Expr>>(v$el$10, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a3s.
          final Pair<Action<Expr>> a3s = yyRepValue1.reverse();

          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = p$$Shared37(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Action<Expr> v$el$11 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepeated1   = true;
              yyRepValue1   = new Pair<Action<Expr>>(v$el$11, yyRepValue1);
              continue;
            }
            break;
          }

          if (yyRepeated1) {
            final Pair<Action<Expr>> a4s = yyRepValue1.reverse();

            Expr e1 = (Expr)apply(a2s, a1);
            Expr e2 = (Expr)apply(a3s, e1);
            yyValue = (Expr)apply(a4s, e2);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }
        } // End scope for a3s.
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared19.
   * This nonterminal represents the duplicate productions 
   * Expression.DottedIdChain, NoNewlineExpr.DottedIdChain, 
   * and NoSpaceExpr.DottedIdChain.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared19(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Id>   yyRepValue1;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared19$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = p$$Shared19$$Choice2(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id v$el$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Id>(v$el$3, yyRepValue1);
          continue;
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Id> a2s = yyRepValue1.reverse();

        List<Id> ids = new ArrayList<Id>(a2s.list().size() + 1);
        ids.add(a1);
        ids.addAll(a2s.list());
        for (Id id : ids) {
          if ( NodeUtil.isKeyword(id) )
          log(NodeUtil.getSpan(id),
          "Keyword " + id + " cannot be used as an identifier.");
        }
        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared19$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared19$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pReserved(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared19$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared19$$Choice2(final int yyStart) throws IOException {
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pReserved(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pId(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared40.
   * This nonterminal represents the duplicate productions 
   * Expression.MathPrimary, NoNewlineExpr.MathPrimary, 
   * and NoSpaceExpr.MathPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared40(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    Pair<MathItem> yyRepValue1;
    Expr           yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared29(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = p$$Shared38(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final MathItem v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<MathItem>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        final Pair<MathItem> a2s = yyRepValue1.reverse();

        Span span = createSpan(yyStart,yyCount);
        List<MathItem> mis = a2s.list();
        if (mis.size() == 0)
        yyValue = a1;
        else if (mis.size() == 1)
        yyValue = ExprFactory.simplifyMathPrimary(span, a1, mis.get(0));
        else // mis.size() > 1
        yyValue = ExprFactory.makeMathPrimary(span, a1, mis);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared29.
   * This nonterminal represents the duplicate productions 
   * Expression.PrimaryFront, NoNewlineExpr.PrimaryFront, 
   * and NoSpaceExpr.PrimaryFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared29(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.f$$Shared29) 
      yyColumn.chunk14.f$$Shared29 = p$$Shared29$1(yyStart);
    return yyColumn.chunk14.f$$Shared29;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared29. */
  private Result p$$Shared29$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArrayExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMapExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pComprehension(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> v$el$7 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$7;
        }
      }
      { // Start scope for a2.
        List<StaticArg> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExprList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Expr> v$el$8 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$8;
          }
        }
        { // Start scope for a3.
          List<Expr> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pRightEncloser(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op a4 = yyResult.semanticValue();

              if (a3 == null) a3 = Collections.<Expr>emptyList();
              Span span = createSpan(yyStart,yyCount);
              if (a2 == null) yyValue = ASTUtil.enclosing(writer, span, a1, a3, a4);
              else            yyValue = ASTUtil.enclosing(writer, span, a1, a2, a3, a4);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 5.

    yyResult = p$$Shared22(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = p$$Shared20(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pself(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared20.
   * This nonterminal represents the duplicate productions 
   * Expression.VarOrFnRef, NoNewlineExpr.VarOrFnRef, 
   * and NoSpaceExpr.VarOrFnRef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared20(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.f$$Shared20) 
      yyColumn.chunk15.f$$Shared20 = p$$Shared20$1(yyStart);
    return yyColumn.chunk15.f$$Shared20;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared20. */
  private Result p$$Shared20$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> a2 = yyResult.semanticValue();

          yyValue = ExprFactory.makeFnRef(createSpan(yyStart,yyCount), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyValue = ExprFactory.makeVarRef(NodeUtil.getSpan(a1), a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared21.
   * This nonterminal represents the duplicate productions 
   * Expression.SubscriptingLeft, NoNewlineExpr.SubscriptingLeft, 
   * and NoSpaceExpr.SubscriptingLeft.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared21(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared21$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<StaticArg> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a2.
        final List<StaticArg> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExprList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<Expr> v$el$4 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$4;
          }
        }
        { // Start scope for a3.
          final List<Expr> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared21$$Choice2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final String a4 = yyResult.semanticValue();

              yyValue = new Action<Expr>() {
                public Expr run(Expr base) {
                  Span span = NodeUtil.spanTwo(NodeUtil.getSpan(base),
                  createSpan(yyStart,yyCount));
                  if (PrecedenceMap.ONLY.matchedBrackets(a1, a4)) {
                    List<StaticArg> ss =
                    (a2 == null) ? Collections.<StaticArg>emptyList() : a2;
                    return ExprFactory.makeSubscripting(span, a1, a4, base, a3, ss);
                  } else {
                    log(span, "Mismatched subscripting operator: " +
                    a1 + " and " + a4);
                    return ExprFactory.makeVoidLiteralExpr(span);
                  }
              }};

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<StaticArg> v$el$7 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$7;
        }
      }
      { // Start scope for a2.
        final List<StaticArg> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExprList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<Expr> v$el$8 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$8;
          }
        }
        { // Start scope for a3.
          final List<Expr> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pRightEncloser(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Op a4 = yyResult.semanticValue();

              yyValue = new Action<Expr>() {
                public Expr run(Expr base) {
                  Span span = NodeUtil.spanTwo(base, a4);
                  List<StaticArg> ss =
                  (a2 == null) ? Collections.<StaticArg>emptyList() : a2;
                  return ExprFactory.makeSubscripting(span, base, a1.getText(),
                  a4.getText(), a3, ss);
              }};

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared21$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared21$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$opensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared21$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared21$$Choice2(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared30.
   * This nonterminal represents the duplicate productions 
   * Expression.ParenthesisDelimitedLeft, 
   * NoNewlineExpr.ParenthesisDelimitedLeft, 
   * and NoSpaceExpr.ParenthesisDelimitedLeft.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared30(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared22(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr a1 = yyResult.semanticValue();

      yyValue = new Action<Expr>() {
        public Expr run(Expr base) {
          return ExprFactory.makeTightJuxt(NodeUtil.spanTwo(base, a1),
          false, Useful.list(base, a1));
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared22.
   * This nonterminal represents the duplicate productions 
   * Expression.ParenthesisDelimited, NoNewlineExpr.ParenthesisDelimited, 
   * and NoSpaceExpr.ParenthesisDelimited.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared22(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.f$$Shared22) 
      yyColumn.chunk15.f$$Shared22 = p$$Shared22$1(yyStart);
    return yyColumn.chunk15.f$$Shared22;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared22. */
  private Result p$$Shared22$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParenthesized(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pArgExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = ExprFactory.makeVoidLiteralExpr(createSpan(yyStart,yyCount));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared37.
   * This nonterminal represents the duplicate productions 
   * Expression.Selector, NoNewlineExpr.Selector, and NoSpaceExpr.Selector.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared37(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Expr>> yyRepValue1;
    int                yyOption1;
    List<StaticArg>    yyOpValue1;
    Action<Expr>       yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = p$$Shared54(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticArgs(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final List<StaticArg> v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
          { // Start scope for a2.
            final List<StaticArg> a2 = yyOpValue1;

            yyResult = p$$Shared22(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Expr a3 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = p$$Shared30(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Action<Expr> v$el$4 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<Action<Expr>>(v$el$4, yyRepValue1);
                  continue;
                }
                break;
              }
              { // Start scope for a4s.
                final Pair<Action<Expr>> a4s = yyRepValue1.reverse();

                yyValue = new Action<Expr>() {
                  public Expr run(Expr base) {
                    Span span = NodeUtil.spanTwo(base, a3);
                    if ( NodeUtil.isKeyword(a1) )
                    log(span, "Keyword " + a1 + " cannot be used as an identifier.");
                    List<StaticArg> sargs =
                    (a2 == null) ? Collections.<StaticArg>emptyList() : a2;
                    Expr mtdInv =
                    ExprFactory.makeMethodInvocation(span, base, a1, sargs, a3);
                    return (Expr)apply(a4s, mtdInv);
                }};

                return new SemanticValue(yyValue, yyRepetition1, yyError);
              } // End scope for a4s.
            }
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = p$$Shared54(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Id a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = p$$Shared21(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Action<Expr> v$el$3 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Expr>>(v$el$3, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for a2s.
            final Pair<Action<Expr>> a2s = yyRepValue1.reverse();

            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = p$$Shared30(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Action<Expr> v$el$4 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Action<Expr>>(v$el$4, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for a3s.
              final Pair<Action<Expr>> a3s = yyRepValue1.reverse();

              yyValue = new Action<Expr>() {
                public Expr run(Expr base) {
                  Span span = NodeUtil.spanTwo(base, a1);
                  if ( NodeUtil.isKeyword(a1) )
                  log(span, "Keyword " + a1 + " cannot be used as an identifier.");
                  Expr fldSel = ExprFactory.makeFieldRef(span, base, a1);
                  return (Expr)apply(a3s, (Expr)apply(a2s, fldSel));
              }};

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            } // End scope for a3s.
          } // End scope for a2s.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared38.
   * This nonterminal represents the duplicate productions 
   * Expression.MathItem, NoNewlineExpr.MathItem, and NoSpaceExpr.MathItem.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared38(final int yyStart) throws IOException {
    Result     yyResult;
    MathItem   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared23(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared35(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared22(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeParenthesisDelimitedMI(NodeUtil.getSpan(a1), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeNonParenthesisDelimitedMI(NodeUtil.getSpan(a1), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = p$$Shared20(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeNonParenthesisDelimitedMI(NodeUtil.getSpan(a1), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pself(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      Expr expr = ExprFactory.makeVarRef(span, a1);
      yyValue = ExprFactory.makeNonParenthesisDelimitedMI(span, expr);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared23.
   * This nonterminal represents the duplicate productions 
   * Expression.Subscripting, NoNewlineExpr.Subscripting, 
   * and NoSpaceExpr.Subscripting.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared23(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Object         yyOpValue1;
    SubscriptingMI yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared23$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a2.
        List<StaticArg> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExprList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Expr> v$el$4 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$4;
          }
        }
        { // Start scope for a3.
          List<Expr> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared23$$Choice2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a4 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              Op op = NodeFactory.makeEnclosing(span, a1, a4, true, false);
              if (a2 == null) a2 = Collections.<StaticArg>emptyList();
              if (a3 == null) a3 = Collections.<Expr>emptyList();
              if (! PrecedenceMap.ONLY.matchedBrackets(a1, a4))
              log(span, "Mismatched subscripting operator: " + a1 + " and " + a4);
              yyValue = ExprFactory.makeSubscriptingMI(span, op, a3, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> v$el$7 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$7;
        }
      }
      { // Start scope for a2.
        List<StaticArg> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExprList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Expr> v$el$8 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$8;
          }
        }
        { // Start scope for a3.
          List<Expr> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pRightEncloser(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op a4 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              Op op = NodeFactory.makeEnclosing(span, a1.getText(),a4.getText(), true, false);
              if (a2 == null) a2 = Collections.<StaticArg>emptyList();
              if (a3 == null) a3 = Collections.<Expr>emptyList();
              yyValue = ExprFactory.makeSubscriptingMI(span, op, a3, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared23$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared23$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$opensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared23$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared23$$Choice2(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared35.
   * This nonterminal represents the duplicate productions 
   * Expression.Exponentiation, NoNewlineExpr.Exponentiation, 
   * and NoSpaceExpr.Exponentiation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared35(final int yyStart) throws IOException {
    Result           yyResult;
    ExponentiationMI yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = phasW(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Boolean a2 = yyResult.semanticValue();

        yyResult = p$$Shared31(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a3 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          if ( a2.booleanValue() )
          log(span, "Space is not allowed immediately after '^'.");
          yyValue = ExprFactory.makeExponentiationMI(span,
          ExprFactory.makeOpRef(NodeFactory.makeOpInfix(span, a1)),
          Option.<Expr>some(a3));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pExponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeExponentiationMI(NodeUtil.getSpan(a1),
      ExprFactory.makeOpRef(a1),
      Option.<Expr>none());

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared31.
   * This nonterminal represents the duplicate productions 
   * Expression.Exponent, NoNewlineExpr.Exponent, and NoSpaceExpr.Exponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared31(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared22(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pself(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.FlowExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$FlowExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pwith(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression$Expr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = cast(yyOpValue1);

          Option<Id> name = (a1 == null) ? Option.<Id>none() : Option.<Id>some(a1);
          yyValue = ExprFactory.makeExit(createSpan(yyStart,yyCount),
          Option.<Type>none(), name,
          Option.<Expr>wrap(a2));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pAccumulator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a2.
        List<StaticArg> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$opensquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression$GeneratorClauseList(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<GeneratorClause> v$el$4 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared7(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                }
              }
            }
          }
        }
        { // Start scope for a3.
          List<GeneratorClause> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a4 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              if (a2 == null) a2 = Collections.<StaticArg>emptyList();
              if (a3 == null)
              yyValue = ExprFactory.makeOpExpr(span, a1, a4, a2);
              else
              yyValue = ExprFactory.makeAccumulator(span, a2, a1, a3, a4);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 3.

    yyResult = pBIG(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pLeftEncloser(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a1 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = pw(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pmapsto(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pStaticArgs(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<StaticArg> v$el$5 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$5;
                }
              }
              { // Start scope for a2.
                List<StaticArg> a2 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pRightEncloser(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Op a3 = yyResult.semanticValue();

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pExpression$Expr(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Expr a4 = yyResult.semanticValue();

                        Span span = createSpan(yyStart,yyCount);
                        if (a2 == null) a2 = Collections.<StaticArg>emptyList();
                        Op opr = NodeFactory.makeEnclosing(span, "BIG " + a1.getText() + "|->",
                        "BIG " + a3.getText());
                        yyValue = ExprFactory.makeOpExpr(span, opr, a4, a2);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              } // End scope for a2.
            }
          }

          // Nested alternative 2.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticArgs(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticArg> v$el$6 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$6;
            }
          }
          { // Start scope for a2.
            List<StaticArg> a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pRightEncloser(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Op a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pExpression$Expr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr a4 = yyResult.semanticValue();

                    Span span = createSpan(yyStart,yyCount);
                    if (a2 == null) a2 = Collections.<StaticArg>emptyList();
                    Op opr = NodeFactory.makeEnclosing(span, "BIG " + a1.getText(),
                    "BIG " + a3.getText());
                    yyValue = ExprFactory.makeOpExpr(span, opr, a4, a2);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Alternative 4.

    yyResult = patomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = ExprFactory.makeAtomicExpr(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = ptryatomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = ExprFactory.makeTryAtomicExpr(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pspawn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = ExprFactory.makeSpawn(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 7.

    yyResult = pthrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = ExprFactory.makeThrow(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.AtomicBack.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$AtomicBack(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fExpression$AtomicBack) 
      yyColumn.chunk15.fExpression$AtomicBack = pExpression$AtomicBack$1(yyStart);
    return yyColumn.chunk15.fExpression$AtomicBack;
  }

  /** Actually parse Expression.AtomicBack. */
  private Result pExpression$AtomicBack$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$AssignExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.GeneratorClauseList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$GeneratorClauseList(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fExpression$GeneratorClauseList) 
      yyColumn.chunk15.fExpression$GeneratorClauseList = pExpression$GeneratorClauseList$1(yyStart);
    return yyColumn.chunk15.fExpression$GeneratorClauseList;
  }

  /** Actually parse Expression.GeneratorClauseList. */
  private Result pExpression$GeneratorClauseList$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    List<GeneratorClause> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$GeneratorBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      GeneratorClause a1 = yyResult.semanticValue();

      yyResult = pExpression$GeneratorClauseList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<GeneratorClause> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Expression.GeneratorClauseList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$GeneratorClauseList$$Star1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fExpression$GeneratorClauseList$$Star1) 
      yyColumn.chunk15.fExpression$GeneratorClauseList$$Star1 = pExpression$GeneratorClauseList$$Star1$1(yyStart);
    return yyColumn.chunk15.fExpression$GeneratorClauseList$$Star1;
  }

  /** Actually parse Expression.GeneratorClauseList$$Star1. */
  private Result pExpression$GeneratorClauseList$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<GeneratorClause> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$GeneratorClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            GeneratorClause v$el$1 = yyResult.semanticValue();

            yyResult = pExpression$GeneratorClauseList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<GeneratorClause> v$2 = yyResult.semanticValue();

              yyValue = new Pair<GeneratorClause>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.GeneratorBinding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$GeneratorBinding(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fExpression$GeneratorBinding) 
      yyColumn.chunk15.fExpression$GeneratorBinding = pExpression$GeneratorBinding$1(yyStart);
    return yyColumn.chunk15.fExpression$GeneratorBinding;
  }

  /** Actually parse Expression.GeneratorBinding. */
  private Result pExpression$GeneratorBinding$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    GeneratorClause yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindIdOrBindIdTuple(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Id> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pleftarrow(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = ExprFactory.makeGeneratorClause(createSpan(yyStart,yyCount),
              a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.GeneratorClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$GeneratorClause(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fExpression$GeneratorClause) 
      yyColumn.chunk15.fExpression$GeneratorClause = pExpression$GeneratorClause$1(yyStart);
    return yyColumn.chunk15.fExpression$GeneratorClause;
  }

  /** Actually parse Expression.GeneratorClause. */
  private Result pExpression$GeneratorClause$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    GeneratorClause yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$GeneratorBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeGeneratorClause(NodeUtil.getSpan(a1),
      Collections.<Id>emptyList(), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.DelimitedExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDelimitedExpr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fDelimitedExpr) 
      yyColumn.chunk15.fDelimitedExpr = pDelimitedExpr$1(yyStart);
    return yyColumn.chunk15.fDelimitedExpr;
  }

  /** Actually parse DelimitedExpr.DelimitedExpr. */
  private Result pDelimitedExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArgExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pParenthesized(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pobject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendsWhere(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<TraitTypeWhere> v$el$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$4;
        }
      }
      { // Start scope for a1.
        List<TraitTypeWhere> a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pnl(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoInAnObject(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Decl> v$el$5 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$5;
          }
        }
        { // Start scope for a2.
          List<Decl> a2 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pend(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              if (a1 == null) a1 = Collections.<TraitTypeWhere>emptyList();
              if (a2 == null) a2 = Collections.<Decl>emptyList();
              yyValue = ExprFactory.makeObjectExpr(createSpan(yyStart,yyCount),
              a1, a2, Option.<SelfType>none());

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a2.
      } // End scope for a1.
    }

    // Alternative 4.

    yyResult = pDo(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = plabel(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrOpName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdOrOp a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pend(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pIdOrOpName(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      IdOrOp a3 = yyResult.semanticValue();

                      Span span = NodeUtil.getSpan(a1);
                      if (!a1.getText().equals(a3.getText()))
                      log(span, "Mismatched identifiers for a label expression:\n        '" +
                      a1 + "' at " + span + " and\n        '" +
                      a3 + "' at " + NodeUtil.getSpan(a3));
                      if ( a1 instanceof Op ) {
                        if (a1.getText().equals("in"))
                        log(span, "'in' is a reserved word, and cannot be used as a label.");
                        else
                        log(span, a1 + " is not a valid label name.\n");
                        yyValue = ExprFactory.makeVoidLiteralExpr(createSpan(yyStart,yyCount));
                      } else
                      yyValue = ExprFactory.makeLabel(createSpan(yyStart,yyCount), (Id)a1, a2);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 6.

    yyResult = pwhile(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$GeneratorClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          GeneratorClause a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDo(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Do a2 = yyResult.semanticValue();

              yyValue = ExprFactory.makeWhile(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 7.

    yyResult = pfor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$GeneratorClauseList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<GeneratorClause> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDoFront(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pend(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = ExprFactory.makeFor(createSpan(yyStart,yyCount), a1, a2);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Alternative 8.

    yyResult = pif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$GeneratorClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          GeneratorClause a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pthen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pBlockElems(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Block a2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pElifs(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<IfClause> v$el$6 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$6;
                    }
                  }
                  { // Start scope for a3.
                    List<IfClause> a3 = cast(yyOpValue1);

                    final int yyChoice1 = yyOption1;

                    // Nested alternative 1.

                    yyOption1  = yyChoice1;
                    yyOpValue1 = null;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pElse(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Block v$el$7 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$7;
                      }
                    }
                    { // Start scope for a4.
                      Block a4 = cast(yyOpValue1);

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pend(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          List<IfClause> clauses =
                          Useful.list(NodeFactory.makeIfClause(NodeUtil.spanTwo(a1,a2), a1, a2));
                          if (a3 != null) clauses.addAll(a3);
                          yyValue = ExprFactory.makeIf(createSpan(yyStart,yyCount), clauses,
                          Option.<Block>wrap(a4));

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    } // End scope for a4.

                    // Nested alternative 2.

                    yyResult = pw(yyChoice1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pElse(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Block a4 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pend(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyOption1  = yyResult.index;
                          }
                        }

                        yyPredResult = pw(yyOption1);
                        yyError      = yyPredResult.select(yyError);
                        if (yyPredResult.hasValue()) {

                          yyPredResult = pcloseparen(yyPredResult.index);
                          yyError      = yyPredResult.select(yyError);
                          if (yyPredResult.hasValue()) {

                            List<IfClause> clauses =
                            Useful.list(NodeFactory.makeIfClause(NodeUtil.spanTwo(a1,a2), a1, a2));
                            if (a3 != null) clauses.addAll(a3);
                            yyValue = ExprFactory.makeIf(createSpan(yyStart,yyCount), clauses,
                            Option.<Block>some(a4));

                            return new SemanticValue(yyValue, yyOption1, yyError);
                          }
                        }
                      }
                    }
                  } // End scope for a3.
                }
              }
            }
          }
        }
      }
    }

    // Alternative 9.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pif(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$GeneratorClause(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              GeneratorClause a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pthen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pBlockElems(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Block a2 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pElifs(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          List<IfClause> v$el$8 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$8;
                        }
                      }
                      { // Start scope for a3.
                        List<IfClause> a3 = cast(yyOpValue1);

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pElse(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            Block a4 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;

                            yyResult = pw(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pend(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyOption1  = yyResult.index;
                              }
                            }

                            yyResult = pw(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pcloseparen(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                List<IfClause> clauses =
                                Useful.list(NodeFactory.makeIfClause(NodeUtil.spanTwo(a1,a2), a1, a2));
                                if (a3 != null) clauses.addAll(a3);
                                yyValue = ExprFactory.makeIf(createSpan(yyStart,yyCount), clauses,
                                Option.<Block>some(a4));

                                return yyResult.createValue(yyValue, yyError);
                              }
                            }
                          }
                        }
                      } // End scope for a3.
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 10.

    yyResult = pcase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$Expr(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pDelimitedExpr$$Choice1(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op v$el$9 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$9;
          }
          { // Start scope for a2.
            Op a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared55(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pCaseClauses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<CaseClause> a4 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = pbr(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pCaseElse(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Block v$el$15 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$15;
                      }
                    }
                    { // Start scope for a5.
                      Block a5 = cast(yyOpValue1);

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pend(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          Span span = createSpan(yyStart,yyCount);
                          Option<FunctionalRef> compare = (a2 == null) ? Option.<FunctionalRef>none()
                          : Option.<FunctionalRef>some(ExprFactory.makeOpRef(NodeFactory.makeOpInfix(a2)));
                          Option<Block> _else = (a5 == null) ? Option.<Block>none()
                          : Option.<Block>some(a5);
                          if ( ! a3.equals("of") )
                          log(span, "In a case expression, '" + a3 +
                          "' is used incorrectly.  Use 'of' instead.");
                          yyValue = ExprFactory.makeCaseExpr(span, Option.<Expr>some(a1),
                          compare, a4, _else);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    } // End scope for a5.
                  }
                }
              }
            }
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = pmost(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared56(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = p$$Shared55(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  String a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pCaseClauses(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<CaseClause> a3 = yyResult.semanticValue();

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pend(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          Span span = createSpan(yyStart,yyCount);
                          if ( ! a2.equals("of") )
                          log(span, "In an extremum expression, '" + a2 +
                          "' is used incorrectly.  Use 'of' instead.");
                          Option<FunctionalRef> compare =
                          Option.<FunctionalRef>some(ExprFactory.makeOpRef(NodeFactory.makeOpInfix(a1)));
                          yyValue = ExprFactory.makeCaseExpr(span, Option.<Expr>none(), compare, a3,
                          Option.<Block>none());

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 11.

    yyResult = ptypecase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$Expr(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared55(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pTypecaseClauses(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<TypecaseClause> a3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pbr(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pCaseElse(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Block v$el$24 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$24;
                    }
                  }
                  { // Start scope for a4.
                    Block a4 = cast(yyOpValue1);

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pend(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        Span span = createSpan(yyStart,yyCount);
                        if ( ! a2.equals("of") )
                        log(span, "In a typecase expression, '" + a2 +
                        "' is used incorrectly.  Use 'of' instead.");
                        yyValue = ExprFactory.makeTypecase(span, false, Option.<Type>none(),
                        a1, a3, Option.<Block>wrap(a4));

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  } // End scope for a4.
                }
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = pself(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared55(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pTypecaseClauses(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;

                  yyResult = pbr(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pCaseElse(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                    }
                  }

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pend(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      Span span = createSpan(yyStart,yyCount);
                      if ( ! a1.equals("of") )
                      log(span, "In a typecase expression, '" + a1 +
                      "' is used incorrectly.  Use 'of' instead.");
                      log(span, "In a typecase expression, 'self' is used incorrectly.  " +
                      "Use a binding such as 'x = self' instead.");
                      yyValue = ExprFactory.makeVoidLiteralExpr(span);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative <TRY>.

    yyResult = ptry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlockElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Block a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pCatch(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Catch v$el$28 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$28;
            }
          }
          { // Start scope for a2.
            Catch a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pforbid(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pTraitTypes(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<BaseType> v$el$29 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$29;
                  }
                }
              }
            }
            { // Start scope for a3.
              List<BaseType> a3 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pfinally(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pBlockElems(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Block v$el$30 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$30;
                    }
                  }
                }
              }
              { // Start scope for a4.
                Block a4 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pend(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    if (a3 == null) a3 = Collections.<BaseType>emptyList();
                    yyValue = ExprFactory.makeTry(createSpan(yyStart,yyCount), a1,
                    Option.<Catch>wrap(a2), a3,
                    Option.<Block>wrap(a4));

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a4.
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.DelimitedExpr$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDelimitedExpr$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pOp(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared55.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.DelimitedExpr$$Choice2, 
   * com.sun.fortress.parser.templateparser.TemplateParser.DelimitedExpr$$Choice4, 
   * com.sun.fortress.parser.templateparser.TemplateParser.DelimitedExpr$$Choice5, 
   * and com.sun.fortress.parser.templateparser.TemplateParser.DelimitedExpr$$Choice6.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared55(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.f$$Shared55) 
      yyColumn.chunk15.f$$Shared55 = p$$Shared55$1(yyStart);
    return yyColumn.chunk15.f$$Shared55;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared55. */
  private Result p$$Shared55$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'o':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('f' == yyC) {

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = "of";

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select(" expected", yyStart);
              }
            }
          }
        }
        break;

      case 'd':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('o' == yyC) {

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = "do";

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select(" expected", yyStart);
              }
            }
          }
        }
        break;

      case 'i':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = "in";

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select(" expected", yyStart);
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared56.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.DelimitedExpr$$Choice3 
   * and com.sun.fortress.parser.templateparser.TemplateParser.SimpleName$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared56(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.f$$Shared56) 
      yyColumn.chunk15.f$$Shared56 = p$$Shared56$1(yyStart);
    return yyColumn.chunk15.f$$Shared56;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared56. */
  private Result p$$Shared56$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Do.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDo(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fDo) yyColumn.chunk16.fDo = pDo$1(yyStart);
    return yyColumn.chunk16.fDo;
  }

  /** Actually parse DelimitedExpr.Do. */
  private Result pDo$1(final int yyStart) throws IOException {
    Result     yyResult;
    Do         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDo$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Block> a1s = yyResult.semanticValue();

      yyResult = pDoFront(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Block a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pend(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = ExprFactory.makeDo(createSpan(yyStart, yyCount),
            Useful.list(a1s.list(), a2));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Do$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDo$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fDo$$Star1) 
      yyColumn.chunk16.fDo$$Star1 = pDo$$Star1$1(yyStart);
    return yyColumn.chunk16.fDo$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.Do$$Star1. */
  private Result pDo$$Star1$1(final int yyStart) throws IOException {
    Result      yyResult;
    Pair<Block> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDoFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Block v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = palso(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDo$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Block> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Block>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.DoFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDoFront(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fDoFront) 
      yyColumn.chunk16.fDoFront = pDoFront$1(yyStart);
    return yyColumn.chunk16.fDoFront;
  }

  /** Actually parse DelimitedExpr.DoFront. */
  private Result pDoFront$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pat(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr v$el$1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
      }
    }
    { // Start scope for a1.
      Expr a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = patomic(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        String a2 = cast(yyOpValue1);

        yyResult = pdo(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
          { // Start scope for a3.
            Block a3 = cast(yyOpValue1);

            boolean atomic = (a2 == null) ? false : true;
            List<Expr> es = (a3 == null) ? Collections.<Expr>emptyList()
            : a3.getExprs();
            yyValue = ExprFactory.makeBlock(createSpan(yyStart,yyCount), false,
            Option.<Type>none(),
            Option.<Expr>wrap(a1), atomic, true, es);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      } // End scope for a2.
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.ArgExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgExpr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fArgExpr) 
      yyColumn.chunk16.fArgExpr = pArgExpr$1(yyStart);
    return yyColumn.chunk16.fArgExpr;
  }

  /** Actually parse DelimitedExpr.ArgExpr. */
  private Result pArgExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Expr       yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pArgExpr$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Expr> a1s = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pExpression$Expr(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr v$el$4 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$4;
                    }
                  }
                }
              }
            }
          }
          { // Start scope for a2.
            Expr a2 = yyOpValue1;

            yyResult = pKeywordExpr(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              KeywordExpr a3 = yyResult.semanticValue();

              yyResult = pArgExpr$$Star2(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<KeywordExpr> a4s = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    Option<Expr> vs = ((a2 != null) ? Option.<Expr>some(a2)
                    : Option.<Expr>none());
                    List<KeywordExpr> ks = new ArrayList<KeywordExpr>();
                    ks.add(a3);
                    for (KeywordExpr b : (List<KeywordExpr>)a4s.list()) {
                      ks.add(b);
                    }
                    yyValue = ExprFactory.makeTupleExpr(createSpan(yyStart,yyCount),
                    false, Option.<Type>none(),
                    a1s.list(), vs, ks, false);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.

          // Nested alternative 2.

          yyResult = pExpression$Expr(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = ExprFactory.makeTupleExpr(createSpan(yyStart,yyCount),
                    false, Option.<Type>none(),
                    a1s.list(), Option.<Expr>some(a2),
                    Collections.<KeywordExpr>emptyList(),
                    false);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pTupleExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ArgExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgExpr$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fArgExpr$$Star1) 
      yyColumn.chunk16.fArgExpr$$Star1 = pArgExpr$$Star1$1(yyStart);
    return yyColumn.chunk16.fArgExpr$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.ArgExpr$$Star1. */
  private Result pArgExpr$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr v$el$2 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pArgExpr$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expr> v$3 = yyResult.semanticValue();

              yyValue = new Pair<Expr>(v$el$2, v$3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ArgExpr$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgExpr$$Star2(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fArgExpr$$Star2) 
      yyColumn.chunk16.fArgExpr$$Star2 = pArgExpr$$Star2$1(yyStart);
    return yyColumn.chunk16.fArgExpr$$Star2;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.ArgExpr$$Star2. */
  private Result pArgExpr$$Star2$1(final int yyStart) throws IOException {
    Result            yyResult;
    Pair<KeywordExpr> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pKeywordExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            KeywordExpr v$el$5 = yyResult.semanticValue();

            yyResult = pArgExpr$$Star2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<KeywordExpr> v$6 = yyResult.semanticValue();

              yyValue = new Pair<KeywordExpr>(v$el$5, v$6);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TupleExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Expr> yyRepValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = false;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pExpression$Expr(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr v$el$1 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyRepetition1 = yyResult.index;
                  yyRepeated1   = true;
                  yyRepValue1   = new Pair<Expr>(v$el$1, yyRepValue1);
                  continue;
                }
              }
            }
          }
          break;
        }

        if (yyRepeated1) {
          Pair<Expr> a1s = yyRepValue1.reverse();

          yyResult = pExpression$Expr(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = ExprFactory.makeTupleExpr(createSpan(yyStart,yyCount),
                Useful.list(a1s.list(), a2));

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.KeywordExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKeywordExpr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fKeywordExpr) 
      yyColumn.chunk16.fKeywordExpr = pKeywordExpr$1(yyStart);
    return yyColumn.chunk16.fKeywordExpr;
  }

  /** Actually parse DelimitedExpr.KeywordExpr. */
  private Result pKeywordExpr$1(final int yyStart) throws IOException {
    Result      yyResult;
    KeywordExpr yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeKeywordExpr(createSpan(yyStart,yyCount),
              a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Parenthesized.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParenthesized(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fParenthesized) 
      yyColumn.chunk16.fParenthesized = pParenthesized$1(yyStart);
    return yyColumn.chunk16.fParenthesized;
  }

  /** Actually parse DelimitedExpr.Parenthesized. */
  private Result pParenthesized$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = ExprFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Elifs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElifs(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fElifs) 
      yyColumn.chunk16.fElifs = pElifs$1(yyStart);
    return yyColumn.chunk16.fElifs;
  }

  /** Actually parse DelimitedExpr.Elifs. */
  private Result pElifs$1(final int yyStart) throws IOException {
    Result         yyResult;
    List<IfClause> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pElif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IfClause a1 = yyResult.semanticValue();

      yyResult = pElifs$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<IfClause> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Elifs$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElifs$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fElifs$$Star1) 
      yyColumn.chunk16.fElifs$$Star1 = pElifs$$Star1$1(yyStart);
    return yyColumn.chunk16.fElifs$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.Elifs$$Star1. */
  private Result pElifs$$Star1$1(final int yyStart) throws IOException {
    Result         yyResult;
    Pair<IfClause> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pElif(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        IfClause v$el$1 = yyResult.semanticValue();

        yyResult = pElifs$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<IfClause> v$2 = yyResult.semanticValue();

          yyValue = new Pair<IfClause>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Elif.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElif(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fElif) 
      yyColumn.chunk17.fElif = pElif$1(yyStart);
    return yyColumn.chunk17.fElif;
  }

  /** Actually parse DelimitedExpr.Elif. */
  private Result pElif$1(final int yyStart) throws IOException {
    Result     yyResult;
    IfClause   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pelif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$GeneratorClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          GeneratorClause a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pthen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pBlockElems(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Block a2 = yyResult.semanticValue();

                  yyValue = NodeFactory.makeIfClause(createSpan(yyStart,yyCount), a1, a2);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Else.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElse(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fElse) 
      yyColumn.chunk17.fElse = pElse$1(yyStart);
    return yyColumn.chunk17.fElse;
  }

  /** Actually parse DelimitedExpr.Else. */
  private Result pElse$1(final int yyStart) throws IOException {
    Result     yyResult;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pelse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlockElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CaseClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClauses(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fCaseClauses) 
      yyColumn.chunk17.fCaseClauses = pCaseClauses$1(yyStart);
    return yyColumn.chunk17.fCaseClauses;
  }

  /** Actually parse DelimitedExpr.CaseClauses. */
  private Result pCaseClauses$1(final int yyStart) throws IOException {
    Result           yyResult;
    List<CaseClause> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCaseClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CaseClause a1 = yyResult.semanticValue();

      yyResult = pCaseClauses$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<CaseClause> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.CaseClauses$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClauses$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fCaseClauses$$Star1) 
      yyColumn.chunk17.fCaseClauses$$Star1 = pCaseClauses$$Star1$1(yyStart);
    return yyColumn.chunk17.fCaseClauses$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.CaseClauses$$Star1. */
  private Result pCaseClauses$$Star1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<CaseClause> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCaseClause(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        CaseClause v$el$1 = yyResult.semanticValue();

        yyResult = pCaseClauses$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<CaseClause> v$2 = yyResult.semanticValue();

          yyValue = new Pair<CaseClause>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CaseElse.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseElse(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fCaseElse) 
      yyColumn.chunk17.fCaseElse = pCaseElse$1(yyStart);
    return yyColumn.chunk17.fCaseElse;
  }

  /** Actually parse DelimitedExpr.CaseElse. */
  private Result pCaseElse$1(final int yyStart) throws IOException {
    Result     yyResult;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pelse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              yyValue = yyResult.semanticValue();

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TypecaseClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseClauses(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fTypecaseClauses) 
      yyColumn.chunk17.fTypecaseClauses = pTypecaseClauses$1(yyStart);
    return yyColumn.chunk17.fTypecaseClauses;
  }

  /** Actually parse DelimitedExpr.TypecaseClauses. */
  private Result pTypecaseClauses$1(final int yyStart) throws IOException {
    Result               yyResult;
    List<TypecaseClause> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypecaseClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypecaseClause a1 = yyResult.semanticValue();

      yyResult = pTypecaseClauses$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<TypecaseClause> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.TypecaseClauses$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseClauses$$Star1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fTypecaseClauses$$Star1) 
      yyColumn.chunk17.fTypecaseClauses$$Star1 = pTypecaseClauses$$Star1$1(yyStart);
    return yyColumn.chunk17.fTypecaseClauses$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.TypecaseClauses$$Star1. */
  private Result pTypecaseClauses$$Star1$1(final int yyStart) 
    throws IOException {

    Result               yyResult;
    Pair<TypecaseClause> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pTypecaseClause(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        TypecaseClause v$el$1 = yyResult.semanticValue();

        yyResult = pTypecaseClauses$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<TypecaseClause> v$2 = yyResult.semanticValue();

          yyValue = new Pair<TypecaseClause>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TypecaseClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseClause(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fTypecaseClause) 
      yyColumn.chunk17.fTypecaseClause = pTypecaseClause$1(yyStart);
    return yyColumn.chunk17.fTypecaseClause;
  }

  /** Actually parse DelimitedExpr.TypecaseClause. */
  private Result pTypecaseClause$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Id             yyOpValue1;
    TypecaseClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a3 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeTypecaseClause(span,
              Option.<Id>none(),
              NodeFactory.makeVarType(span, a1),
              a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pId(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
      }
    }
    { // Start scope for a1.
      Id a1 = yyOpValue1;

      yyResult = pTypeOrPattern(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        TypeOrPattern a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pmatch(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pBlockElems(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Block a3 = yyResult.semanticValue();

                yyValue = NodeFactory.makeTypecaseClause(createSpan(yyStart,yyCount),
                Option.<Id>wrap(a1), a2, a3);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Catch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatch(final int yyStart) throws IOException {
    Result     yyResult;
    Catch      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcatch(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBindId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pCatchClauses(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<CatchClause> a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeCatch(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CatchClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatchClauses(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<CatchClause> yyRepValue1;
    List<CatchClause> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCatchClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CatchClause a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pCatchClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            CatchClause v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<CatchClause>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<CatchClause> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CatchClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatchClause(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fCatchClause) 
      yyColumn.chunk17.fCatchClause = pCatchClause$1(yyStart);
    return yyColumn.chunk17.fCatchClause;
  }

  /** Actually parse DelimitedExpr.CatchClause. */
  private Result pCatchClause$1(final int yyStart) throws IOException {
    Result      yyResult;
    CatchClause yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$TraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BaseType a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeCatchClause(createSpan(yyStart,yyCount),
              a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.MapExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMapExpr(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<StaticArg> yyOpValue1;
    Expr            yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<StaticArg> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pEntryList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Expr> a3 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pRightEncloser(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Op a4 = yyResult.semanticValue();

                if (a3 == null) a3 = Collections.<Expr>emptyList();
                Span span = createSpan(yyStart,yyCount);
                Op open  = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyStart+1),
                a1.getText() + "|->");
                Op close = NodeFactory.makeOpEnclosing(createSpan(yyCount-1,1),
                a4.getText());
                if (a2 == null)
                yyValue = ASTUtil.enclosing(writer, span, open, a3, close);
                else yyValue = ASTUtil.enclosing(writer, span, open, a2, a3, close);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Comprehension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComprehension(final int yyStart) throws IOException {
    Result                         yyResult;
    int                            yyRepetition1;
    Pair<ArrayComprehensionClause> yyRepValue1;
    int                            yyOption1;
    List<StaticArg>                yyOpValue1;
    Expr                           yyValue;
    ParseError                     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyResult = pBIG(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }
    }
    { // Start scope for nested choice.

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pSymbol$opensquare(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArgs(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<StaticArg> v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
        { // Start scope for a1.
          List<StaticArg> a1 = yyOpValue1;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pArrayComprehensionClause(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              ArrayComprehensionClause a2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pbr(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pArrayComprehensionClause(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    ArrayComprehensionClause v$el$2 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = 
                      new Pair<ArrayComprehensionClause>(v$el$2, yyRepValue1);
                    continue;
                  }
                }
                break;
              }
              { // Start scope for a3s.
                Pair<ArrayComprehensionClause> a3s = yyRepValue1.reverse();

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared7(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    Span span = createSpan(yyStart,yyCount);
                    if (a1 == null) a1 = Collections.<StaticArg>emptyList();
                    yyValue = ExprFactory.makeArrayComprehension(span, a1,
                    Useful.cons(a2, a3s.list()));

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a3s.
            }
          }
        } // End scope for a1.
      }

      // Nested alternative 2.

      yyResult = pLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArgs(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<StaticArg> v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
        }
        { // Start scope for a2.
          List<StaticArg> a2 = yyOpValue1;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyResult = pEntry(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyResult = pwr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pSymbol$bar(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pwr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = 
                      pExpression$GeneratorClauseList(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<GeneratorClause> a4 = yyResult.semanticValue();

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pRightEncloser(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Op a5 = yyResult.semanticValue();

                          Span span = createSpan(yyStart,yyCount);
                          Op opr = NodeFactory.makeEnclosing(span, "BIG " + a1.getText() + "|->",
                          "BIG " + a5.getText());
                          if (a2 == null) a2 = Collections.<StaticArg>emptyList();
                          yyValue = ExprFactory.makeAccumulator(span, a2, opr, a4, a3);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }

            // Nested alternative 2.

            yyResult = pExpression$Expr(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyResult = pwr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pSymbol$bar(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pwr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = 
                      pExpression$GeneratorClauseList(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<GeneratorClause> a4 = yyResult.semanticValue();

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pRightEncloser(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Op a5 = yyResult.semanticValue();

                          Span span = createSpan(yyStart,yyCount);
                          Op opr = NodeFactory.makeEnclosing(span, "BIG " + a1.getText(),
                          "BIG " + a5.getText());
                          if (a2 == null) a2 = Collections.<StaticArg>emptyList();
                          yyValue = ExprFactory.makeAccumulator(createSpan(yyStart,yyCount),
                          a2, opr, a4, a3);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } // End scope for a2.
      }
    } // End scope for nested choice.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.mapstoOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmapstoOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pmapstoOp$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if ('|' == yyC) {
        yyIndex = yyStart + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('>' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "|->";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    } else {
      yyError = yyError.select("mapsto op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("mapsto op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.mapstoOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmapstoOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pw(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyResult = pw(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pmapsto(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }

              // Nested alternative 2.

              yyResult = pwr(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pSymbol$bar(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }

              // Nested alternative 3.

              yyResult = pw(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                final int yyChoice2 = yyResult.index;

                // Nested alternative 1.

                yyResult = pclosecurly(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }

                // Nested alternative 2.

                yyResult = pcomma(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("mapsto op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.leftarrowOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftarrowOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pleftarrowOp$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if ('<' == yyC) {
        yyIndex = yyStart + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "<-";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    } else {
      yyError = yyError.select("leftarrow op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("leftarrow op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.leftarrowOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftarrowOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pw(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$Expr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pw(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice2 = yyResult.index;

              // Nested alternative 1.

              yyResult = pleftarrow(yyChoice2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = null;

                return yyResult.createValue(yyValue, yyError);
              }

              // Nested alternative 2.

              yyResult = pcomma(yyChoice2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = null;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("leftarrow op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Entry.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEntry(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fEntry) 
      yyColumn.chunk17.fEntry = pEntry$1(yyStart);
    return yyColumn.chunk17.fEntry;
  }

  /** Actually parse DelimitedExpr.Entry. */
  private Result pEntry$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmapsto(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = ExprFactory.makeTupleExpr(createSpan(yyStart,yyCount),
              a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.ArrayComprehensionLeft.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayComprehensionLeft(final int yyStart) 
    throws IOException {

    Result                                        yyResult;
    com.sun.fortress.useful.Pair<List<Expr>,Expr> yyValue;
    ParseError                                    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdOrInt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmapsto(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(Useful.list(a1),
              a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrInt(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pcomma(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pIdOrIntList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Expr> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pmapsto(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pExpression$Expr(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Expr a3 = yyResult.semanticValue();

                              List<Expr> exprs = Useful.list(a1);
                              for (Expr i : a2) exprs.add(i);
                              yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a3);

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }

            // Nested alternative 2.

            yyResult = pIdOrIntList(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Expr> a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pmapsto(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pExpression$Expr(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Expr a3 = yyResult.semanticValue();

                          log(NodeUtil.getSpan(a1), "Missing comma.");
                          List<Expr> exprs = Useful.list(a1);
                          for (Expr i : a2) exprs.add(i);
                          yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a3);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.IdOrInt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdOrInt(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fIdOrInt) 
      yyColumn.chunk18.fIdOrInt = pIdOrInt$1(yyStart);
    return yyColumn.chunk18.fIdOrInt;
  }

  /** Actually parse DelimitedExpr.IdOrInt. */
  private Result pIdOrInt$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIntLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.IdOrIntList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdOrIntList(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fIdOrIntList) 
      yyColumn.chunk18.fIdOrIntList = pIdOrIntList$1(yyStart);
    return yyColumn.chunk18.fIdOrIntList;
  }

  /** Actually parse DelimitedExpr.IdOrIntList. */
  private Result pIdOrIntList$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdOrInt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pIdOrIntList$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Expr> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pIdOrIntList$$Plus2(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Expr> a2s = yyResult.semanticValue();

        log(createSpan(yyStart,yyCount), "Missing comma.");
        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyValue = Useful.list(a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.IdOrIntList$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdOrIntList$$Plus1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fIdOrIntList$$Plus1) 
      yyColumn.chunk18.fIdOrIntList$$Plus1 = pIdOrIntList$$Plus1$1(yyStart);
    return yyColumn.chunk18.fIdOrIntList$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.IdOrIntList$$Plus1. */
  private Result pIdOrIntList$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIdOrInt(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr v$el$1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pIdOrIntList$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expr> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Expr>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<Expr>(v$el$1);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.IdOrIntList$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdOrIntList$$Plus2(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fIdOrIntList$$Plus2) 
      yyColumn.chunk18.fIdOrIntList$$Plus2 = pIdOrIntList$$Plus2$1(yyStart);
    return yyColumn.chunk18.fIdOrIntList$$Plus2;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.IdOrIntList$$Plus2. */
  private Result pIdOrIntList$$Plus2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSymbol$commaOrNot(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIdOrInt(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr v$el$3 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pIdOrIntList$$Plus2(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expr> v$4 = yyResult.semanticValue();

              yyValue = new Pair<Expr>(v$el$3, v$4);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<Expr>(v$el$3);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.ExprList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprList(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fExprList) 
      yyColumn.chunk18.fExprList = pExprList$1(yyStart);
    return yyColumn.chunk18.fExprList;
  }

  /** Actually parse DelimitedExpr.ExprList. */
  private Result pExprList$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pExprList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Expr> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ExprList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprList$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fExprList$$Star1) 
      yyColumn.chunk18.fExprList$$Star1 = pExprList$$Star1$1(yyStart);
    return yyColumn.chunk18.fExprList$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.ExprList$$Star1. */
  private Result pExprList$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$Expr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr v$el$1 = yyResult.semanticValue();

            yyResult = pExprList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expr> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Expr>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.EntryList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEntryList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Expr> yyRepValue1;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEntry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEntry(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Expr>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Expr> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$Expr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fNoNewlineExpr$Expr) 
      yyColumn.chunk18.fNoNewlineExpr$Expr = pNoNewlineExpr$Expr$1(yyStart);
    return yyColumn.chunk18.fNoNewlineExpr$Expr;
  }

  /** Actually parse NoNewlineExpr.Expr. */
  private Result pNoNewlineExpr$Expr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$Expr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> list = yyResult.semanticValue();

        yyValue = (Expr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineExpr.Expr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$Expr$$Star1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fNoNewlineExpr$Expr$$Star1) 
      yyColumn.chunk18.fNoNewlineExpr$Expr$$Star1 = pNoNewlineExpr$Expr$$Star1$1(yyStart);
    return yyColumn.chunk18.fNoNewlineExpr$Expr$$Star1;
  }

  /** Actually parse NoNewlineExpr.Expr$$Star1. */
  private Result pNoNewlineExpr$Expr$$Star1$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    Pair<Action<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$ExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expr> v$el$1 = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$Expr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.ExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$ExprFront(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <AssignExpr>.

    yyResult = pNoNewlineAssignExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Flow>.

    yyResult = pNoNewlineExpr$FlowExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pLooseJuxtGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pFnExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pfn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pBindId(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Type> v$el$8 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$8;
            }
          }
          { // Start scope for a2.
            List<Type> a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pmatch(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pNoNewlineExpr$Expr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr a3 = yyResult.semanticValue();

                    yyValue = ExprFactory.makeFnExpr(createSpan(yyStart,yyCount),
                    Useful.list(NodeFactory.makeParam(a1)),
                    Option.<Type>none(),
                    Option.<List<Type>>wrap(a2), a3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = popenparen(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pParameter$Params(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Param> v$el$9 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$9;
            }
          }
          { // Start scope for a1.
            List<Param> a1 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pIsType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Type v$el$10 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$10;
                  }
                }
                { // Start scope for a2.
                  Type a2 = cast(yyOpValue1);

                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pThrows(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<Type> v$el$11 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$11;
                    }
                  }
                  { // Start scope for a3.
                    List<Type> a3 = cast(yyOpValue1);

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pmatch(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pNoNewlineExpr$Expr(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            Expr a4 = yyResult.semanticValue();

                            if (a1 == null) a1 = Collections.<Param>emptyList();
                            yyValue = ExprFactory.makeFnExpr(createSpan(yyStart,yyCount), a1,
                            Option.<Type>wrap(a2),
                            Option.<List<Type>>wrap(a3), a4);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      }
                    }
                  } // End scope for a3.
                } // End scope for a2.
              }
            }
          } // End scope for a1.
        }

        // Nested alternative 3.

        yyResult = pParameter$ValParam(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIsType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }
          }


          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }
          }

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyResult = pmatch(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineExpr$Expr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  Span span = createSpan(yyStart,yyCount);
                  log(span, "Parentheses are required around the parameter of an anonymous function expression.");
                  yyValue = ExprFactory.makeVoidLiteralExpr(span);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }

            // Nested alternative 2.

            yyResult = pNoNewlineExpr$Expr(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount);
              log(span, "Anonymous function expression is missing \"=>\".");
              yyValue = ExprFactory.makeVoidLiteralExpr(span);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.ExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$ExprTail(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pDoubleStar(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new Action<Expr>() {
          public Expr run(Expr base) {
            return new _EllipsesExpr(NodeFactory.makeExprInfo(createSpan(yyStart,yyCount)), base);
        }};

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = ptyped(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            final Type t = a1;
            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return ExprFactory.makeAsExpr(createSpan(yyStart,yyCount),
                (Expr)base, t);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyResult = pasif(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            final Type t = a1;
            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return ExprFactory.makeAsIfExpr(createSpan(yyStart,yyCount),
                (Expr)base, t);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.AssignExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$AssignExpr(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared36(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Lhs> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<FunctionalRef> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = ExprFactory.makeAssignment(createSpan(yyStart,yyCount),
              a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExpr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fNoNewlineExpr$OpExpr) 
      yyColumn.chunk18.fNoNewlineExpr$OpExpr = pNoNewlineExpr$OpExpr$1(yyStart);
    return yyColumn.chunk18.fNoNewlineExpr$OpExpr;
  }

  /** Actually parse NoNewlineExpr.OpExpr. */
  private Result pNoNewlineExpr$OpExpr$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <FIRST>.

    yyResult = pNoNewlineExpr$OpExprNoEnc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = Resolver.resolveOps(writer, span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = Resolver.resolveOps(writer, span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(NodeUtil.getSpan(a1), a1));
      yyValue = Resolver.resolveOps(writer, span, PureList.make(e));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprNoEnc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprNoEnc(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fNoNewlineExpr$OpExprNoEnc) 
      yyColumn.chunk18.fNoNewlineExpr$OpExprNoEnc = pNoNewlineExpr$OpExprNoEnc$1(yyStart);
    return yyColumn.chunk18.fNoNewlineExpr$OpExprNoEnc;
  }

  /** Actually parse NoNewlineExpr.OpExprNoEnc. */
  private Result pNoNewlineExpr$OpExprNoEnc$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative <FIRST>.

    yyResult = pNoNewlineExpr$OpExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      Op op = NodeFactory.makeOpUnknown(span, "^");
      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(span, op));
      yyValue = PureList.make(e);
      log(span, "^ is always an infix operator but used as a nofix operator.");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(NodeUtil.getSpan(a1), a1));
      yyValue = PureList.make(e);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.TightInfixRight.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$TightInfixRight(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue = PureList.make((PrecedenceOpExpr)new Right(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.LeftLooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$LeftLooseInfix(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fNoNewlineExpr$LeftLooseInfix) 
      yyColumn.chunk19.fNoNewlineExpr$LeftLooseInfix = pNoNewlineExpr$LeftLooseInfix$1(yyStart);
    return yyColumn.chunk19.fNoNewlineExpr$LeftLooseInfix;
  }

  /** Actually parse NoNewlineExpr.LeftLooseInfix. */
  private Result pNoNewlineExpr$LeftLooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pSpacing$sr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprLeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprLeftEncloser(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fNoNewlineExpr$OpExprLeftEncloser) 
      yyColumn.chunk19.fNoNewlineExpr$OpExprLeftEncloser = pNoNewlineExpr$OpExprLeftEncloser$1(yyStart);
    return yyColumn.chunk19.fNoNewlineExpr$OpExprLeftEncloser;
  }

  /** Actually parse NoNewlineExpr.OpExprLeftEncloser. */
  private Result pNoNewlineExpr$OpExprLeftEncloser$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$OpExprNoEnc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new Left(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprPrimary(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fNoNewlineExpr$OpExprPrimary) 
      yyColumn.chunk19.fNoNewlineExpr$OpExprPrimary = pNoNewlineExpr$OpExprPrimary$1(yyStart);
    return yyColumn.chunk19.fNoNewlineExpr$OpExprPrimary;
  }

  /** Actually parse NoNewlineExpr.OpExprPrimary. */
  private Result pNoNewlineExpr$OpExprPrimary$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared42(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<Expr> a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$TightInfixRight(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue = PureList.make((PrecedenceOpExpr)new RealExpr(ExprFactory.buildPrimary(a1)));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprPrefix(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fNoNewlineExpr$OpExprPrefix) 
      yyColumn.chunk19.fNoNewlineExpr$OpExprPrefix = pNoNewlineExpr$OpExprPrefix$1(yyStart);
    return yyColumn.chunk19.fNoNewlineExpr$OpExprPrefix;
  }

  /** Actually parse NoNewlineExpr.OpExprPrefix. */
  private Result pNoNewlineExpr$OpExprPrefix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(op));
          log(span, "^ is always an infix operator but used as a prefix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(op));
          log(span, "^ is always an infix operator but used as a prefix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(op));
          log(span, "^ is always an infix operator but used as a prefix operator.");

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(op));
          log(span, "^ is always an infix operator but used as a postfix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(op));
          log(span, "^ is always an infix operator but used as a postfix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(op));
          log(span, "^ is always an infix operator but used as a postfix operator.");

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      Span span = createSpan(yyStart,yyCount);
      Op op = NodeFactory.makeOpUnknown(span, "^");
      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(op));
      log(span, "^ is always an infix operator but used as a postfix operator.");

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 3.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.LooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$LooseInfix(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fNoNewlineExpr$LooseInfix) 
      yyColumn.chunk19.fNoNewlineExpr$LooseInfix = pNoNewlineExpr$LooseInfix$1(yyStart);
    return yyColumn.chunk19.fNoNewlineExpr$LooseInfix;
  }

  /** Actually parse NoNewlineExpr.LooseInfix. */
  private Result pNoNewlineExpr$LooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.FlowExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$FlowExpr(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pwith(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr$Expr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = cast(yyOpValue1);

          Option<Id> name = (a1 == null) ? Option.<Id>none() : Option.<Id>some(a1);
          yyValue = ExprFactory.makeExit(createSpan(yyStart,yyCount),
          Option.<Type>none(), name,
          Option.<Expr>wrap(a2));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pAccumulator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a2.
        List<StaticArg> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$opensquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr$GeneratorClauseList(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<GeneratorClause> v$el$4 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared7(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                }
              }
            }
          }
        }
        { // Start scope for a3.
          List<GeneratorClause> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a4 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              if (a2 == null) a2 = Collections.<StaticArg>emptyList();
              if (a3 == null)
              yyValue = ExprFactory.makeOpExpr(span, a1, a4, a2);
              else
              yyValue = ExprFactory.makeAccumulator(span, a2, a1, a3, a4);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 3.

    yyResult = pBIG(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pLeftEncloser(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a1 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = pw(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pmapsto(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pStaticArgs(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<StaticArg> v$el$5 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$5;
                }
              }
              { // Start scope for a2.
                List<StaticArg> a2 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pRightEncloser(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Op a3 = yyResult.semanticValue();

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pNoNewlineExpr$Expr(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Expr a4 = yyResult.semanticValue();

                        Span span = createSpan(yyStart,yyCount);
                        if (a2 == null) a2 = Collections.<StaticArg>emptyList();
                        Op opr = NodeFactory.makeEnclosing(span, "BIG " + a1.getText() + "|->",
                        "BIG " + a3.getText());
                        yyValue = ExprFactory.makeOpExpr(span, opr, a4, a2);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              } // End scope for a2.
            }
          }

          // Nested alternative 2.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticArgs(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticArg> v$el$6 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$6;
            }
          }
          { // Start scope for a2.
            List<StaticArg> a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pRightEncloser(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Op a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pNoNewlineExpr$Expr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr a4 = yyResult.semanticValue();

                    Span span = createSpan(yyStart,yyCount);
                    if (a2 == null) a2 = Collections.<StaticArg>emptyList();
                    Op opr = NodeFactory.makeEnclosing(span, "BIG " + a1.getText(),
                    "BIG " + a3.getText());
                    yyValue = ExprFactory.makeOpExpr(span, opr, a4, a2);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Alternative 4.

    yyResult = patomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = ExprFactory.makeAtomicExpr(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = ptryatomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = ExprFactory.makeTryAtomicExpr(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pspawn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = ExprFactory.makeSpawn(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 7.

    yyResult = pthrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = ExprFactory.makeThrow(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.AtomicBack.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$AtomicBack(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fNoNewlineExpr$AtomicBack) 
      yyColumn.chunk19.fNoNewlineExpr$AtomicBack = pNoNewlineExpr$AtomicBack$1(yyStart);
    return yyColumn.chunk19.fNoNewlineExpr$AtomicBack;
  }

  /** Actually parse NoNewlineExpr.AtomicBack. */
  private Result pNoNewlineExpr$AtomicBack$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$AssignExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.GeneratorClauseList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$GeneratorClauseList(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fNoNewlineExpr$GeneratorClauseList) 
      yyColumn.chunk19.fNoNewlineExpr$GeneratorClauseList = pNoNewlineExpr$GeneratorClauseList$1(yyStart);
    return yyColumn.chunk19.fNoNewlineExpr$GeneratorClauseList;
  }

  /** Actually parse NoNewlineExpr.GeneratorClauseList. */
  private Result pNoNewlineExpr$GeneratorClauseList$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    List<GeneratorClause> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$GeneratorBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      GeneratorClause a1 = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$GeneratorClauseList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<GeneratorClause> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineExpr.GeneratorClauseList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$GeneratorClauseList$$Star1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fNoNewlineExpr$GeneratorClauseList$$Star1) 
      yyColumn.chunk19.fNoNewlineExpr$GeneratorClauseList$$Star1 = pNoNewlineExpr$GeneratorClauseList$$Star1$1(yyStart);
    return yyColumn.chunk19.fNoNewlineExpr$GeneratorClauseList$$Star1;
  }

  /** Actually parse NoNewlineExpr.GeneratorClauseList$$Star1. */
  private Result pNoNewlineExpr$GeneratorClauseList$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<GeneratorClause> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineExpr$GeneratorClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            GeneratorClause v$el$1 = yyResult.semanticValue();

            yyResult = 
              pNoNewlineExpr$GeneratorClauseList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<GeneratorClause> v$2 = yyResult.semanticValue();

              yyValue = new Pair<GeneratorClause>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.GeneratorBinding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$GeneratorBinding(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fNoNewlineExpr$GeneratorBinding) 
      yyColumn.chunk19.fNoNewlineExpr$GeneratorBinding = pNoNewlineExpr$GeneratorBinding$1(yyStart);
    return yyColumn.chunk19.fNoNewlineExpr$GeneratorBinding;
  }

  /** Actually parse NoNewlineExpr.GeneratorBinding. */
  private Result pNoNewlineExpr$GeneratorBinding$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    GeneratorClause yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindIdOrBindIdTuple(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Id> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pleftarrow(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = ExprFactory.makeGeneratorClause(createSpan(yyStart,yyCount),
              a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.GeneratorClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$GeneratorClause(final int yyStart) 
    throws IOException {

    Result          yyResult;
    GeneratorClause yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$GeneratorBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeGeneratorClause(NodeUtil.getSpan(a1),
      Collections.<Id>emptyList(), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fNoNewlineExpr) 
      yyColumn.chunk19.fNoNewlineExpr = pNoNewlineExpr$1(yyStart);
    return yyColumn.chunk19.fNoNewlineExpr;
  }

  /** Actually parse NoNewlineExpr.NoNewlineExpr. */
  private Result pNoNewlineExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineAssignExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineAssignExpr(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared36(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Lhs> a1 = yyResult.semanticValue();

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<FunctionalRef> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = ExprFactory.makeAssignment(createSpan(yyStart,yyCount),
              a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineVarWTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineVarWTypes(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fNoNewlineVarWTypes) 
      yyColumn.chunk20.fNoNewlineVarWTypes = pNoNewlineVarWTypes$1(yyStart);
    return yyColumn.chunk20.fNoNewlineVarWTypes;
  }

  /** Actually parse NoNewlineExpr.NoNewlineVarWTypes. */
  private Result pNoNewlineVarWTypes$1(final int yyStart) throws IOException {
    Result       yyResult;
    List<LValue> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineVarWType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LValue a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineVarWType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LValue a1 = yyResult.semanticValue();

          yyResult = pNoNewlineVarWTypes$$Plus1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<LValue> a2s = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.NoNewlineVarWTypes$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineVarWTypes$$Plus1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fNoNewlineVarWTypes$$Plus1) 
      yyColumn.chunk20.fNoNewlineVarWTypes$$Plus1 = pNoNewlineVarWTypes$$Plus1$1(yyStart);
    return yyColumn.chunk20.fNoNewlineVarWTypes$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.NoNewlineVarWTypes$$Plus1. */
  private Result pNoNewlineVarWTypes$$Plus1$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Pair<LValue> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineVarWType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            LValue v$el$1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pNoNewlineVarWTypes$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<LValue> v$2 = yyResult.semanticValue();

              yyValue = new Pair<LValue>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<LValue>(v$el$1);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineVarWType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineVarWType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fNoNewlineVarWType) 
      yyColumn.chunk20.fNoNewlineVarWType = pNoNewlineVarWType$1(yyStart);
    return yyColumn.chunk20.fNoNewlineVarWType;
  }

  /** Actually parse NoNewlineExpr.NoNewlineVarWType. */
  private Result pNoNewlineVarWType$1(final int yyStart) throws IOException {
    Result     yyResult;
    LValue     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineIsType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a2 = yyResult.semanticValue();

          yyValue = NodeFactory.makeLValue(createSpan(yyStart,yyCount),a1,a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineIsType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineIsType(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$colon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineIsTypeOrZilch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineIsTypeOrZilch(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$colon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineTypeOrZilch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineTypeOrZilch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineTypeOrZilch(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pZilch(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = NodeFactory.makeBottomType(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$Expr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fNoSpaceExpr$Expr) 
      yyColumn.chunk20.fNoSpaceExpr$Expr = pNoSpaceExpr$Expr$1(yyStart);
    return yyColumn.chunk20.fNoSpaceExpr$Expr;
  }

  /** Actually parse NoSpaceExpr.Expr. */
  private Result pNoSpaceExpr$Expr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = p$$Shared53(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> list = yyResult.semanticValue();

        yyValue = (Expr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.ExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$ExprFront(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fNoSpaceExpr$ExprFront) 
      yyColumn.chunk20.fNoSpaceExpr$ExprFront = pNoSpaceExpr$ExprFront$1(yyStart);
    return yyColumn.chunk20.fNoSpaceExpr$ExprFront;
  }

  /** Actually parse NoSpaceExpr.ExprFront. */
  private Result pNoSpaceExpr$ExprFront$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <AssignExpr>.

    yyResult = pNoSpaceExpr$AssignExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoSpaceExpr$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pLooseJuxtGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pFnExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pfn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$ValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIsType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }
          }


          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }
          }

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pmatch(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoSpaceExpr$Expr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  Span span = createSpan(yyStart,yyCount);
                  log(span, "Parentheses are required around the parameter of an anonymous function expression.");
                  yyValue = ExprFactory.makeVoidLiteralExpr(span);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }

            // Nested alternative 2.

            yyResult = pNoSpaceExpr$Expr(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount);
              log(span, "Anonymous function expression is missing \"=>\".");
              yyValue = ExprFactory.makeVoidLiteralExpr(span);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.AssignExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$AssignExpr(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared36(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Lhs> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<FunctionalRef> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoSpaceExpr$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = ExprFactory.makeAssignment(createSpan(yyStart,yyCount),
              a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExpr(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$OpExprNoEnc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = Resolver.resolveOpsNoSpace(writer, span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoSpaceExpr$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = Resolver.resolveOpsNoSpace(writer, span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(NodeUtil.getSpan(a1), a1));
      yyValue = Resolver.resolveOpsNoSpace(writer, span, PureList.make(e));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprNoEnc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprNoEnc(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fNoSpaceExpr$OpExprNoEnc) 
      yyColumn.chunk20.fNoSpaceExpr$OpExprNoEnc = pNoSpaceExpr$OpExprNoEnc$1(yyStart);
    return yyColumn.chunk20.fNoSpaceExpr$OpExprNoEnc;
  }

  /** Actually parse NoSpaceExpr.OpExprNoEnc. */
  private Result pNoSpaceExpr$OpExprNoEnc$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative <FIRST>.

    yyResult = pNoSpaceExpr$OpExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoSpaceExpr$OpExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      Op op = NodeFactory.makeOpUnknown(span, "^");
      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(span, op));
      yyValue = PureList.make(e);
      log(span, "^ is always an infix operator but used as a nofix operator.");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(NodeUtil.getSpan(a1), a1));
      yyValue = PureList.make(e);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.TightInfixRight.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$TightInfixRight(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyValue = PureList.make((PrecedenceOpExpr)new Right(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprLeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprLeftEncloser(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fNoSpaceExpr$OpExprLeftEncloser) 
      yyColumn.chunk20.fNoSpaceExpr$OpExprLeftEncloser = pNoSpaceExpr$OpExprLeftEncloser$1(yyStart);
    return yyColumn.chunk20.fNoSpaceExpr$OpExprLeftEncloser;
  }

  /** Actually parse NoSpaceExpr.OpExprLeftEncloser. */
  private Result pNoSpaceExpr$OpExprLeftEncloser$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pNoSpaceExpr$OpExprNoEnc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new Left(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprPrimary(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fNoSpaceExpr$OpExprPrimary) 
      yyColumn.chunk20.fNoSpaceExpr$OpExprPrimary = pNoSpaceExpr$OpExprPrimary$1(yyStart);
    return yyColumn.chunk20.fNoSpaceExpr$OpExprPrimary;
  }

  /** Actually parse NoSpaceExpr.OpExprPrimary. */
  private Result pNoSpaceExpr$OpExprPrimary$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared42(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<Expr> a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$TightInfixRight(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyValue = PureList.make((PrecedenceOpExpr)new RealExpr(ExprFactory.buildPrimary(a1)));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprPrefix(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fNoSpaceExpr$OpExprPrefix) 
      yyColumn.chunk20.fNoSpaceExpr$OpExprPrefix = pNoSpaceExpr$OpExprPrefix$1(yyStart);
    return yyColumn.chunk20.fNoSpaceExpr$OpExprPrefix;
  }

  /** Actually parse NoSpaceExpr.OpExprPrefix. */
  private Result pNoSpaceExpr$OpExprPrefix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoSpaceExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoSpaceExpr$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(op));
          log(span, "^ is always an infix operator but used as a prefix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoSpaceExpr$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(op));
          log(span, "^ is always an infix operator but used as a prefix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoSpaceExpr$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(op));
          log(span, "^ is always an infix operator but used as a prefix operator.");

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoSpaceExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoSpaceExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(op));
          log(span, "^ is always an infix operator but used as a postfix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoSpaceExpr$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(op));
          log(span, "^ is always an infix operator but used as a postfix operator.");

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoSpaceExpr$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          Op op = NodeFactory.makeOpUnknown(span, "^");
          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(op));
          log(span, "^ is always an infix operator but used as a postfix operator.");

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      Span span = createSpan(yyStart,yyCount);
      Op op = NodeFactory.makeOpUnknown(span, "^");
      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(op));
      log(span, "^ is always an infix operator but used as a postfix operator.");

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 3.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.NoSpaceExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fNoSpaceExpr) 
      yyColumn.chunk20.fNoSpaceExpr = pNoSpaceExpr$1(yyStart);
    return yyColumn.chunk20.fNoSpaceExpr;
  }

  /** Actually parse NoSpaceExpr.NoSpaceExpr. */
  private Result pNoSpaceExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.LiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteralExpr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fLiteralExpr) 
      yyColumn.chunk21.fLiteralExpr = pLiteralExpr$1(yyStart);
    return yyColumn.chunk21.fLiteralExpr;
  }

  /** Actually parse Literal.LiteralExpr. */
  private Result pLiteralExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLooseJuxtGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pSimpleExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pPrimaryGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pLiteralExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <VOID>.

    yyResult = pVoidLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <NUMERICAL>.

    yyResult = pNumericLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <CHAR>.

    yyResult = pCharLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <STRING>.

    yyResult = pStringLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <BOOLEAN>.

    yyResult = pBooleanLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.VoidLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVoidLiteralExpr(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVoidLiteralExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <FIRST>.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = ExprFactory.makeVoidLiteralExpr(createSpan(yyStart,yyCount));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.BooleanLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBooleanLiteralExpr(final int yyStart) throws IOException {
    Result             yyResult;
    BooleanLiteralExpr yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBooleanLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String b = yyResult.semanticValue();

      yyValue = ExprFactory.makeBooleanLiteralExpr(createSpan(yyStart,yyCount),b.equals("true")?1:0);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.BooleanLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBooleanLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 't':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('r' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = "true";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("boolean literal expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('l' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('s' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = "false";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select("boolean literal expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("boolean literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.IntLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntLiteralExpr(final int yyStart) throws IOException {
    Result         yyResult;
    IntLiteralExpr yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNumberLiteralExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIntLiteralExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <FIRST>.

    yyResult = pNumericLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumberLiteralExpr a1 = yyResult.semanticValue();

      if ((a1 instanceof IntLiteralExpr)) {

        yyValue = (IntLiteralExpr)a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("int literal expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NumericLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumericLiteralExpr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fNumericLiteralExpr) 
      yyColumn.chunk21.fNumericLiteralExpr = pNumericLiteralExpr$1(yyStart);
    return yyColumn.chunk21.fNumericLiteralExpr;
  }

  /** Actually parse Literal.NumericLiteralExpr. */
  private Result pNumericLiteralExpr$1(final int yyStart) throws IOException {
    Result            yyResult;
    NumberLiteralExpr yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNumericLiteralWithRadix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNumericWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pNumericLiteralExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> a2s = yyResult.semanticValue();

        if (Character.isDigit(a1.charAt(0))) {

          String numeral;
          StringBuilder buf = new StringBuilder();
          buf.append(a1);
          for (String n: a2s.list()) buf.append(n);
          numeral = buf.toString();
          Span span = createSpan(yyStart,yyCount);
          if ( NodeUtil.validNumericLiteral(writer, span, numeral) ) {
            if ( NodeUtil.validIntLiteral(numeral) )
            yyValue = ExprFactory.makeIntLiteralExpr(span, numeral);
            else yyValue = ExprFactory.makeFloatLiteralExpr(span, numeral);
          }
          else yyValue = ExprFactory.makeIntLiteralExpr(span, "0");

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("numeric literal expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.NumericLiteralExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumericLiteralExpr$$Star1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fNumericLiteralExpr$$Star1) 
      yyColumn.chunk21.fNumericLiteralExpr$$Star1 = pNumericLiteralExpr$$Star1$1(yyStart);
    return yyColumn.chunk21.fNumericLiteralExpr$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.NumericLiteralExpr$$Star1. */
  private Result pNumericLiteralExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRestNumericWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$2 = yyResult.semanticValue();

      yyResult = pNumericLiteralExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$3 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NumericLiteralWithRadix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumericLiteralWithRadix(final int yyStart) 
    throws IOException {

    int               yyC;
    int               yyIndex;
    Result            yyResult;
    int               yyBase;
    int               yyRepetition1;
    Pair<String>      yyRepValue1;
    NumberLiteralExpr yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNumericWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pRestNumericWord(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<String> a2s = yyRepValue1.reverse();

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if ('_' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pRadixSpecifier(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a3 = yyResult.semanticValue();

            String numeral;
            StringBuilder buf = new StringBuilder();
            buf.append(a1);
            for (String n: a2s.list()) buf.append(n);
            numeral = buf.toString();
            Span span = createSpan(yyStart,yyCount);
            if ( NodeUtil.validNumericLiteral(writer, span, numeral, a3) ) {
              numeral += "_"+NodeUtil.radix2Number(a3);
              if ( NodeUtil.validIntLiteral(numeral) )
              yyValue = ExprFactory.makeIntLiteralExpr(span, numeral);
              else yyValue = ExprFactory.makeFloatLiteralExpr(span, numeral);
            }
            else yyValue = ExprFactory.makeIntLiteralExpr(span, "0");

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("\"_\" expected", yyBase);
        }
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NumericWord.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumericWord(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    boolean      yyRepeated1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pNumericCharacter(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<String> a1s = yyRepValue1.reverse();

      yyValue = "";
      StringBuilder buf = new StringBuilder();
      for (String n: a1s.list()) buf.append(n);
      yyValue = buf.toString();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NumericCharacter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumericCharacter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("numeric character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RestNumericWord.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRestNumericWord(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNumericSeparator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pNumericWord(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NumericSeparator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumericSeparator(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\'':
        {
          yyValue = "\'";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u202f':
        {
          yyValue = "\u202f";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = ".";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("numeric separator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RadixSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRadixSpecifier(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDigitString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if (-1 != yyC) {
        if ((('A' <= yyC) && (yyC <= 'Z')) ||
            (('a' <= yyC) && (yyC <= 'z'))) {

          yyPredMatched = true;
        }
      }

      if (! yyPredMatched) {

        if (NodeUtil.validRadix(writer, createSpan(yyStart,yyCount), a1)) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("radix specifier expected", yyStart);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'S':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'I':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('X' == yyC) {

                    final int yyChoice1 = yyIndex;

                    // Nested alternative 1.

                    yyC = character(yyChoice1);
                    if (-1 != yyC) {
                      yyIndex = yyChoice1 + 1;
                      if ('T' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('E' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('E' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('N' == yyC) {

                                    yyValue = "SIXTEEN";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }

                    // Nested alternative 2.

                    yyValue = "SIX";

                    return new SemanticValue(yyValue, yyChoice1, yyError);
                  }
                }
              }
              break;

            case 'E':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('V' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('E' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('N' == yyC) {

                            yyValue = "SEVEN";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'F':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'I':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'F':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('T' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('E' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('E' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('N' == yyC) {

                                      yyValue = "FIFTEEN";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'V':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('E' == yyC) {

                          yyValue = "FIVE";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'O':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('U' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('R' == yyC) {

                        final int yyChoice1 = yyIndex;

                        // Nested alternative 1.

                        yyC = character(yyChoice1);
                        if (-1 != yyC) {
                          yyIndex = yyChoice1 + 1;
                          if ('T' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('E' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('E' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('N' == yyC) {

                                        yyValue = "FOURTEEN";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }

                        // Nested alternative 2.

                        yyValue = "FOUR";

                        return new SemanticValue(yyValue, yyChoice1, yyError);
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'T':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'H':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'I':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('R' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('T' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('E' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('E' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('N' == yyC) {

                                          yyValue = "THIRTEEN";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'R':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('E' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('E' == yyC) {

                              yyValue = "THREE";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'W':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'E':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('L' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('V' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('E' == yyC) {

                                  yyValue = "TWELVE";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'O':
                    {
                      yyValue = "TWO";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'E':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('N' == yyC) {

                    yyValue = "TEN";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'E':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'L':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('E' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('V' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('E' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('N' == yyC) {

                                yyValue = "ELEVEN";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'I':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('G' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('H' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('T' == yyC) {

                            yyValue = "EIGHT";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'N':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('I' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('N' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('E' == yyC) {

                      yyValue = "NINE";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("radix specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.DigitString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDigitString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("digit string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.CharLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharLiteralExpr(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    Result          yyResult;
    int             yyBase;
    CharLiteralExpr yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCharLiteralExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\'':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pCharLiteralContent(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a1 = yyResult.semanticValue();

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyBase = yyChoice2;
            yyC    = character(yyBase);
            if ('\'' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyValue = ExprFactory.makeCharLiteralExpr(createSpan(yyStart,yyCount), a1);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"\\\'\" expected", yyBase);
            }

            // Nested alternative 2.

            yyBase = yyChoice2;
            yyC    = character(yyBase);
            if ('\u2019' == yyC) {
              yyIndex = yyChoice2 + 1;

              Span span = createSpan(yyStart,yyCount);
              log(span, "The opening and closing marks of a character literal must match.");
              yyValue = ExprFactory.makeCharLiteralExpr(span, "");

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"\\u2019\" expected", yyBase);
            }
          }
        }
        break;

      case '`':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pCharLiteralContent(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a1 = yyResult.semanticValue();

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyBase = yyChoice2;
            yyC    = character(yyBase);
            if ('\'' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyValue = ExprFactory.makeCharLiteralExpr(createSpan(yyStart,yyCount), a1);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"\\\'\" expected", yyBase);
            }

            // Nested alternative 2.

            yyBase = yyChoice2;
            yyC    = character(yyBase);
            if ('\u2019' == yyC) {
              yyIndex = yyChoice2 + 1;

              Span span = createSpan(yyStart,yyCount);
              log(span, "The opening and closing marks of a character literal must match.");
              yyValue = ExprFactory.makeCharLiteralExpr(span, "");

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"\\u2019\" expected", yyBase);
            }
          }
        }
        break;

      case '\u2018':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pCharLiteralContent(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a1 = yyResult.semanticValue();

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyBase = yyChoice2;
            yyC    = character(yyBase);
            if ('\u2019' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyValue = ExprFactory.makeCharLiteralExpr(createSpan(yyStart,yyCount), a1);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"\\u2019\" expected", yyBase);
            }

            // Nested alternative 2.

            yyBase = yyChoice2;
            yyC    = character(yyBase);
            if ('\'' == yyC) {
              yyIndex = yyChoice2 + 1;

              Span span = createSpan(yyStart,yyCount);
              log(span, "The opening and closing marks of a character literal must match.");
              yyValue = ExprFactory.makeCharLiteralExpr(span, "");

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"\\\'\" expected", yyBase);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("char literal expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.StringLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralExpr(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fStringLiteralExpr) 
      yyColumn.chunk21.fStringLiteralExpr = pStringLiteralExpr$1(yyStart);
    return yyColumn.chunk21.fStringLiteralExpr;
  }

  /** Actually parse Literal.StringLiteralExpr. */
  private Result pStringLiteralExpr$1(final int yyStart) throws IOException {
    int               yyC;
    int               yyIndex;
    Result            yyResult;
    int               yyBase;
    StringLiteralExpr yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringLiteralExprGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pStringLiteralExpr$$Star1(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<String> a1 = yyResult.semanticValue();

            yyC = character(yyResult.index);
            if ('\"' == yyC) {
              yyIndex = yyResult.index + 1;

              String str = "";
              for (String c : (List<String>)a1.list()) str = str.concat(c);
              yyValue = ExprFactory.makeStringLiteralExpr(createSpan(yyStart,yyCount), str);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyResult = pStringLiteralExpr$$Star3(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<String> a1 = yyResult.semanticValue();

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('\u201d' == yyC) {
              yyIndex = yyResult.index + 1;

              Span span = createSpan(yyStart,yyCount);
              log(span, "The opening and closing marks of a string literal must match.");
              yyValue = ExprFactory.makeStringLiteralExpr(span, "");

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"\\u201d\" expected", yyBase);
            }
          }
        }
        break;

      case '\u201c':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pStringLiteralExpr$$Star2(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<String> a1 = yyResult.semanticValue();

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('\u201d' == yyC) {
              yyIndex = yyResult.index + 1;

              String str = "";
              for (String c : (List<String>)a1.list()) str = str.concat(c);
              yyValue = ExprFactory.makeStringLiteralExpr(createSpan(yyStart,yyCount), str);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"\\u201d\" expected", yyBase);
            }
          }

          // Nested alternative 2.

          yyResult = pStringLiteralExpr$$Star4(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<String> a1 = yyResult.semanticValue();

            yyC = character(yyResult.index);
            if ('\"' == yyC) {
              yyIndex = yyResult.index + 1;

              Span span = createSpan(yyStart,yyCount);
              log(span, "The opening and closing marks of a string literal must match.");
              yyValue = ExprFactory.makeStringLiteralExpr(span, "");

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("string literal expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.StringLiteralExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralExpr$$Star1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fStringLiteralExpr$$Star1) 
      yyColumn.chunk21.fStringLiteralExpr$$Star1 = pStringLiteralExpr$$Star1$1(yyStart);
    return yyColumn.chunk21.fStringLiteralExpr$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.StringLiteralExpr$$Star1. */
  private Result pStringLiteralExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringLiteralContent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$2 = yyResult.semanticValue();

      yyResult = pStringLiteralExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$3 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.StringLiteralExpr$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralExpr$$Star2(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fStringLiteralExpr$$Star2) 
      yyColumn.chunk21.fStringLiteralExpr$$Star2 = pStringLiteralExpr$$Star2$1(yyStart);
    return yyColumn.chunk21.fStringLiteralExpr$$Star2;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.StringLiteralExpr$$Star2. */
  private Result pStringLiteralExpr$$Star2$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringLiteralContent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$4 = yyResult.semanticValue();

      yyResult = pStringLiteralExpr$$Star2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$5 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$4, v$5);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.StringLiteralExpr$$Star3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralExpr$$Star3(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fStringLiteralExpr$$Star3) 
      yyColumn.chunk21.fStringLiteralExpr$$Star3 = pStringLiteralExpr$$Star3$1(yyStart);
    return yyColumn.chunk21.fStringLiteralExpr$$Star3;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.StringLiteralExpr$$Star3. */
  private Result pStringLiteralExpr$$Star3$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringLiteralContent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$6 = yyResult.semanticValue();

      yyResult = pStringLiteralExpr$$Star3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$7 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$6, v$7);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.StringLiteralExpr$$Star4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralExpr$$Star4(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fStringLiteralExpr$$Star4) 
      yyColumn.chunk21.fStringLiteralExpr$$Star4 = pStringLiteralExpr$$Star4$1(yyStart);
    return yyColumn.chunk21.fStringLiteralExpr$$Star4;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.StringLiteralExpr$$Star4. */
  private Result pStringLiteralExpr$$Star4$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringLiteralContent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$8 = yyResult.semanticValue();

      yyResult = pStringLiteralExpr$$Star4(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$9 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$8, v$9);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.StringLiteralContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralContent(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fStringLiteralContent) 
      yyColumn.chunk21.fStringLiteralContent = pStringLiteralContent$1(yyStart);
    return yyColumn.chunk21.fStringLiteralContent;
  }

  /** Actually parse Literal.StringLiteralContent. */
  private Result pStringLiteralContent$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEscapeSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pStringLiteralContent$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = String.valueOf(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.StringLiteralContent$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralContent$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pInvalidStringLiteralContent(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("string literal content expected", yyStart);
    }

    // Done.
    yyError = yyError.select("string literal content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.InvalidStringLiteralContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInvalidStringLiteralContent(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('\"' == yyC) ||
          (('\u201c' <= yyC) && (yyC <= '\u201d'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      log(createSpan(yyStart,yyCount), "Invalid string literal content: " + a1);

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if ((('\t' <= a1) && (a1 <= '\r')) ||
          (('\u001c' <= a1) && (a1 <= '\u001f')) ||
          (('\u2028' <= a1) && (a1 <= '\u2029'))) {

        log(createSpan(yyStart,yyCount), "Invalid string literal content: " + a1);

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (Character.getType(c) == Character.CONTROL) {

        log(createSpan(yyStart,yyCount), "Invalid string literal content: " + c);

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("invalid string literal content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.EscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeSequence(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fEscapeSequence) 
      yyColumn.chunk21.fEscapeSequence = pEscapeSequence$1(yyStart);
    return yyColumn.chunk21.fEscapeSequence;
  }

  /** Actually parse Literal.EscapeSequence. */
  private Result pEscapeSequence$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;
        char a1 = (char)yyC;

        if (('\"' == a1) ||
            ('\\' == a1) ||
            ('b' == a1) ||
            ('f' == a1) ||
            ('n' == a1) ||
            ('r' == a1) ||
            ('t' == a1)) {

          switch (a1) {
            case 'b': { yyValue = "\b"; break; }
            case 't': { yyValue = "\t"; break; }
            case 'n': { yyValue = "\n"; break; }
            case 'f': { yyValue = "\f"; break; }
            case 'r': { yyValue = "\r"; break; }
            case '"': { yyValue = "\""; break; }
            case '\\': { yyValue = "\\"; break; }
            default: { yyValue = ""; }
          }

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\u201c':
          {
            yyValue = "\u201c";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case '\u201d':
          {
            yyValue = "\u201d";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.CharLiteralContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharLiteralContent(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fCharLiteralContent) 
      yyColumn.chunk22.fCharLiteralContent = pCharLiteralContent$1(yyStart);
    return yyColumn.chunk22.fCharLiteralContent;
  }

  /** Actually parse Literal.CharLiteralContent. */
  private Result pCharLiteralContent$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEscapeSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pUnicodeCharLiteralContent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'A':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'L':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'P':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('H' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('A' == yyC) {

                              yyValue = "\u0391";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'L':
                    {
                      yyValue = "\u22C0";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'P':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('P' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('R' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('O' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('X' == yyC) {

                                final int yyChoice1 = yyIndex;

                                // Nested alternative 1.

                                yyC = character(yyChoice1);
                                if (-1 != yyC) {
                                  yyIndex = yyChoice1 + 1;
                                  if ('E' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('Q' == yyC) {

                                        yyValue = "\u224A";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }

                                // Nested alternative 2.

                                yyValue = "\u2248";

                                return new SemanticValue(yyValue, yyChoice1, yyError);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'N':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'D':
                    {
                      yyValue = "\u2227";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  case 'Y':
                    {
                      yyValue = "\u22C1";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'B':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'E':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('T' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('A' == yyC) {

                        yyValue = "\u0392";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
              }
              break;

            case 'O':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'T':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('T' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('O' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('M' == yyC) {

                                  yyValue = "\u22A5";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'X':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case 'T':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('I' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('M' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('E' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('S' == yyC) {

                                            yyValue = "\u22A0";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'D':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('O' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('T' == yyC) {

                                    yyValue = "\u22A1";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'A':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('S' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('T' == yyC) {

                                    yyValue = "\u29C6";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'S':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('L' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('A' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('S' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('H' == yyC) {

                                            yyValue = "\u29C4";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'P':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('L' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('U' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('S' == yyC) {

                                        yyValue = "\u229E";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'M':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('I' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('N' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('U' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('S' == yyC) {

                                            yyValue = "\u229F";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'Y':
              {
                yyValue = "\u00D7";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'U':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'M':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('P' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('E' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('Q' == yyC) {

                                  final int yyChoice1 = yyIndex;

                                  // Nested alternative 1.

                                  yyC = character(yyChoice1);
                                  if (-1 != yyC) {
                                    yyIndex = yyChoice1 + 1;
                                    if ('V' == yyC) {

                                      yyValue = "\u224E";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }

                                  // Nested alternative 2.

                                  yyValue = "\u224F";

                                  return new SemanticValue(yyValue, yyChoice1, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'L':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('L' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('E' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('T' == yyC) {

                                  yyValue = "\u2219";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'I':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('G' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;

                      switch (yyC) {
                      case 'A':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('N' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('D' == yyC) {

                                  yyValue = "\u22C0";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                        break;

                      case 'O':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case 'R':
                              {
                                yyValue = "\u22C1";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }

                            case 'D':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('O' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('T' == yyC) {

                                        yyValue = "\u2A00";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'P':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('L' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('U' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('S' == yyC) {

                                            yyValue = "\u2A01";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'T':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('I' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('M' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('E' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('S' == yyC) {

                                                yyValue = "\u2A02";

                                                return new SemanticValue(yyValue, yyIndex, yyError);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                        break;

                      case 'C':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case 'A':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('P' == yyC) {

                                    yyValue = "\u22C2";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                              break;

                            case 'U':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('P' == yyC) {

                                    yyValue = "\u22C3";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                        break;

                      case 'I':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('N' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('T' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('E' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('R' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('S' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('E' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('C' == yyC) {

                                                      yyC = 
                                                        character(yyIndex);
                                                      if (-1 != yyC) {
                                                        yyIndex = yyIndex + 1;
                                                        if ('T' == yyC) {

                                                          yyValue = "\u22C2";

                                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        break;

                      case 'U':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case 'N':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('I' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('O' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('N' == yyC) {

                                            yyValue = "\u22C3";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'D':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('O' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('T' == yyC) {

                                        yyValue = "\u2A03";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'P':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('L' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('U' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('S' == yyC) {

                                            yyValue = "\u2A04";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                        break;

                      case 'S':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('Q' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('C' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;

                                    switch (yyC) {
                                    case 'A':
                                      {
                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('P' == yyC) {

                                            yyValue = "\u2A05";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                      break;

                                    case 'U':
                                      {
                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('P' == yyC) {

                                            yyValue = "\u2A06";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                      break;

                                    default:
                                      /* No match. */
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        break;

                      case 'T':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('I' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('M' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('E' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('S' == yyC) {

                                          yyValue = "\u2A09";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        break;

                      default:
                        /* No match. */
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'G':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'A':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('M' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('M' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('A' == yyC) {

                            yyValue = "\u0393";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'T':
              {
                yyValue = "\u003E";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'E':
              {
                yyValue = "\u2265";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'D':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'E':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'L':
                    {
                      final int yyChoice1 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice1);
                      if (-1 != yyC) {
                        yyIndex = yyChoice1 + 1;
                        if ('T' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('A' == yyC) {

                              yyValue = "\u0394";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }

                      // Nested alternative 2.

                      yyValue = "\u2202";

                      return new SemanticValue(yyValue, yyChoice1, yyError);
                    }

                  case 'G':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('R' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('E' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('E' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('S' == yyC) {

                                      yyValue = "\u00B0";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'O':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'T':
                    {
                      final int yyChoice1 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice1);
                      if (-1 != yyC) {
                        yyIndex = yyChoice1 + 1;

                        switch (yyC) {
                        case 'T':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('I' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('M' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('E' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('S' == yyC) {

                                            yyValue = "\u2A30";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'P':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('L' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('U' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('S' == yyC) {

                                        yyValue = "\u2214";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'M':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('I' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('N' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('U' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('S' == yyC) {

                                            yyValue = "\u2238";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'E':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('Q' == yyC) {

                                final int yyChoice2 = yyIndex;

                                // Nested alternative 1.

                                yyC = character(yyChoice2);
                                if (-1 != yyC) {
                                  yyIndex = yyChoice2 + 1;
                                  if ('D' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('O' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('T' == yyC) {

                                            yyValue = "\u2251";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }

                                // Nested alternative 2.

                                yyValue = "\u2250";

                                return new SemanticValue(yyValue, yyChoice2, yyError);
                              }
                            }
                          }
                          break;

                        case 'L':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('T' == yyC) {

                                yyValue = "\u22D6";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                          break;

                        case 'G':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('T' == yyC) {

                                yyValue = "\u22D7";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }

                      // Nested alternative 2.

                      yyValue = "\u00B7";

                      return new SemanticValue(yyValue, yyChoice1, yyError);
                    }

                  case 'W':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('N' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case 'A':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('R' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('R' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('O' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('W' == yyC) {

                                                yyValue = "\u2193";

                                                return new SemanticValue(yyValue, yyIndex, yyError);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'H':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('A' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('R' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('P' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('O' == yyC) {

                                                yyC = character(yyIndex);
                                                if (-1 != yyC) {
                                                  yyIndex = yyIndex + 1;
                                                  if ('O' == yyC) {

                                                    yyC = character(yyIndex);
                                                    if (-1 != yyC) {
                                                      yyIndex = yyIndex + 1;
                                                      if ('N' == yyC) {

                                                        yyC = 
                                                          character(yyIndex);
                                                        if (-1 != yyC) {
                                                          yyIndex = yyIndex + 1;

                                                          switch (yyC) {
                                                          case 'R':
                                                            {
                                                              yyC = 
                                                                character(yyIndex);
                                                              if (-1 != yyC) {
                                                                yyIndex = yyIndex + 1;
                                                                if ('I' == yyC) {

                                                                  yyC = 
                                                                    character(yyIndex);
                                                                  if (-1 != yyC) {
                                                                    yyIndex = yyIndex + 1;
                                                                    if ('G' == yyC) {

                                                                      yyC = 
                                                                        character(yyIndex);
                                                                      if (-1 != yyC) {
                                                                        yyIndex = yyIndex + 1;
                                                                        if ('H' == yyC) {

                                                                          yyC = 
                                                                            character(yyIndex);
                                                                          if (-1 != yyC) {
                                                                            yyIndex = yyIndex + 1;
                                                                            if ('T' == yyC) {

                                                                              yyValue = "\u21C2";

                                                                              return new SemanticValue(yyValue, yyIndex, yyError);
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                            break;

                                                          case 'L':
                                                            {
                                                              yyC = 
                                                                character(yyIndex);
                                                              if (-1 != yyC) {
                                                                yyIndex = yyIndex + 1;
                                                                if ('E' == yyC) {

                                                                  yyC = 
                                                                    character(yyIndex);
                                                                  if (-1 != yyC) {
                                                                    yyIndex = yyIndex + 1;
                                                                    if ('F' == yyC) {

                                                                      yyC = 
                                                                        character(yyIndex);
                                                                      if (-1 != yyC) {
                                                                        yyIndex = yyIndex + 1;
                                                                        if ('T' == yyC) {

                                                                          yyValue = "\u21C3";

                                                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                            break;

                                                          default:
                                                            /* No match. */
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'D':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('O' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('W' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('N' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('A' == yyC) {

                                                yyC = character(yyIndex);
                                                if (-1 != yyC) {
                                                  yyIndex = yyIndex + 1;
                                                  if ('R' == yyC) {

                                                    yyC = character(yyIndex);
                                                    if (-1 != yyC) {
                                                      yyIndex = yyIndex + 1;
                                                      if ('R' == yyC) {

                                                        yyC = 
                                                          character(yyIndex);
                                                        if (-1 != yyC) {
                                                          yyIndex = yyIndex + 1;
                                                          if ('O' == yyC) {

                                                            yyC = 
                                                              character(yyIndex);
                                                            if (-1 != yyC) {
                                                              yyIndex = yyIndex + 1;
                                                              if ('W' == yyC) {

                                                                yyC = 
                                                                  character(yyIndex);
                                                                if (-1 != yyC) {
                                                                  yyIndex = yyIndex + 1;
                                                                  if ('S' == yyC) {

                                                                    yyValue = "\u21CA";

                                                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'I':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'V':
                    {
                      final int yyChoice1 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice1);
                      if (-1 != yyC) {
                        yyIndex = yyChoice1 + 1;
                        if ('I' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('D' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('E' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('S' == yyC) {

                                      yyValue = "\u2223";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }

                      // Nested alternative 2.

                      yyValue = "\u00F7";

                      return new SemanticValue(yyValue, yyChoice1, yyError);
                    }

                  case 'A':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('M' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('O' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('N' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('D' == yyC) {

                                      yyValue = "\u22C4";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'A':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('S' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('H' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('V' == yyC) {

                            yyValue = "\u22A3";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'E':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'P':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('S' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('I' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('L' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('O' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('N' == yyC) {

                                    yyValue = "\u0395";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'T':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('A' == yyC) {

                    yyValue = "\u0397";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case 'X':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('I' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('S' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('T' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('S' == yyC) {

                                yyValue = "\u2203";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'Q':
              {
                final int yyChoice1 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice1);
                if (-1 != yyC) {
                  yyIndex = yyChoice1 + 1;

                  switch (yyC) {
                  case 'R':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('I' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('N' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('G' == yyC) {

                                  yyValue = "\u2256";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'D':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('E' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case 'L':
                              {
                                yyValue = "\u225C";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }

                            case 'F':
                              {
                                yyValue = "\u225D";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }

                            default:
                              /* No match. */
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'V':
                    {
                      yyValue = "\u2261";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  case 'U':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('I' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('V' == yyC) {

                              yyValue = "\u2261";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'P':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('R' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('E' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('C' == yyC) {

                                  yyValue = "\u22DE";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'S':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('U' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('C' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('C' == yyC) {

                                  yyValue = "\u22DF";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyValue = "\u003D";

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }

            case 'M':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('P' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('T' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('Y' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('S' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('E' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('T' == yyC) {

                                        yyValue = "\u2205";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'Z':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('E' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('T' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('A' == yyC) {

                      yyValue = "\u0396";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'T':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'H':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('E' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('T' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('A' == yyC) {

                            yyValue = "\u0398";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'A':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('U' == yyC) {

                    yyValue = "\u03A4";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case 'O':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('P' == yyC) {

                    yyValue = "\u22A4";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case 'I':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('M' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('E' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('S' == yyC) {

                            yyValue = "\u00D7";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'R':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('I' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;

                      switch (yyC) {
                      case 'T':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('I' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('M' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('E' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('S' == yyC) {

                                          yyValue = "\u2A3B";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        break;

                      case 'P':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('L' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('U' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('S' == yyC) {

                                      yyValue = "\u2A39";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        break;

                      case 'M':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('I' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('N' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('U' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('S' == yyC) {

                                          yyValue = "\u2A3A";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        break;

                      default:
                        /* No match. */
                      }
                    }
                  }
                }
              }
              break;

            case 'U':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('R' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('N' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('S' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('T' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('I' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('L' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('E' == yyC) {

                                            yyValue = "\u22A2";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'I':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'O':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('T' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('A' == yyC) {

                        yyValue = "\u0399";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
              }
              break;

            case 'N':
              {
                final int yyChoice1 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice1);
                if (-1 != yyC) {
                  yyIndex = yyChoice1 + 1;

                  switch (yyC) {
                  case 'F':
                    {
                      yyValue = "\u221E";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  case 'T':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('E' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case 'R':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('S' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('E' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('C' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('T' == yyC) {

                                                yyValue = "\u2229";

                                                return new SemanticValue(yyValue, yyIndex, yyError);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'G':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('R' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('A' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('L' == yyC) {

                                            yyValue = "\u222B";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyValue = "\u2208";

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }

            case 'M':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('P' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('L' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('I' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('E' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('S' == yyC) {

                                    yyValue = "\u2192";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'F':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('F' == yyC) {

                    yyValue = "\u2194";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'K':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('A' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('P' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('P' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('A' == yyC) {

                          yyValue = "\u039A";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'L':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'A':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'M':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('B' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('D' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('A' == yyC) {

                                  yyValue = "\u039B";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'R':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('G' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('E' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('R' == yyC) {

                                  final int yyChoice1 = yyIndex;

                                  // Nested alternative 1.

                                  yyC = character(yyChoice1);
                                  if (-1 != yyC) {
                                    yyIndex = yyChoice1 + 1;
                                    if ('E' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('Q' == yyC) {

                                          yyValue = "\u2AAD";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        }
                                      }
                                    }
                                  }

                                  // Nested alternative 2.

                                  yyValue = "\u2AAB";

                                  return new SemanticValue(yyValue, yyChoice1, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'T':
              {
                yyValue = "\u003C";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'E':
              {
                final int yyChoice1 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice1);
                if (-1 != yyC) {
                  yyIndex = yyChoice1 + 1;

                  switch (yyC) {
                  case 'A':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('D' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('S' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('T' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('O' == yyC) {

                                      yyValue = "\u219D";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'F':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('T' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case 'H':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('A' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('R' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('P' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('O' == yyC) {

                                                yyC = character(yyIndex);
                                                if (-1 != yyC) {
                                                  yyIndex = yyIndex + 1;
                                                  if ('O' == yyC) {

                                                    yyC = character(yyIndex);
                                                    if (-1 != yyC) {
                                                      yyIndex = yyIndex + 1;
                                                      if ('N' == yyC) {

                                                        yyC = 
                                                          character(yyIndex);
                                                        if (-1 != yyC) {
                                                          yyIndex = yyIndex + 1;

                                                          switch (yyC) {
                                                          case 'U':
                                                            {
                                                              yyC = 
                                                                character(yyIndex);
                                                              if (-1 != yyC) {
                                                                yyIndex = yyIndex + 1;
                                                                if ('P' == yyC) {

                                                                  yyValue = "\u21BC";

                                                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                                                }
                                                              }
                                                            }
                                                            break;

                                                          case 'D':
                                                            {
                                                              yyC = 
                                                                character(yyIndex);
                                                              if (-1 != yyC) {
                                                                yyIndex = yyIndex + 1;
                                                                if ('O' == yyC) {

                                                                  yyC = 
                                                                    character(yyIndex);
                                                                  if (-1 != yyC) {
                                                                    yyIndex = yyIndex + 1;
                                                                    if ('W' == yyC) {

                                                                      yyC = 
                                                                        character(yyIndex);
                                                                      if (-1 != yyC) {
                                                                        yyIndex = yyIndex + 1;
                                                                        if ('N' == yyC) {

                                                                          yyValue = "\u21BD";

                                                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                            break;

                                                          default:
                                                            /* No match. */
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'R':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('I' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('G' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('H' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('T' == yyC) {

                                                yyC = character(yyIndex);
                                                if (-1 != yyC) {
                                                  yyIndex = yyIndex + 1;
                                                  if ('A' == yyC) {

                                                    yyC = character(yyIndex);
                                                    if (-1 != yyC) {
                                                      yyIndex = yyIndex + 1;
                                                      if ('R' == yyC) {

                                                        yyC = 
                                                          character(yyIndex);
                                                        if (-1 != yyC) {
                                                          yyIndex = yyIndex + 1;
                                                          if ('R' == yyC) {

                                                            yyC = 
                                                              character(yyIndex);
                                                            if (-1 != yyC) {
                                                              yyIndex = yyIndex + 1;
                                                              if ('O' == yyC) {

                                                                yyC = 
                                                                  character(yyIndex);
                                                                if (-1 != yyC) {
                                                                  yyIndex = yyIndex + 1;
                                                                  if ('W' == yyC) {

                                                                    yyC = 
                                                                      character(yyIndex);
                                                                    if (-1 != yyC) {
                                                                      yyIndex = yyIndex + 1;
                                                                      if ('S' == yyC) {

                                                                        yyValue = "\u21C6";

                                                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'L':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('E' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('F' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('T' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('A' == yyC) {

                                                yyC = character(yyIndex);
                                                if (-1 != yyC) {
                                                  yyIndex = yyIndex + 1;
                                                  if ('R' == yyC) {

                                                    yyC = character(yyIndex);
                                                    if (-1 != yyC) {
                                                      yyIndex = yyIndex + 1;
                                                      if ('R' == yyC) {

                                                        yyC = 
                                                          character(yyIndex);
                                                        if (-1 != yyC) {
                                                          yyIndex = yyIndex + 1;
                                                          if ('O' == yyC) {

                                                            yyC = 
                                                              character(yyIndex);
                                                            if (-1 != yyC) {
                                                              yyIndex = yyIndex + 1;
                                                              if ('W' == yyC) {

                                                                yyC = 
                                                                  character(yyIndex);
                                                                if (-1 != yyC) {
                                                                  yyIndex = yyIndex + 1;
                                                                  if ('S' == yyC) {

                                                                    yyValue = "\u21C7";

                                                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyValue = "\u2264";

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'M':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('U' == yyC) {

              yyValue = "\u039C";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case 'N':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'U':
              {
                yyValue = "\u039D";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'S':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'I':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('M' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('E' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('Q' == yyC) {

                                  yyValue = "\u2244";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'U':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case 'B':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('S' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('E' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('T' == yyC) {

                                        final int yyChoice1 = yyIndex;

                                        // Nested alternative 1.

                                        yyC = character(yyChoice1);
                                        if (-1 != yyC) {
                                          yyIndex = yyChoice1 + 1;
                                          if ('E' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('Q' == yyC) {

                                                yyValue = "\u2288";

                                                return new SemanticValue(yyValue, yyIndex, yyError);
                                              }
                                            }
                                          }
                                        }

                                        // Nested alternative 2.

                                        yyValue = "\u2284";

                                        return new SemanticValue(yyValue, yyChoice1, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'P':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('S' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('E' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('T' == yyC) {

                                        final int yyChoice1 = yyIndex;

                                        // Nested alternative 1.

                                        yyC = character(yyChoice1);
                                        if (-1 != yyC) {
                                          yyIndex = yyChoice1 + 1;
                                          if ('E' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('Q' == yyC) {

                                                yyValue = "\u2289";

                                                return new SemanticValue(yyValue, yyIndex, yyError);
                                              }
                                            }
                                          }
                                        }

                                        // Nested alternative 2.

                                        yyValue = "\u2285";

                                        return new SemanticValue(yyValue, yyChoice1, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'C':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('C' == yyC) {

                                yyValue = "\u2281";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'A':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('P' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('P' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('R' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('O' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('X' == yyC) {

                                    yyValue = "\u2249";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'E':
              {
                final int yyChoice1 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice1);
                if (-1 != yyC) {
                  yyIndex = yyChoice1 + 1;

                  switch (yyC) {
                  case 'Q':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('V' == yyC) {

                          yyValue = "\u2262";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                    break;

                  case 'A':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('R' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('R' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('O' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('W' == yyC) {

                                      yyValue = "\u2197";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyValue = "\u2260";

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }

            case 'L':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'T':
                    {
                      yyValue = "\u226E";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  case 'E':
                    {
                      yyValue = "\u2270";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'G':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'T':
                    {
                      yyValue = "\u226F";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  case 'E':
                    {
                      yyValue = "\u2271";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'P':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'R':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('E' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('C' == yyC) {

                              yyValue = "\u2280";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'A':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('R' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('A' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('L' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('L' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('E' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('L' == yyC) {

                                              yyValue = "\u2226";

                                              return new SemanticValue(yyValue, yyIndex, yyError);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'O':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('T' == yyC) {

                    final int yyChoice1 = yyIndex;

                    // Nested alternative 1.

                    yyC = character(yyChoice1);
                    if (-1 != yyC) {
                      yyIndex = yyChoice1 + 1;

                      switch (yyC) {
                      case 'I':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('N' == yyC) {

                              final int yyChoice2 = yyIndex;

                              // Nested alternative 1.

                              yyValue = "\u2209";

                              return new SemanticValue(yyValue, yyChoice2, yyError);
                            }
                          }
                        }
                        break;

                      case 'S':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('U' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('B' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('S' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('E' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('T' == yyC) {

                                              final int yyChoice2 = yyIndex;

                                              // Nested alternative 1.

                                              yyC = character(yyChoice2);
                                              if (-1 != yyC) {
                                                yyIndex = yyChoice2 + 1;
                                                if ('E' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('Q' == yyC) {

                                                      yyValue = "\u2288";

                                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                                    }
                                                  }
                                                }
                                              }

                                              // Nested alternative 2.

                                              yyValue = "\u2284";

                                              return new SemanticValue(yyValue, yyChoice2, yyError);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        break;

                      case 'E':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('Q' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('U' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('I' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('V' == yyC) {

                                          yyValue = "\u2262";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        break;

                      default:
                        /* No match. */
                      }
                    }

                    // Nested alternative 2.

                    yyValue = "\u00AC";

                    return new SemanticValue(yyValue, yyChoice1, yyError);
                  }
                }
              }
              break;

            case 'W':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('A' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('R' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('R' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('O' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('W' == yyC) {

                                    yyValue = "\u2196";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'X':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'I':
              {
                yyValue = "\u039E";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'O':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('R' == yyC) {

                    yyValue = "\u22BB";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'O':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'M':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'I':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case 'C':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('R' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('O' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('N' == yyC) {

                                        yyValue = "\u039F";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'N':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('U' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('S' == yyC) {

                                    yyValue = "\u2296";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  case 'E':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('G' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('A' == yyC) {

                              yyValue = "\u03A9";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'T':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('I' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('M' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('E' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('S' == yyC) {

                                yyValue = "\u2297";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'D':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'O':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('T' == yyC) {

                          yyValue = "\u2299";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                    break;

                  case 'I':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('V' == yyC) {

                          yyValue = "\u2A38";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'S':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('L' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('A' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('S' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('H' == yyC) {

                                yyValue = "\u2298";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'P':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('L' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('U' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('S' == yyC) {

                            yyValue = "\u2295";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'R':
              {
                yyValue = "\u2228";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'P':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'I':
              {
                yyValue = "\u03A0";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'H':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('I' == yyC) {

                    yyValue = "\u03A6";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case 'S':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('I' == yyC) {

                    yyValue = "\u03A8";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case 'R':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'E':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('C' == yyC) {

                          final int yyChoice1 = yyIndex;

                          // Nested alternative 1.

                          yyC = character(yyChoice1);
                          if (-1 != yyC) {
                            yyIndex = yyChoice1 + 1;

                            switch (yyC) {
                            case 'E':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('Q' == yyC) {

                                    yyValue = "\u227C";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                              break;

                            case 'S':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('I' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('M' == yyC) {

                                        yyValue = "\u227E";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'N':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('S' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('I' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('M' == yyC) {

                                            yyValue = "\u22E8";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }

                          // Nested alternative 2.

                          yyValue = "\u227A";

                          return new SemanticValue(yyValue, yyChoice1, yyError);
                        }
                      }
                    }
                    break;

                  case 'O':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case 'D':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('U' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('C' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('T' == yyC) {

                                        yyValue = "\u220F";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          break;

                        case 'P':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('T' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('O' == yyC) {

                                    yyValue = "\u221D";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'A':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('R' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('A' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('L' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('L' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('E' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('L' == yyC) {

                                        yyValue = "\u2225";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'E':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('R' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('P' == yyC) {

                        yyValue = "\u27C2";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'R':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'H':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('O' == yyC) {

                    yyValue = "\u03A1";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case 'I':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'N':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('G' == yyC) {

                          final int yyChoice1 = yyIndex;

                          // Nested alternative 1.

                          yyC = character(yyChoice1);
                          if (-1 != yyC) {
                            yyIndex = yyChoice1 + 1;
                            if ('E' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('Q' == yyC) {

                                  yyValue = "\u2257";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }

                          // Nested alternative 2.

                          yyValue = "\u2218";

                          return new SemanticValue(yyValue, yyChoice1, yyError);
                        }
                      }
                    }
                    break;

                  case 'G':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('H' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('T' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;

                                switch (yyC) {
                                case 'H':
                                  {
                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('A' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('R' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('P' == yyC) {

                                                yyC = character(yyIndex);
                                                if (-1 != yyC) {
                                                  yyIndex = yyIndex + 1;
                                                  if ('O' == yyC) {

                                                    yyC = character(yyIndex);
                                                    if (-1 != yyC) {
                                                      yyIndex = yyIndex + 1;
                                                      if ('O' == yyC) {

                                                        yyC = 
                                                          character(yyIndex);
                                                        if (-1 != yyC) {
                                                          yyIndex = yyIndex + 1;
                                                          if ('N' == yyC) {

                                                            yyC = 
                                                              character(yyIndex);
                                                            if (-1 != yyC) {
                                                              yyIndex = yyIndex + 1;

                                                              switch (yyC) {
                                                              case 'U':
                                                                {
                                                                  yyC = 
                                                                    character(yyIndex);
                                                                  if (-1 != yyC) {
                                                                    yyIndex = yyIndex + 1;
                                                                    if ('P' == yyC) {

                                                                      yyValue = "\u21C0";

                                                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                                                    }
                                                                  }
                                                                }
                                                                break;

                                                              case 'D':
                                                                {
                                                                  yyC = 
                                                                    character(yyIndex);
                                                                  if (-1 != yyC) {
                                                                    yyIndex = yyIndex + 1;
                                                                    if ('O' == yyC) {

                                                                      yyC = 
                                                                        character(yyIndex);
                                                                      if (-1 != yyC) {
                                                                        yyIndex = yyIndex + 1;
                                                                        if ('W' == yyC) {

                                                                          yyC = 
                                                                            character(yyIndex);
                                                                          if (-1 != yyC) {
                                                                            yyIndex = yyIndex + 1;
                                                                            if ('N' == yyC) {

                                                                              yyValue = "\u21C1";

                                                                              return new SemanticValue(yyValue, yyIndex, yyError);
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                                break;

                                                              default:
                                                                /* No match. */
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  break;

                                case 'L':
                                  {
                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('E' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('F' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('T' == yyC) {

                                                yyC = character(yyIndex);
                                                if (-1 != yyC) {
                                                  yyIndex = yyIndex + 1;

                                                  switch (yyC) {
                                                  case 'A':
                                                    {
                                                      yyC = 
                                                        character(yyIndex);
                                                      if (-1 != yyC) {
                                                        yyIndex = yyIndex + 1;
                                                        if ('R' == yyC) {

                                                          yyC = 
                                                            character(yyIndex);
                                                          if (-1 != yyC) {
                                                            yyIndex = yyIndex + 1;
                                                            if ('R' == yyC) {

                                                              yyC = 
                                                                character(yyIndex);
                                                              if (-1 != yyC) {
                                                                yyIndex = yyIndex + 1;
                                                                if ('O' == yyC) {

                                                                  yyC = 
                                                                    character(yyIndex);
                                                                  if (-1 != yyC) {
                                                                    yyIndex = yyIndex + 1;
                                                                    if ('W' == yyC) {

                                                                      yyC = 
                                                                        character(yyIndex);
                                                                      if (-1 != yyC) {
                                                                        yyIndex = yyIndex + 1;
                                                                        if ('S' == yyC) {

                                                                          yyValue = "\u21C4";

                                                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                    break;

                                                  case 'H':
                                                    {
                                                      yyC = 
                                                        character(yyIndex);
                                                      if (-1 != yyC) {
                                                        yyIndex = yyIndex + 1;
                                                        if ('A' == yyC) {

                                                          yyC = 
                                                            character(yyIndex);
                                                          if (-1 != yyC) {
                                                            yyIndex = yyIndex + 1;
                                                            if ('R' == yyC) {

                                                              yyC = 
                                                                character(yyIndex);
                                                              if (-1 != yyC) {
                                                                yyIndex = yyIndex + 1;
                                                                if ('P' == yyC) {

                                                                  yyC = 
                                                                    character(yyIndex);
                                                                  if (-1 != yyC) {
                                                                    yyIndex = yyIndex + 1;
                                                                    if ('O' == yyC) {

                                                                      yyC = 
                                                                        character(yyIndex);
                                                                      if (-1 != yyC) {
                                                                        yyIndex = yyIndex + 1;
                                                                        if ('O' == yyC) {

                                                                          yyC = 
                                                                            character(yyIndex);
                                                                          if (-1 != yyC) {
                                                                            yyIndex = yyIndex + 1;
                                                                            if ('N' == yyC) {

                                                                              yyC = 
                                                                                character(yyIndex);
                                                                              if (-1 != yyC) {
                                                                                yyIndex = yyIndex + 1;
                                                                                if ('S' == yyC) {

                                                                                  yyValue = "\u21CC";

                                                                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                    break;

                                                  default:
                                                    /* No match. */
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  break;

                                case 'R':
                                  {
                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('I' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('G' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('H' == yyC) {

                                                yyC = character(yyIndex);
                                                if (-1 != yyC) {
                                                  yyIndex = yyIndex + 1;
                                                  if ('T' == yyC) {

                                                    yyC = character(yyIndex);
                                                    if (-1 != yyC) {
                                                      yyIndex = yyIndex + 1;
                                                      if ('A' == yyC) {

                                                        yyC = 
                                                          character(yyIndex);
                                                        if (-1 != yyC) {
                                                          yyIndex = yyIndex + 1;
                                                          if ('R' == yyC) {

                                                            yyC = 
                                                              character(yyIndex);
                                                            if (-1 != yyC) {
                                                              yyIndex = yyIndex + 1;
                                                              if ('R' == yyC) {

                                                                yyC = 
                                                                  character(yyIndex);
                                                                if (-1 != yyC) {
                                                                  yyIndex = yyIndex + 1;
                                                                  if ('O' == yyC) {

                                                                    yyC = 
                                                                      character(yyIndex);
                                                                    if (-1 != yyC) {
                                                                      yyIndex = yyIndex + 1;
                                                                      if ('W' == yyC) {

                                                                        yyC = 
                                                                          character(yyIndex);
                                                                        if (-1 != yyC) {
                                                                          yyIndex = yyIndex + 1;
                                                                          if ('S' == yyC) {

                                                                            yyValue = "\u21C9";

                                                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  break;

                                default:
                                  /* No match. */
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'S':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'I':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'G':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('M' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('A' == yyC) {

                              yyValue = "\u03A3";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'M':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('E' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('Q' == yyC) {

                              yyValue = "\u2243";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'E':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'T':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('M' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('I' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('N' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('U' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('S' == yyC) {

                                          yyValue = "\u2216";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'Q':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('V' == yyC) {

                          yyValue = "\u2263";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                    break;

                  case 'A':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('R' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('R' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('O' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('W' == yyC) {

                                      yyValue = "\u2198";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'Q':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'C':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case 'A':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('P' == yyC) {

                                final int yyChoice1 = yyIndex;

                                // Nested alternative 1.

                                yyC = character(yyChoice1);
                                if (-1 != yyC) {
                                  yyIndex = yyChoice1 + 1;
                                  if ('C' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('A' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('P' == yyC) {

                                            yyValue = "\u2A4E";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }

                                // Nested alternative 2.

                                yyValue = "\u2293";

                                return new SemanticValue(yyValue, yyChoice1, yyError);
                              }
                            }
                          }
                          break;

                        case 'U':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('P' == yyC) {

                                final int yyChoice1 = yyIndex;

                                // Nested alternative 1.

                                yyC = character(yyChoice1);
                                if (-1 != yyC) {
                                  yyIndex = yyChoice1 + 1;
                                  if ('C' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('U' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('P' == yyC) {

                                            yyValue = "\u2A4F";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }

                                // Nested alternative 2.

                                yyValue = "\u2294";

                                return new SemanticValue(yyValue, yyChoice1, yyError);
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  case 'S':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('U' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case 'B':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('S' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('E' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('T' == yyC) {

                                            final int yyChoice1 = yyIndex;

                                            // Nested alternative 1.

                                            yyC = character(yyChoice1);
                                            if (-1 != yyC) {
                                              yyIndex = yyChoice1 + 1;
                                              if ('E' == yyC) {

                                                yyC = character(yyIndex);
                                                if (-1 != yyC) {
                                                  yyIndex = yyIndex + 1;
                                                  if ('Q' == yyC) {

                                                    yyValue = "\u2291";

                                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                                  }
                                                }
                                              }
                                            }

                                            // Nested alternative 2.

                                            yyValue = "\u228F";

                                            return new SemanticValue(yyValue, yyChoice1, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'P':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('S' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('E' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('T' == yyC) {

                                            final int yyChoice1 = yyIndex;

                                            // Nested alternative 1.

                                            yyC = character(yyChoice1);
                                            if (-1 != yyC) {
                                              yyIndex = yyChoice1 + 1;
                                              if ('E' == yyC) {

                                                yyC = character(yyIndex);
                                                if (-1 != yyC) {
                                                  yyIndex = yyIndex + 1;
                                                  if ('Q' == yyC) {

                                                    yyValue = "\u2292";

                                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                                  }
                                                }
                                              }
                                            }

                                            // Nested alternative 2.

                                            yyValue = "\u2290";

                                            return new SemanticValue(yyValue, yyChoice1, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'R':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('T' == yyC) {

                          yyValue = "\u221A";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'U':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'B':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('S' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case 'E':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('T' == yyC) {

                                    final int yyChoice1 = yyIndex;

                                    // Nested alternative 1.

                                    yyC = character(yyChoice1);
                                    if (-1 != yyC) {
                                      yyIndex = yyChoice1 + 1;

                                      switch (yyC) {
                                      case 'E':
                                        {
                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('Q' == yyC) {

                                              yyValue = "\u2286";

                                              return new SemanticValue(yyValue, yyIndex, yyError);
                                            }
                                          }
                                        }
                                        break;

                                      case 'N':
                                        {
                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('E' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('Q' == yyC) {

                                                  yyValue = "\u228A";

                                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                                }
                                              }
                                            }
                                          }
                                        }
                                        break;

                                      default:
                                        /* No match. */
                                      }
                                    }

                                    // Nested alternative 2.

                                    yyValue = "\u2282";

                                    return new SemanticValue(yyValue, yyChoice1, yyError);
                                  }
                                }
                              }
                              break;

                            case 'U':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('B' == yyC) {

                                    yyValue = "\u22D0";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'P':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('S' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case 'E':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('T' == yyC) {

                                    final int yyChoice1 = yyIndex;

                                    // Nested alternative 1.

                                    yyC = character(yyChoice1);
                                    if (-1 != yyC) {
                                      yyIndex = yyChoice1 + 1;

                                      switch (yyC) {
                                      case 'E':
                                        {
                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('Q' == yyC) {

                                              yyValue = "\u2287";

                                              return new SemanticValue(yyValue, yyIndex, yyError);
                                            }
                                          }
                                        }
                                        break;

                                      case 'N':
                                        {
                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('E' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('Q' == yyC) {

                                                  yyValue = "\u228B";

                                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                                }
                                              }
                                            }
                                          }
                                        }
                                        break;

                                      default:
                                        /* No match. */
                                      }
                                    }

                                    // Nested alternative 2.

                                    yyValue = "\u2283";

                                    return new SemanticValue(yyValue, yyChoice1, yyError);
                                  }
                                }
                              }
                              break;

                            case 'U':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('P' == yyC) {

                                    yyValue = "\u22D1";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'C':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('C' == yyC) {

                          final int yyChoice1 = yyIndex;

                          // Nested alternative 1.

                          yyC = character(yyChoice1);
                          if (-1 != yyC) {
                            yyIndex = yyChoice1 + 1;

                            switch (yyC) {
                            case 'E':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('Q' == yyC) {

                                    yyValue = "\u227D";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                              break;

                            case 'S':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('I' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('M' == yyC) {

                                        yyValue = "\u227F";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            case 'N':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('S' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('I' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('M' == yyC) {

                                            yyValue = "\u22E9";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }

                          // Nested alternative 2.

                          yyValue = "\u227B";

                          return new SemanticValue(yyValue, yyChoice1, yyError);
                        }
                      }
                    }
                    break;

                  case 'M':
                    {
                      yyValue = "\u2211";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'M':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('A' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('L' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('L' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('E' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('R' == yyC) {

                                    final int yyChoice1 = yyIndex;

                                    // Nested alternative 1.

                                    yyC = character(yyChoice1);
                                    if (-1 != yyC) {
                                      yyIndex = yyChoice1 + 1;
                                      if ('E' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('Q' == yyC) {

                                            yyValue = "\u2AAC";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }

                                    // Nested alternative 2.

                                    yyValue = "\u2AAA";

                                    return new SemanticValue(yyValue, yyChoice1, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'W':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('A' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('R' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('R' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('O' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('W' == yyC) {

                                    yyValue = "\u2199";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'T':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('A' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('R' == yyC) {

                        yyValue = "\u22C6";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'U':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'P':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'S':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('I' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('L' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('O' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('N' == yyC) {

                                      yyValue = "\u03A5";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'L':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('U' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('S' == yyC) {

                              yyValue = "\u228E";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'A':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('R' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('R' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('O' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('W' == yyC) {

                                      yyValue = "\u2191";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'D':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('O' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('W' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('N' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('A' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('R' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('R' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('O' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('W' == yyC) {

                                                      yyValue = "\u2195";

                                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'H':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('A' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('R' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('P' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('O' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('O' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('N' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;

                                                switch (yyC) {
                                                case 'R':
                                                  {
                                                    yyC = character(yyIndex);
                                                    if (-1 != yyC) {
                                                      yyIndex = yyIndex + 1;
                                                      if ('I' == yyC) {

                                                        yyC = 
                                                          character(yyIndex);
                                                        if (-1 != yyC) {
                                                          yyIndex = yyIndex + 1;
                                                          if ('G' == yyC) {

                                                            yyC = 
                                                              character(yyIndex);
                                                            if (-1 != yyC) {
                                                              yyIndex = yyIndex + 1;
                                                              if ('H' == yyC) {

                                                                yyC = 
                                                                  character(yyIndex);
                                                                if (-1 != yyC) {
                                                                  yyIndex = yyIndex + 1;
                                                                  if ('T' == yyC) {

                                                                    yyValue = "\u21BE";

                                                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                  break;

                                                case 'L':
                                                  {
                                                    yyC = character(yyIndex);
                                                    if (-1 != yyC) {
                                                      yyIndex = yyIndex + 1;
                                                      if ('E' == yyC) {

                                                        yyC = 
                                                          character(yyIndex);
                                                        if (-1 != yyC) {
                                                          yyIndex = yyIndex + 1;
                                                          if ('F' == yyC) {

                                                            yyC = 
                                                              character(yyIndex);
                                                            if (-1 != yyC) {
                                                              yyIndex = yyIndex + 1;
                                                              if ('T' == yyC) {

                                                                yyValue = "\u21BF";

                                                                return new SemanticValue(yyValue, yyIndex, yyError);
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                  break;

                                                default:
                                                  /* No match. */
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'U':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('P' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('A' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('R' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('R' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('O' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('W' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('S' == yyC) {

                                                  yyValue = "\u21C8";

                                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'N':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('I' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('O' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('N' == yyC) {

                            yyValue = "\u222A";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'C':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'H':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('I' == yyC) {

                    yyValue = "\u03A7";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case 'I':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('R' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('C' == yyC) {

                        final int yyChoice1 = yyIndex;

                        // Nested alternative 1.

                        yyC = character(yyChoice1);
                        if (-1 != yyC) {
                          yyIndex = yyChoice1 + 1;
                          if ('L' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('E' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('D' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;

                                      switch (yyC) {
                                      case 'A':
                                        {
                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('S' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('T' == yyC) {

                                                  yyValue = "\u229B";

                                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                                }
                                              }
                                            }
                                          }
                                        }
                                        break;

                                      case 'R':
                                        {
                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('I' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('N' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('G' == yyC) {

                                                      yyValue = "\u229A";

                                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                        break;

                                      default:
                                        /* No match. */
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }

                        // Nested alternative 2.

                        yyValue = "\u2218";

                        return new SemanticValue(yyValue, yyChoice1, yyError);
                      }
                    }
                  }
                }
              }
              break;

            case 'R':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('O' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('S' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('S' == yyC) {

                            yyValue = "\u2A2F";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'A':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('P' == yyC) {

                    final int yyChoice1 = yyIndex;

                    // Nested alternative 1.

                    yyC = character(yyChoice1);
                    if (-1 != yyC) {
                      yyIndex = yyChoice1 + 1;
                      if ('C' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('A' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('P' == yyC) {

                                yyValue = "\u22D2";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                        }
                      }
                    }

                    // Nested alternative 2.

                    yyValue = "\u2229";

                    return new SemanticValue(yyValue, yyChoice1, yyError);
                  }
                }
              }
              break;

            case 'U':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'P':
                    {
                      final int yyChoice1 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice1);
                      if (-1 != yyC) {
                        yyIndex = yyChoice1 + 1;
                        if ('C' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('U' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('P' == yyC) {

                                  yyValue = "\u22D3";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                      }

                      // Nested alternative 2.

                      yyValue = "\u222A";

                      return new SemanticValue(yyValue, yyChoice1, yyError);
                    }

                  case 'R':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('L' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('Y' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;

                                switch (yyC) {
                                case 'A':
                                  {
                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('N' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('D' == yyC) {

                                            yyValue = "\u22CF";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          }
                                        }
                                      }
                                    }
                                  }
                                  break;

                                case 'O':
                                  {
                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('R' == yyC) {

                                        yyValue = "\u22CE";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                  break;

                                default:
                                  /* No match. */
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'O':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'N':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('T' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('A' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('I' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('N' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('S' == yyC) {

                                          yyValue = "\u220B";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'P':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('R' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('O' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('D' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('U' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('C' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('T' == yyC) {

                                              yyValue = "\u2210";

                                              return new SemanticValue(yyValue, yyIndex, yyError);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'M':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('P' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('O' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('S' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('E' == yyC) {

                                      yyValue = "\u2218";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'E':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('N' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('T' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('S' == yyC) {

                            yyValue = "\u00A2";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'B':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('R' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('T' == yyC) {

                        yyValue = "\u221B";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'a':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('l' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('p' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('h' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('a' == yyC) {

                          yyValue = "\u03B1";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'b':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('e' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('t' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('a' == yyC) {

                      yyValue = "\u03B2";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'g':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('m' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('m' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('a' == yyC) {

                          yyValue = "\u03B3";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'd':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('e' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('l' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('t' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('a' == yyC) {

                          yyValue = "\u03B4";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'p':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('s' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('i' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('l' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('o' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('n' == yyC) {

                                    yyValue = "\u03B5";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 't':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('a' == yyC) {

                    yyValue = "\u03B7";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'z':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('e' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('t' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('a' == yyC) {

                      yyValue = "\u03B6";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 't':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'h':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('e' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('t' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('a' == yyC) {

                            yyValue = "\u03B8";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'a':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('u' == yyC) {

                    yyValue = "\u03C4";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'i':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('o' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('t' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('a' == yyC) {

                      yyValue = "\u03B9";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'k':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('p' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('p' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('a' == yyC) {

                          yyValue = "\u03BA";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'l':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('m' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('b' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('d' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('a' == yyC) {

                              yyValue = "\u03BB";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'm':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('u' == yyC) {

              yyValue = "\u03BC";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case 'n':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('u' == yyC) {

              yyValue = "\u03BD";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case 'x':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('i' == yyC) {

              yyValue = "\u03BE";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case 'o':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('m' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;

                switch (yyC) {
                case 'i':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('c' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('r' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('o' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('n' == yyC) {

                                    yyValue = "\u03BF";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  break;

                case 'e':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('g' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('a' == yyC) {

                            yyValue = "\u03C9";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }
                        }
                      }
                    }
                  }
                  break;

                default:
                  /* No match. */
                }
              }
            }
          }
        }
        break;

      case 'p':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'i':
              {
                yyValue = "\u03C0";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'h':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('i' == yyC) {

                    yyValue = "\u03C6";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case 's':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('i' == yyC) {

                    yyValue = "\u03C8";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'r':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('h' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('o' == yyC) {

                  yyValue = "\u03C1";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('i' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('g' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('m' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('a' == yyC) {

                          yyValue = "\u03C3";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'u':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('p' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('s' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('i' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('l' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('o' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('n' == yyC) {

                                  yyValue = "\u03C5";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'c':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('h' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('i' == yyC) {

                  yyValue = "\u03C7";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case 'F':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('O' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;

                switch (yyC) {
                case 'R':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('A' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('L' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('L' == yyC) {

                                yyValue = "\u2200";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  break;

                case 'U':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('R' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('T' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('H' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('R' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('O' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('O' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('T' == yyC) {

                                                yyValue = "\u221C";

                                                return new SemanticValue(yyValue, yyIndex, yyError);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  break;

                default:
                  /* No match. */
                }
              }
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '=':
              {
                final int yyChoice1 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice1);
                if (-1 != yyC) {
                  yyIndex = yyChoice1 + 1;
                  if ('>' == yyC) {

                    yyValue = "\u21D4";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = "\u2264";

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }

            case '<':
              {
                final int yyChoice1 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice1);
                if (-1 != yyC) {
                  yyIndex = yyChoice1 + 1;
                  if ('<' == yyC) {

                    yyValue = "\u22D8";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = "\u226A";

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }

            case '-':
              {
                final int yyChoice1 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice1);
                if (-1 != yyC) {
                  yyIndex = yyChoice1 + 1;

                  switch (yyC) {
                  case '>':
                    {
                      yyValue = "\u2194";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  case '/':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('-' == yyC) {

                          yyValue = "\u219A";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyValue = "\u2190";

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "\u2265";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '>':
              {
                final int yyChoice1 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice1);
                if (-1 != yyC) {
                  yyIndex = yyChoice1 + 1;
                  if ('>' == yyC) {

                    yyValue = "\u22D9";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = "\u226B";

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '>':
              {
                yyValue = "\u2192";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '/':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('-' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('>' == yyC) {

                        yyValue = "\u219B";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case '!':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('!' == yyC) {

              yyValue = "\u203C";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('>' == yyC) {

              yyValue = "\u21D2";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case 'W':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('R' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('E' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('A' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('T' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('H' == yyC) {

                              yyValue = "\u2240";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'V':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('D' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('A' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('S' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('H' == yyC) {

                          yyValue = "\u22A2";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'J':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('O' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('I' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('N' == yyC) {

                      yyValue = "\u2A1D";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 4.

    yyResult = p$$Shared57(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (' ' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pUnicodeCharLiteralContent(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a2 = yyResult.semanticValue();

          if (Integer.parseInt(a2, 16) == ((int) a1)) {

            yyValue = a1 + " " + a2;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("\" \" expected", yyBase);
      }
    }

    // Alternative <ErrorProduction1>.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyBase = yyIndex;
      yyC    = character(yyBase);
      if (' ' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUnicodeCharLiteralContent(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          log(span, "Syntax Error: The character in a redundant character literal is invalid or does not match the given hexadecimal codepoint.");
          yyValue = "";

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\" \" expected", yyBase);
      }
    }

    // Alternative 6.

    yyResult = p$$Shared57(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = String.valueOf(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("char literal content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared57.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.CharLiteralContent$$Choice1 
   * and com.sun.fortress.parser.templateparser.TemplateParser.CharLiteralContent$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared57(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.f$$Shared57) 
      yyColumn.chunk22.f$$Shared57 = p$$Shared57$1(yyStart);
    return yyColumn.chunk22.f$$Shared57;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared57. */
  private Result p$$Shared57$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pInvalidCharLiteralContent(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select(" expected", yyStart);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.UnicodeCharLiteralContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnicodeCharLiteralContent(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fUnicodeCharLiteralContent) 
      yyColumn.chunk22.fUnicodeCharLiteralContent = pUnicodeCharLiteralContent$1(yyStart);
    return yyColumn.chunk22.fUnicodeCharLiteralContent;
  }

  /** Actually parse Literal.UnicodeCharLiteralContent. */
  private Result pUnicodeCharLiteralContent$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnicodeHexChar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('U' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('+' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pUnicodeHexChar(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a1 = yyResult.semanticValue();

          yyValue = a1;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("unicode char literal content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.UnicodeHexChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnicodeHexChar(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fUnicodeHexChar) 
      yyColumn.chunk22.fUnicodeHexChar = pUnicodeHexChar$1(yyStart);
    return yyColumn.chunk22.fUnicodeHexChar;
  }

  /** Actually parse Literal.UnicodeHexChar. */
  private Result pUnicodeHexChar$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                          {
                            yyOption1  = yyIndex;

                            yyC = character(yyOption1);
                            if (-1 != yyC) {
                              yyIndex = yyOption1 + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                              case '8':
                              case '9':
                              case 'A':
                              case 'B':
                              case 'C':
                              case 'D':
                              case 'E':
                              case 'F':
                                {
                                  yyOption1  = yyIndex;
                                }

                              default:
                                /* No match. */
                              }
                            }

                            yyValue = difference(yyStart, yyOption1);

                            return new SemanticValue(yyValue, yyOption1, yyError);
                          }

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                          {
                            yyOption1  = yyIndex;

                            yyC = character(yyOption1);
                            if (-1 != yyC) {
                              yyIndex = yyOption1 + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                              case '8':
                              case '9':
                              case 'a':
                              case 'b':
                              case 'c':
                              case 'd':
                              case 'e':
                              case 'f':
                                {
                                  yyOption1  = yyIndex;
                                }

                              default:
                                /* No match. */
                              }
                            }

                            yyValue = difference(yyStart, yyOption1);

                            return new SemanticValue(yyValue, yyOption1, yyError);
                          }

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('1' == yyC) {

        yyC = character(yyIndex);
        if (-1 != yyC) {
          yyIndex = yyIndex + 1;
          if ('0' == yyC) {

            final int yyChoice1 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
              case 'A':
              case 'B':
              case 'C':
              case 'D':
              case 'E':
              case 'F':
                {
                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case 'A':
                    case 'B':
                    case 'C':
                    case 'D':
                    case 'E':
                    case 'F':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;

                          switch (yyC) {
                          case '0':
                          case '1':
                          case '2':
                          case '3':
                          case '4':
                          case '5':
                          case '6':
                          case '7':
                          case '8':
                          case '9':
                          case 'A':
                          case 'B':
                          case 'C':
                          case 'D':
                          case 'E':
                          case 'F':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;

                                switch (yyC) {
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                case 'A':
                                case 'B':
                                case 'C':
                                case 'D':
                                case 'E':
                                case 'F':
                                  {
                                    yyValue = difference(yyStart, yyIndex);

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }

                                default:
                                  /* No match. */
                                }
                              }
                            }
                            break;

                          default:
                            /* No match. */
                          }
                        }
                      }
                      break;

                    default:
                      /* No match. */
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }

            // Nested alternative 2.

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
              case 'a':
              case 'b':
              case 'c':
              case 'd':
              case 'e':
              case 'f':
                {
                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case 'a':
                    case 'b':
                    case 'c':
                    case 'd':
                    case 'e':
                    case 'f':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;

                          switch (yyC) {
                          case '0':
                          case '1':
                          case '2':
                          case '3':
                          case '4':
                          case '5':
                          case '6':
                          case '7':
                          case '8':
                          case '9':
                          case 'a':
                          case 'b':
                          case 'c':
                          case 'd':
                          case 'e':
                          case 'f':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;

                                switch (yyC) {
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                case 'a':
                                case 'b':
                                case 'c':
                                case 'd':
                                case 'e':
                                case 'f':
                                  {
                                    yyValue = difference(yyStart, yyIndex);

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }

                                default:
                                  /* No match. */
                                }
                              }
                            }
                            break;

                          default:
                            /* No match. */
                          }
                        }
                      }
                      break;

                    default:
                      /* No match. */
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
        }
      }
    }

    // Alternative <ErrorProduction1>.

    yyResult = pUnicodeHexChar$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      log(span, "Syntax Error: a hexadecimal character literal " +
      "has a value larger than 10FFFF.");

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <ErrorProduction2>.

    yyResult = pUnicodeHexChar$$Choice2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      log(span, "Syntax Error: a hexadecimal character literal " +
      "has fewer than four hexadecimal digits.");

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyResult = pUnicodeHexChar$$Plus3(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount);
            log(span, "Syntax Error: a hexadecimal character literal " +
            "contains both uppercase and lowercase letters.");

            yyValue = difference(yyStart, yyResult.index);

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("unicode hex char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.UnicodeHexChar$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnicodeHexChar$$Plus1(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fUnicodeHexChar$$Plus1) 
      yyColumn.chunk22.fUnicodeHexChar$$Plus1 = pUnicodeHexChar$$Plus1$1(yyStart);
    return yyColumn.chunk22.fUnicodeHexChar$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.UnicodeHexChar$$Plus1. */
  private Result pUnicodeHexChar$$Plus1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pUnicodeHexChar$$Plus1(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("unicode hex char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.UnicodeHexChar$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnicodeHexChar$$Plus2(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fUnicodeHexChar$$Plus2) 
      yyColumn.chunk22.fUnicodeHexChar$$Plus2 = pUnicodeHexChar$$Plus2$1(yyStart);
    return yyColumn.chunk22.fUnicodeHexChar$$Plus2;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.UnicodeHexChar$$Plus2. */
  private Result pUnicodeHexChar$$Plus2$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pUnicodeHexChar$$Plus2(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("unicode hex char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.UnicodeHexChar$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnicodeHexChar$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                              case '8':
                              case '9':
                              case 'A':
                              case 'B':
                              case 'C':
                              case 'D':
                              case 'E':
                              case 'F':
                                {
                                  yyResult = pUnicodeHexChar$$Plus1(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyValue = null;

                                    return yyResult.createValue(yyValue, yyError);
                                  }
                                }
                                break;

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                              case '8':
                              case '9':
                              case 'a':
                              case 'b':
                              case 'c':
                              case 'd':
                              case 'e':
                              case 'f':
                                {
                                  yyResult = pUnicodeHexChar$$Plus2(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyValue = null;

                                    return yyResult.createValue(yyValue, yyError);
                                  }
                                }
                                break;

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("unicode hex char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.UnicodeHexChar$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnicodeHexChar$$Choice2(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
              {
                yyOption1  = yyIndex;

                yyC = character(yyOption1);
                if (-1 != yyC) {
                  yyIndex = yyOption1 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                    {
                      yyOption1  = yyIndex;
                    }

                  default:
                    /* No match. */
                  }
                }

                yyValue = null;

                return new SemanticValue(yyValue, yyOption1, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
              {
                yyOption1  = yyIndex;

                yyC = character(yyOption1);
                if (-1 != yyC) {
                  yyIndex = yyOption1 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                    {
                      yyOption1  = yyIndex;
                    }

                  default:
                    /* No match. */
                  }
                }

                yyValue = null;

                return new SemanticValue(yyValue, yyOption1, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("unicode hex char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.UnicodeHexChar$$Plus3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnicodeHexChar$$Plus3(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fUnicodeHexChar$$Plus3) 
      yyColumn.chunk22.fUnicodeHexChar$$Plus3 = pUnicodeHexChar$$Plus3$1(yyStart);
    return yyColumn.chunk22.fUnicodeHexChar$$Plus3;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.UnicodeHexChar$$Plus3. */
  private Result pUnicodeHexChar$$Plus3$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pUnicodeHexChar$$Plus3(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("unicode hex char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.InvalidCharLiteralContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInvalidCharLiteralContent(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if ((('\t' <= a1) && (a1 <= '\r')) ||
          (('\u001c' <= a1) && (a1 <= '\u001f')) ||
          ('\"' == a1) ||
          ('\\' == a1) ||
          (('\u201c' <= a1) && (a1 <= '\u201d')) ||
          (('\u2028' <= a1) && (a1 <= '\u2029'))) {

        log(createSpan(yyStart,yyCount), "Invalid character literal: " + a1);
        yyValue = "";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (Character.getType(c) == Character.CONTROL) {

        log(createSpan(yyStart,yyCount), "Invalid character literal: " + c);
        yyValue = "";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("invalid char literal content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceLiteral.ArrayExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayExpr(final int yyStart) throws IOException {
    Result                                           yyResult;
    int                                              yyRepetition1;
    Pair<com.sun.fortress.useful.Pair<Integer,Expr>> yyRepValue1;
    int                                              yyOption1;
    List<StaticArg>                                  yyOpValue1;
    ArrayElements                                    yyValue;
    ParseError                                       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$opensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<StaticArg> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoSpaceExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pMultiDimCons(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                com.sun.fortress.useful.Pair<Integer,Expr> v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<com.sun.fortress.useful.Pair<Integer,Expr>>(v$el$2, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for a3s.
              Pair<com.sun.fortress.useful.Pair<Integer,Expr>> a3s = yyRepValue1.reverse();

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = p$$Shared7(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  ArrayElements rectElements;
                  if (a3s == null || a3s.isEmpty()) {
                    List<ArrayExpr> list = new ArrayList<ArrayExpr>();
                    list.add(ExprFactory.makeArrayElement(a2));
                    rectElements = ExprFactory.makeArrayElements(NodeUtil.getSpan(a2),
                    1, list);
                  } else
                  rectElements = ExprFactory.multiDimCons(writer, a2, a3s.list());
                  if (a1 == null)
                  yyValue = ExprFactory.finalizeArrayExpr(rectElements);
                  else
                  yyValue = ExprFactory.addStaticArgsToArrayExpr(a1, rectElements);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a3s.
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceLiteral.MultiDimCons.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiDimCons(final int yyStart) throws IOException {
    Result                                     yyResult;
    com.sun.fortress.useful.Pair<Integer,Expr> yyValue;
    ParseError                                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRectSeparator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Integer a1 = yyResult.semanticValue();

      yyResult = pNoSpaceExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expr a2 = yyResult.semanticValue();

        yyValue = new com.sun.fortress.useful.Pair<Integer,Expr>(a1,a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.BlockElems.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElems(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fBlockElems) 
      yyColumn.chunk22.fBlockElems = pBlockElems$1(yyStart);
    return yyColumn.chunk22.fBlockElems;
  }

  /** Actually parse LocalDecl.BlockElems. */
  private Result pBlockElems$1(final int yyStart) throws IOException {
    Result     yyResult;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBlockElemCollection(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Expr> a1 = yyResult.semanticValue();

      yyValue = ExprFactory.doBlock(writer, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.BlockElemCollection.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElemCollection(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fBlockElemCollection) 
      yyColumn.chunk22.fBlockElemCollection = pBlockElemCollection$1(yyStart);
    return yyColumn.chunk22.fBlockElemCollection;
  }

  /** Actually parse LocalDecl.BlockElemCollection. */
  private Result pBlockElemCollection$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Result     yyPredResult;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBlockElem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pbr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlockElemCollection(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expr> a2 = yyResult.semanticValue();

          yyValue = Useful.cons(a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyPredResult = p$$Shared58(yyResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyValue = Useful.list(a1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyPredResult = p$$Shared58(yyChoice1);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyValue = Useful.list(a1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }

      // Nested alternative 4.

      yyPredResult = pBlockElemCollection$$Choice3(yyChoice1);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyValue = Useful.list(a1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }

      // Nested alternative 5.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyPredResult = pw(yyResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyPredResult = pElse(yyPredResult.index);
            yyError      = yyPredResult.select(yyError);
            if (yyPredResult.hasValue()) {

              yyValue = Useful.list(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared58.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.BlockElemCollection$$Choice1 
   * and com.sun.fortress.parser.templateparser.TemplateParser.BlockElemCollection$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared58(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.f$$Shared58) 
      yyColumn.chunk22.f$$Shared58 = p$$Shared58$1(yyStart);
    return yyColumn.chunk22.f$$Shared58;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.$$Shared58. */
  private Result p$$Shared58$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pelif(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = palso(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pend(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pcatch(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 5.

      yyResult = pforbid(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 6.

      yyResult = pfinally(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 7.

      yyResult = pcloseparen(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.BlockElemCollection$$Choice3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElemCollection$$Choice3(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pElse(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pCaseClause(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;

      yyResult = pId(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$colon(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }
          }
        }
      }

      yyResult = pTypeOrPattern(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pCaseElse(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.BlockElem.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElem(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyOption1;
    List<GeneratorClause> yyOpValue1;
    Expr                  yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalVarFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = ps(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$GeneratorClauseList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<GeneratorClause> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
        }
      }
      { // Start scope for a2.
        List<GeneratorClause> a2 = yyOpValue1;

        if (a2 == null) yyValue = a1;
        else yyValue = ExprFactory.makeFor(createSpan(yyStart,yyCount),
        a2, ExprFactory.makeBlock(a1));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.LocalVarFnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalVarFnDecl(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<FnDecl> yyRepValue1;
    LetExpr      yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FnDecl a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pLocalFnDecl(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            FnDecl v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<FnDecl>(v$el$2, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<FnDecl> a2s = yyRepValue1.reverse();

        yyValue = ExprFactory.makeLetFn(createSpan(yyStart,yyCount),
        Collections.<Expr>emptyList(),
        Useful.cons(a1, a2s.list()));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Alternative 2.

    yyResult = pLocalVarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.LocalFnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalFnDecl(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fLocalFnDecl) 
      yyColumn.chunk23.fLocalFnDecl = pLocalFnDecl$1(yyStart);
    return yyColumn.chunk23.fLocalFnDecl;
  }

  /** Actually parse LocalDecl.LocalFnDecl. */
  private Result pLocalFnDecl$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    FnDecl     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      Modifiers a1 = cast(yyOpValue1);

      yyResult = pId(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticParams(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<StaticParam> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<StaticParam> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pLocalDecl$ValParam(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Param> a4 = yyResult.semanticValue();

              yyResult = pFnHeaderClause(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                FnHeaderClause a5 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pequals(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pNoNewlineExpr(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Expr a6 = yyResult.semanticValue();

                        if (a1 == null) a1 = Modifiers.None;
                        if (a3 == null) a3 = Collections.<StaticParam>emptyList();
                        yyValue = NodeFactory.mkFnDecl(createSpan(yyStart,yyCount), a1,
                        new FnHeaderFront(a2, a3, a4), a5, a6);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              }
            }
          }
        } // End scope for a3.
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.ValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalDecl$ValParam(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pLocalDecl$Params(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = Collections.<Param>emptyList();
            else            yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = Useful.list(NodeFactory.makeParam(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalDecl$Params(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyRepetition1;
    boolean     yyRepeated1;
    Pair<Param> yyRepValue1;
    int         yyOption1;
    Param       yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative <ErrorProduction1>.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pLocalDecl$Param(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              yyRepeated1   = true;
              continue;
            }
          }
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyRepeated1   = false;
      while (true) {

        yyResult = pLocalDecl$Keyword(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyResult = pLocalDecl$Varargs(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          log(createSpan(yyStart,yyCount),
          "Varargs parameters should come before keyword parameters.");
          yyValue = Collections.<Param>emptyList();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pLocalDecl$Varargs(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            yyRepeated1   = false;
            while (true) {

              yyResult = pLocalDecl$Keyword(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyRepetition1 = yyResult.index;
                      yyRepeated1   = true;
                      continue;
                    }
                  }
                }
              }
              break;
            }

            if (yyRepeated1) {

              yyResult = pLocalDecl$Param(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyRepetition1 = yyResult.index;
                while (true) {

                  yyResult = pw(yyRepetition1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcomma(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pLocalDecl$Param(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyRepetition1 = yyResult.index;
                          continue;
                        }
                      }
                    }
                  }
                  break;
                }

                log(createSpan(yyStart,yyCount),
                "Normal parameters should come before varargs parameters and keyword parameters.");
                yyValue = Collections.<Param>emptyList();

                return new SemanticValue(yyValue, yyRepetition1, yyError);
              }
            }
          }
        }
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pLocalDecl$Param(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {

        while (true) {

          yyResult = pw(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pLocalDecl$Keyword(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyRepetition1 = yyResult.index;
                  continue;
                }
              }
            }
          }
          break;
        }

        log(createSpan(yyStart,yyCount),
        "Normal parameters should come before varargs parameters.");
        yyValue = Collections.<Param>emptyList();

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Alternative 3.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pLocalDecl$Param(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Param v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Param>(v$el$1, yyRepValue1);
              continue;
            }
          }
        }
      }
      break;
    }
    { // Start scope for a1s.
      Pair<Param> a1s = yyRepValue1.reverse();

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pLocalDecl$Varargs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Param v$el$2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
        }
      }
      { // Start scope for a2.
        Param a2 = yyOpValue1;

        yyResult = pLocalDecl$Keyword(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Param a3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pLocalDecl$Keyword(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Param v$el$3 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = new Pair<Param>(v$el$3, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }
          { // Start scope for a4s.
            Pair<Param> a4s = yyRepValue1.reverse();

            yyValue = Useful.list(a1s.list());
            if (a2 != null) yyValue.add(a2);
            yyValue.add(a3);
            yyValue.addAll(a4s.list());

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for a4s.
        }
      } // End scope for a2.

      // Nested alternative 2.

      yyResult = pLocalDecl$Varargs(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Param a2 = yyResult.semanticValue();

        yyValue = Useful.list(a1s.list(), a2);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1s.

    // Alternative 4.

    yyResult = pLocalDecl$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Param a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pLocalDecl$Param(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Param v$el$4 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Param>(v$el$4, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Param> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.Param.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalDecl$Param(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = ps(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = ps(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyResult = pPattern(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pattern a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeParam(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyResult = pNoNewlineType(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeParam(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }

      // Nested alternative 2.

      yyValue = NodeFactory.makeParam(a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.Varargs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalDecl$Varargs(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = ps(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyResult = ps(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pellipses(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = NodeFactory.makeVarargsParam(a1, a2);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalDecl$Keyword(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalDecl$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Param a1 = yyResult.semanticValue();

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeParam(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.LocalVarDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalVarDecl(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    LocalVarDecl yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      Modifiers a1 = cast(yyOpValue1);

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pLocalDecl$VarMayTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValue> a2 = yyResult.semanticValue();

        yyResult = ps(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pequals(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr a3 = yyResult.semanticValue();

                a2 = NodeFactory.makeLvs(writer, a2, Option.<Modifiers>wrap(a1), false);
                yyValue = ExprFactory.makeLocalVarDecl(createSpan(yyStart,yyCount), a2, a3);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }

      // Nested alternative 2.

      yyResult = pNoNewlineVarWTypeOrPatterns(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValue> a2 = yyResult.semanticValue();

        yyResult = ps(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcolonequals(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr a3 = yyResult.semanticValue();

                a2 = NodeFactory.makeLvs(writer, a2, Option.<Modifiers>wrap(a1), true);
                yyValue = ExprFactory.makeLocalVarDecl(createSpan(yyStart,yyCount), a2, a3);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }

      // Nested alternative 3.

      yyResult = pNoNewlineVarWTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValue> a2 = yyResult.semanticValue();

        a2 = NodeFactory.makeLvs(writer, a2, Option.<Modifiers>wrap(a1), false);
        yyValue = ExprFactory.makeLocalVarDecl(createSpan(yyStart,yyCount), a2);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pVarWoTypes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<LValue> a1 = yyResult.semanticValue();

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = ExprFactory.makeLocalVarDecl(createSpan(yyStart,yyCount),a1,a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 3.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifiers v$el$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$2;
    }
    { // Start scope for a1.
      Modifiers a1 = cast(yyOpValue1);

      yyResult = pVarWoTypes(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValue> a2 = yyResult.semanticValue();

        yyResult = ps(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$colon(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = ps(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyResult = pNoNewlineType(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type a3 = yyResult.semanticValue();

                yyResult = ps(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pellipses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = ps(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pInitVal(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        com.sun.fortress.useful.Pair<Expr,Boolean> v$el$3 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$3;
                      }
                    }
                    { // Start scope for a4.
                      com.sun.fortress.useful.Pair<Expr,Boolean> a4 = cast(yyOpValue1);

                      Option<Expr> init;
                      if ( a4 != null ) {
                        init = Option.<Expr>some(a4.getA());
                        a2 = NodeFactory.makeLvs(writer, a2, Option.<Modifiers>wrap(a1),
                        Option.<TypeOrPattern>some(a3), a4.getB());
                      } else {
                        init = Option.<Expr>none();
                        a2 = NodeFactory.makeLvs(writer, a2, Option.<Modifiers>wrap(a1),
                        Option.<TypeOrPattern>some(a3), false);
                      }
                      yyValue = ExprFactory.makeLocalVarDecl(createSpan(yyStart,yyCount), a2,
                      init);

                      return new SemanticValue(yyValue, yyOption1, yyError);
                    } // End scope for a4.
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pNoNewlineTupleType(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TupleType a3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = ps(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pInitVal(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    com.sun.fortress.useful.Pair<Expr,Boolean> v$el$4 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                }
                { // Start scope for a4.
                  com.sun.fortress.useful.Pair<Expr,Boolean> a4 = cast(yyOpValue1);

                  Span span = createSpan(yyStart,yyCount);
                  List<Type> tys = a3.getElements();
                  if (a2.size() != tys.size())
                  log(span, "Mismatched numbers of variables and types.");
                  Option<Expr> init;
                  if ( a4 != null ) {
                    init = Option.<Expr>some(a4.getA());
                    a2 = NodeFactory.makeLvs(writer, a2, Option.<Modifiers>wrap(a1), tys, a4.getB());
                  } else {
                    init = Option.<Expr>none();
                    a2 = NodeFactory.makeLvs(writer, a2, Option.<Modifiers>wrap(a1), tys, false);
                  }
                  yyValue = ExprFactory.makeLocalVarDecl(span, a2, init);

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for a4.
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.VarMayTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalDecl$VarMayTypes(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyRepetition1;
    boolean      yyRepeated1;
    Pair<LValue> yyRepValue1;
    List<LValue> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalDecl$VarMayType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LValue a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pLocalDecl$VarMayType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LValue a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pLocalDecl$VarMayType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    LValue v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = new Pair<LValue>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<LValue> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.VarMayType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalDecl$VarMayType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fLocalDecl$VarMayType) 
      yyColumn.chunk23.fLocalDecl$VarMayType = pLocalDecl$VarMayType$1(yyStart);
    return yyColumn.chunk23.fLocalDecl$VarMayType;
  }

  /** Actually parse LocalDecl.VarMayType. */
  private Result pLocalDecl$VarMayType$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    LValue     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = ps(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = ps(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyResult = pNoNewlinePattern(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pattern a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeLValue(createSpan(yyStart,yyCount),a1,a2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyResult = pNoNewlineType(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeLValue(createSpan(yyStart,yyCount),a1,a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }

      // Nested alternative 2.

      yyValue = NodeFactory.makeLValue(createSpan(yyStart,yyCount),a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.VarWoTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarWoTypes(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fVarWoTypes) 
      yyColumn.chunk23.fVarWoTypes = pVarWoTypes$1(yyStart);
    return yyColumn.chunk23.fVarWoTypes;
  }

  /** Actually parse LocalDecl.VarWoTypes. */
  private Result pVarWoTypes$1(final int yyStart) throws IOException {
    Result       yyResult;
    List<LValue> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVarWoType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LValue a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pVarWoType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LValue a1 = yyResult.semanticValue();

          yyResult = pVarWoTypes$$Plus1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<LValue> a2s = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.VarWoTypes$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarWoTypes$$Plus1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fVarWoTypes$$Plus1) 
      yyColumn.chunk23.fVarWoTypes$$Plus1 = pVarWoTypes$$Plus1$1(yyStart);
    return yyColumn.chunk23.fVarWoTypes$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.VarWoTypes$$Plus1. */
  private Result pVarWoTypes$$Plus1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<LValue> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pVarWoType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            LValue v$el$1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pVarWoTypes$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<LValue> v$2 = yyResult.semanticValue();

              yyValue = new Pair<LValue>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<LValue>(v$el$1);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.VarWoType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarWoType(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fVarWoType) 
      yyColumn.chunk23.fVarWoType = pVarWoType$1(yyStart);
    return yyColumn.chunk23.fVarWoType;
  }

  /** Actually parse LocalDecl.VarWoType. */
  private Result pVarWoType$1(final int yyStart) throws IOException {
    Result     yyResult;
    LValue     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeLValue(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pUnpasting(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      log(span, "Matrix unpasting is not yet implemented.");
      yyValue = NodeFactory.makeLValue(span, NodeFactory.makeId(span, "_"));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.NoNewlineVarWTypeOrPatterns.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineVarWTypeOrPatterns(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyRepetition1;
    boolean      yyRepeated1;
    Pair<LValue> yyRepValue1;
    List<LValue> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineVarWTypeOrPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LValue a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineVarWTypeOrPattern(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LValue a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pNoNewlineVarWTypeOrPattern(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    LValue v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = new Pair<LValue>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<LValue> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.NoNewlineVarWTypeOrPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineVarWTypeOrPattern(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fNoNewlineVarWTypeOrPattern) 
      yyColumn.chunk23.fNoNewlineVarWTypeOrPattern = pNoNewlineVarWTypeOrPattern$1(yyStart);
    return yyColumn.chunk23.fNoNewlineVarWTypeOrPattern;
  }

  /** Actually parse LocalDecl.NoNewlineVarWTypeOrPattern. */
  private Result pNoNewlineVarWTypeOrPattern$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    LValue     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineIsTypeOrPattern(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TypeOrPattern a2 = yyResult.semanticValue();

          yyValue = NodeFactory.makeLValue(createSpan(yyStart,yyCount),a1,a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.NoNewlineIsTypeOrPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineIsTypeOrPattern(final int yyStart) 
    throws IOException {

    Result        yyResult;
    TypeOrPattern yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$colon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlinePattern(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineType(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.Unpasting.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpasting(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fUnpasting) 
      yyColumn.chunk23.fUnpasting = pUnpasting$1(yyStart);
    return yyColumn.chunk23.fUnpasting;
  }

  /** Actually parse LocalDecl.Unpasting. */
  private Result pUnpasting$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$opensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnpastingElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if (']' == yyC) {
              yyIndex = yyResult.index + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"]\" expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.UnpastingElems.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpastingElems(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fUnpastingElems) 
      yyColumn.chunk23.fUnpastingElems = pUnpastingElems$1(yyStart);
    return yyColumn.chunk23.fUnpastingElems;
  }

  /** Actually parse LocalDecl.UnpastingElems. */
  private Result pUnpastingElems$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnpastingElem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pRectSeparator(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnpastingElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyValue = null;

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.UnpastingElem.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpastingElem(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyResult = pSymbol$opensquare(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pUnpastingDim(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if (']' == yyC) {
                yyIndex = yyResult.index + 1;

                yyOption1  = yyIndex;
              } else {
                yyError = yyError.select("\"]\" expected", yyBase);
              }
            }
          }
        }
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Alternative 2.

    yyResult = pUnpasting(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.UnpastingDim.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpastingDim(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExtentRange(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcross(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExtentRange(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyValue = null;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.CaseClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClause(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fCaseClause) 
      yyColumn.chunk23.fCaseClause = pCaseClause$1(yyStart);
    return yyColumn.chunk23.fCaseClause;
  }

  /** Actually parse LocalDecl.CaseClause. */
  private Result pCaseClause$1(final int yyStart) throws IOException {
    Result     yyResult;
    CaseClause yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeCaseClause(createSpan(yyStart,yyCount), a1, a2,
              Option.<FunctionalRef>none());

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared59(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s = yyResult.semanticValue();

      if (!FORTRESS_KEYWORDS.contains(s)) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared59.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.id$$Choice1 
   * and com.sun.fortress.parser.templateparser.TemplateParser.reserved$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared59(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidstart(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      while (true) {

        yyResult = pidrest(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idstart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidstart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          (('\u3400' <= yyC) && (yyC <= '\u4db5')) ||
          (('\u4e00' <= yyC) && (yyC <= '\u9fbb')) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          (('\uac00' <= yyC) && (yyC <= '\ud7a3')) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\uded6')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idstart expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idrest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidrest(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          (('\u3400' <= yyC) && (yyC <= '\u4db5')) ||
          (('\u4e00' <= yyC) && (yyC <= '\u9fbb')) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          (('\uac00' <= yyC) && (yyC <= '\ud7a3')) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\uded6')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\'':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u2032':
      case '\u2033':
      case '\u2034':
      case '\u2035':
      case '\u2036':
      case '\u2037':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          ('_' == yyC) ||
          ('\u00ad' == yyC) ||
          (('\u0300' <= yyC) && (yyC <= '\u036f')) ||
          (('\u0483' <= yyC) && (yyC <= '\u0486')) ||
          (('\u0591' <= yyC) && (yyC <= '\u05bd')) ||
          ('\u05bf' == yyC) ||
          (('\u05c1' <= yyC) && (yyC <= '\u05c2')) ||
          (('\u05c4' <= yyC) && (yyC <= '\u05c5')) ||
          ('\u05c7' == yyC) ||
          (('\u0600' <= yyC) && (yyC <= '\u0603')) ||
          (('\u0610' <= yyC) && (yyC <= '\u0615')) ||
          (('\u064b' <= yyC) && (yyC <= '\u065e')) ||
          (('\u0660' <= yyC) && (yyC <= '\u0669')) ||
          ('\u0670' == yyC) ||
          (('\u06d6' <= yyC) && (yyC <= '\u06dd')) ||
          (('\u06df' <= yyC) && (yyC <= '\u06e4')) ||
          (('\u06e7' <= yyC) && (yyC <= '\u06e8')) ||
          (('\u06ea' <= yyC) && (yyC <= '\u06ed')) ||
          (('\u06f0' <= yyC) && (yyC <= '\u06f9')) ||
          ('\u070f' == yyC) ||
          ('\u0711' == yyC) ||
          (('\u0730' <= yyC) && (yyC <= '\u074a')) ||
          (('\u07a6' <= yyC) && (yyC <= '\u07b0')) ||
          (('\u07c0' <= yyC) && (yyC <= '\u07c9')) ||
          (('\u07eb' <= yyC) && (yyC <= '\u07f3')) ||
          (('\u0901' <= yyC) && (yyC <= '\u0903')) ||
          ('\u093c' == yyC) ||
          (('\u093e' <= yyC) && (yyC <= '\u094d')) ||
          (('\u0951' <= yyC) && (yyC <= '\u0954')) ||
          (('\u0962' <= yyC) && (yyC <= '\u0963')) ||
          (('\u0966' <= yyC) && (yyC <= '\u096f')) ||
          (('\u0981' <= yyC) && (yyC <= '\u0983')) ||
          ('\u09bc' == yyC) ||
          (('\u09be' <= yyC) && (yyC <= '\u09c4')) ||
          (('\u09c7' <= yyC) && (yyC <= '\u09c8')) ||
          (('\u09cb' <= yyC) && (yyC <= '\u09cd')) ||
          ('\u09d7' == yyC) ||
          (('\u09e2' <= yyC) && (yyC <= '\u09e3')) ||
          (('\u09e6' <= yyC) && (yyC <= '\u09ef')) ||
          (('\u0a01' <= yyC) && (yyC <= '\u0a03')) ||
          ('\u0a3c' == yyC) ||
          (('\u0a3e' <= yyC) && (yyC <= '\u0a42')) ||
          (('\u0a47' <= yyC) && (yyC <= '\u0a48')) ||
          (('\u0a4b' <= yyC) && (yyC <= '\u0a4d')) ||
          (('\u0a66' <= yyC) && (yyC <= '\u0a71')) ||
          (('\u0a81' <= yyC) && (yyC <= '\u0a83')) ||
          ('\u0abc' == yyC) ||
          (('\u0abe' <= yyC) && (yyC <= '\u0ac5')) ||
          (('\u0ac7' <= yyC) && (yyC <= '\u0ac9')) ||
          (('\u0acb' <= yyC) && (yyC <= '\u0acd')) ||
          (('\u0ae2' <= yyC) && (yyC <= '\u0ae3')) ||
          (('\u0ae6' <= yyC) && (yyC <= '\u0aef')) ||
          (('\u0b01' <= yyC) && (yyC <= '\u0b03')) ||
          ('\u0b3c' == yyC) ||
          (('\u0b3e' <= yyC) && (yyC <= '\u0b43')) ||
          (('\u0b47' <= yyC) && (yyC <= '\u0b48')) ||
          (('\u0b4b' <= yyC) && (yyC <= '\u0b4d')) ||
          (('\u0b56' <= yyC) && (yyC <= '\u0b57')) ||
          (('\u0b66' <= yyC) && (yyC <= '\u0b6f')) ||
          ('\u0b82' == yyC) ||
          (('\u0bbe' <= yyC) && (yyC <= '\u0bc2')) ||
          (('\u0bc6' <= yyC) && (yyC <= '\u0bc8')) ||
          (('\u0bca' <= yyC) && (yyC <= '\u0bcd')) ||
          ('\u0bd7' == yyC) ||
          (('\u0be6' <= yyC) && (yyC <= '\u0bef')) ||
          (('\u0c01' <= yyC) && (yyC <= '\u0c03')) ||
          (('\u0c3e' <= yyC) && (yyC <= '\u0c44')) ||
          (('\u0c46' <= yyC) && (yyC <= '\u0c48')) ||
          (('\u0c4a' <= yyC) && (yyC <= '\u0c4d')) ||
          (('\u0c55' <= yyC) && (yyC <= '\u0c56')) ||
          (('\u0c66' <= yyC) && (yyC <= '\u0c6f')) ||
          (('\u0c82' <= yyC) && (yyC <= '\u0c83')) ||
          ('\u0cbc' == yyC) ||
          (('\u0cbe' <= yyC) && (yyC <= '\u0cc4')) ||
          (('\u0cc6' <= yyC) && (yyC <= '\u0cc8')) ||
          (('\u0cca' <= yyC) && (yyC <= '\u0ccd')) ||
          (('\u0cd5' <= yyC) && (yyC <= '\u0cd6')) ||
          (('\u0ce2' <= yyC) && (yyC <= '\u0ce3')) ||
          (('\u0ce6' <= yyC) && (yyC <= '\u0cef')) ||
          (('\u0d02' <= yyC) && (yyC <= '\u0d03')) ||
          (('\u0d3e' <= yyC) && (yyC <= '\u0d43')) ||
          (('\u0d46' <= yyC) && (yyC <= '\u0d48')) ||
          (('\u0d4a' <= yyC) && (yyC <= '\u0d4d')) ||
          ('\u0d57' == yyC) ||
          (('\u0d66' <= yyC) && (yyC <= '\u0d6f')) ||
          (('\u0d82' <= yyC) && (yyC <= '\u0d83')) ||
          ('\u0dca' == yyC) ||
          (('\u0dcf' <= yyC) && (yyC <= '\u0dd4')) ||
          ('\u0dd6' == yyC) ||
          (('\u0dd8' <= yyC) && (yyC <= '\u0ddf')) ||
          (('\u0df2' <= yyC) && (yyC <= '\u0df3')) ||
          ('\u0e31' == yyC) ||
          (('\u0e34' <= yyC) && (yyC <= '\u0e3a')) ||
          (('\u0e47' <= yyC) && (yyC <= '\u0e4e')) ||
          (('\u0e50' <= yyC) && (yyC <= '\u0e59')) ||
          ('\u0eb1' == yyC) ||
          (('\u0eb4' <= yyC) && (yyC <= '\u0eb9')) ||
          (('\u0ebb' <= yyC) && (yyC <= '\u0ebc')) ||
          (('\u0ec8' <= yyC) && (yyC <= '\u0ecd')) ||
          (('\u0ed0' <= yyC) && (yyC <= '\u0ed9')) ||
          (('\u0f18' <= yyC) && (yyC <= '\u0f19')) ||
          (('\u0f20' <= yyC) && (yyC <= '\u0f29')) ||
          ('\u0f35' == yyC) ||
          ('\u0f37' == yyC) ||
          ('\u0f39' == yyC) ||
          (('\u0f3e' <= yyC) && (yyC <= '\u0f3f')) ||
          (('\u0f71' <= yyC) && (yyC <= '\u0f84')) ||
          (('\u0f86' <= yyC) && (yyC <= '\u0f87')) ||
          (('\u0f90' <= yyC) && (yyC <= '\u0f97')) ||
          (('\u0f99' <= yyC) && (yyC <= '\u0fbc')) ||
          ('\u0fc6' == yyC) ||
          (('\u102c' <= yyC) && (yyC <= '\u1032')) ||
          (('\u1036' <= yyC) && (yyC <= '\u1039')) ||
          (('\u1040' <= yyC) && (yyC <= '\u1049')) ||
          (('\u1056' <= yyC) && (yyC <= '\u1059')) ||
          ('\u135f' == yyC) ||
          (('\u1712' <= yyC) && (yyC <= '\u1714')) ||
          (('\u1732' <= yyC) && (yyC <= '\u1734')) ||
          (('\u1752' <= yyC) && (yyC <= '\u1753')) ||
          (('\u1772' <= yyC) && (yyC <= '\u1773')) ||
          (('\u17b4' <= yyC) && (yyC <= '\u17d3')) ||
          ('\u17dd' == yyC) ||
          (('\u17e0' <= yyC) && (yyC <= '\u17e9')) ||
          (('\u180b' <= yyC) && (yyC <= '\u180d')) ||
          (('\u1810' <= yyC) && (yyC <= '\u1819')) ||
          ('\u18a9' == yyC) ||
          (('\u1920' <= yyC) && (yyC <= '\u192b')) ||
          (('\u1930' <= yyC) && (yyC <= '\u193b')) ||
          (('\u1946' <= yyC) && (yyC <= '\u194f')) ||
          (('\u19b0' <= yyC) && (yyC <= '\u19c0')) ||
          (('\u19c8' <= yyC) && (yyC <= '\u19c9')) ||
          (('\u19d0' <= yyC) && (yyC <= '\u19d9')) ||
          (('\u1a17' <= yyC) && (yyC <= '\u1a1b')) ||
          (('\u1b00' <= yyC) && (yyC <= '\u1b04')) ||
          (('\u1b34' <= yyC) && (yyC <= '\u1b44')) ||
          (('\u1b50' <= yyC) && (yyC <= '\u1b59')) ||
          (('\u1b6b' <= yyC) && (yyC <= '\u1b73')) ||
          (('\u1dc0' <= yyC) && (yyC <= '\u1dca')) ||
          (('\u1dfe' <= yyC) && (yyC <= '\u1dff')) ||
          (('\u200b' <= yyC) && (yyC <= '\u200f')) ||
          (('\u202a' <= yyC) && (yyC <= '\u202e')) ||
          (('\u2060' <= yyC) && (yyC <= '\u2063')) ||
          (('\u206a' <= yyC) && (yyC <= '\u206f')) ||
          (('\u20d0' <= yyC) && (yyC <= '\u20dc')) ||
          ('\u20e1' == yyC) ||
          (('\u20e5' <= yyC) && (yyC <= '\u20ef')) ||
          (('\u302a' <= yyC) && (yyC <= '\u302f')) ||
          (('\u3099' <= yyC) && (yyC <= '\u309a')) ||
          ('\ua802' == yyC) ||
          ('\ua806' == yyC) ||
          ('\ua80b' == yyC) ||
          (('\ua823' <= yyC) && (yyC <= '\ua827')) ||
          ('\ufb1e' == yyC) ||
          (('\ufe00' <= yyC) && (yyC <= '\ufe0f')) ||
          (('\ufe20' <= yyC) && (yyC <= '\ufe23')) ||
          ('\ufeff' == yyC) ||
          (('\uff10' <= yyC) && (yyC <= '\uff19')) ||
          (('\ufff9' <= yyC) && (yyC <= '\ufffb'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\udca0':
            case '\udca1':
            case '\udca2':
            case '\udca3':
            case '\udca4':
            case '\udca5':
            case '\udca6':
            case '\udca7':
            case '\udca8':
            case '\udca9':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\ude01':
            case '\ude02':
            case '\ude03':
            case '\ude05':
            case '\ude06':
            case '\ude0c':
            case '\ude0d':
            case '\ude0e':
            case '\ude0f':
            case '\ude38':
            case '\ude39':
            case '\ude3a':
            case '\ude3f':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud834':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udd65' <= yyC) && (yyC <= '\udd69')) ||
                (('\udd6d' <= yyC) && (yyC <= '\udd82')) ||
                (('\udd85' <= yyC) && (yyC <= '\udd8b')) ||
                (('\uddaa' <= yyC) && (yyC <= '\uddad')) ||
                (('\ude42' <= yyC) && (yyC <= '\ude44'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udfce' <= yyC) && (yyC <= '\udfff')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\udb40':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc01' == yyC) ||
                (('\udc20' <= yyC) && (yyC <= '\udc7f')) ||
                (('\udd00' <= yyC) && (yyC <= '\uddef'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idrest expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.IdText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdText(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      if (NodeUtil.validId(a1)) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("id text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.reserved.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result preserved(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared59(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s = yyResult.semanticValue();

      if (FORTRESS_KEYWORDS.contains(s)) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("reserved expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Reserved.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pReserved(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fReserved) 
      yyColumn.chunk23.fReserved = pReserved$1(yyStart);
    return yyColumn.chunk23.fReserved;
  }

  /** Actually parse Identifier.Reserved. */
  private Result pReserved$1(final int yyStart) throws IOException {
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = preserved(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeId(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pId(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fId) yyColumn.chunk24.fId = pId$1(yyStart);
    return yyColumn.chunk24.fId;
  }

  /** Actually parse Identifier.Id. */
  private Result pId$1(final int yyStart) throws IOException {
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNameGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIdGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <FIRST>.

    yyResult = pIdText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeId(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.IdOrOpName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdOrOpName(final int yyStart) throws IOException {
    Result     yyResult;
    IdOrOp     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pOpName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpUnknown(createSpan(yyStart, yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.BindId.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindId(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fBindId) 
      yyColumn.chunk24.fBindId = pBindId$1(yyStart);
    return yyColumn.chunk24.fBindId;
  }

  /** Actually parse Identifier.BindId. */
  private Result pBindId$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = "_";

      yyValue = NodeFactory.makeId(createSpan(yyStart,yyCount), a1);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("bind id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.BindIdList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindIdList(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fBindIdList) 
      yyColumn.chunk24.fBindIdList = pBindIdList$1(yyStart);
    return yyColumn.chunk24.fBindIdList;
  }

  /** Actually parse Identifier.BindIdList. */
  private Result pBindIdList$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pBindIdList$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Id> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pBindIdList$$Plus2(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Id> a2s = yyResult.semanticValue();

        log(createSpan(yyStart,yyCount), "Missing comma.");
        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyValue = Useful.list(a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.BindIdList$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindIdList$$Plus1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fBindIdList$$Plus1) 
      yyColumn.chunk24.fBindIdList$$Plus1 = pBindIdList$$Plus1$1(yyStart);
    return yyColumn.chunk24.fBindIdList$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.BindIdList$$Plus1. */
  private Result pBindIdList$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBindId(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Id v$el$1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pBindIdList$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Id> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Id>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<Id>(v$el$1);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.BindIdList$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindIdList$$Plus2(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fBindIdList$$Plus2) 
      yyColumn.chunk24.fBindIdList$$Plus2 = pBindIdList$$Plus2$1(yyStart);
    return yyColumn.chunk24.fBindIdList$$Plus2;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.BindIdList$$Plus2. */
  private Result pBindIdList$$Plus2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pIdentifier$commaOrNot(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBindId(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Id v$el$3 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pBindIdList$$Plus2(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Id> v$4 = yyResult.semanticValue();

              yyValue = new Pair<Id>(v$el$3, v$4);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<Id>(v$el$3);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.BindIdOrBindIdTuple.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindIdOrBindIdTuple(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fBindIdOrBindIdTuple) 
      yyColumn.chunk24.fBindIdOrBindIdTuple = pBindIdOrBindIdTuple$1(yyStart);
    return yyColumn.chunk24.fBindIdOrBindIdTuple;
  }

  /** Actually parse Identifier.BindIdOrBindIdTuple. */
  private Result pBindIdOrBindIdTuple$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindIdOrBindIdTupleGap(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <FIRST>.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBindId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pBindIdList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Id> a2s = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyValue = Useful.cons(a1, a2s);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.commaOrNot.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier$commaOrNot(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.SimpleName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleName(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fSimpleName) 
      yyColumn.chunk24.fSimpleName = pSimpleName$1(yyStart);
    return yyColumn.chunk24.fSimpleName;
  }

  /** Actually parse Identifier.SimpleName. */
  private Result pSimpleName$1(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyOption1;
    String                yyOpValue1;
    IdOrOpOrAnonymousName yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for big.
        String big = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = p$$Shared56(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op a1 = yyResult.semanticValue();

            if (big != null) yyValue = NodeFactory.makeBig(a1);
            else yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyResult = pEncloserPair(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op a1 = yyResult.semanticValue();

            if (big != null) yyValue = NodeFactory.makeBig(a1);
            else yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for big.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idOrKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidOrKeyword(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fidOrKeyword) 
      yyColumn.chunk24.fidOrKeyword = pidOrKeyword$1(yyStart);
    return yyColumn.chunk24.fidOrKeyword;
  }

  /** Actually parse Identifier.idOrKeyword. */
  private Result pidOrKeyword$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidstart(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pidOrKeyword$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        if (true) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("id or keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.idOrKeyword$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidOrKeyword$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fidOrKeyword$$Star1) 
      yyColumn.chunk24.fidOrKeyword$$Star1 = pidOrKeyword$$Star1$1(yyStart);
    return yyColumn.chunk24.fidOrKeyword$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.idOrKeyword$$Star1. */
  private Result pidOrKeyword$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidrest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pidOrKeyword$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.APIName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAPIName(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fAPIName) 
      yyColumn.chunk24.fAPIName = pAPIName$1(yyStart);
    return yyColumn.chunk24.fAPIName;
  }

  /** Actually parse Identifier.APIName. */
  private Result pAPIName$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    APIName    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidOrKeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyPredResult = pw(yyChoice1);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyPredResult = pellipses(yyPredResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          Span span = createSpan(yyStart,yyCount);
          Id bogusId = NodeFactory.bogusId(span);
          if (FORTRESS_KEYWORDS.contains(a1)) {
            log(span, a1 + " is a Fortress keyword.");
            yyValue = NodeFactory.makeAPIName(span, bogusId);
          } else if (NodeUtil.validId(a1)) {
            yyValue = NodeFactory.makeAPIName(span, NodeFactory.makeId(span, a1));
          } else if (NodeUtil.validOp(a1)) {
            log(span, a1 + " is not a valid Fortress identifier.");
            yyValue = NodeFactory.makeAPIName(span, bogusId);
          } else {
            log(span, a1 + " is not a valid Fortress identifier.");
            yyValue = NodeFactory.makeAPIName(span, bogusId);
          }

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = pAPIName$$Star1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> a2s = yyResult.semanticValue();

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyPredResult = pw(yyChoice2);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pellipses(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount);
            List<Id> ids = new ArrayList<Id>(a2s.list().size()+1);
            ids.add(NodeFactory.makeId(span, a1));
            for ( String name : a2s.list() ) ids.add(NodeFactory.makeId(span, name));
            Id bogusId = NodeFactory.bogusId(span);
            for (Id _id : ids) {
              String id = _id.getText();
              if (FORTRESS_KEYWORDS.contains(id))
              log(span, id + " is a Fortress keyword.");
              else if (NodeUtil.validOp(id))
              log(span, id + " is not a valid Fortress identifier.");
              else if (!NodeUtil.validId(id))
              log(span, id + " is not a valid Fortress identifier.");
            }
            yyValue = NodeFactory.makeAPIName(span, ids);

            return new SemanticValue(yyValue, yyChoice2, yyError);
          }
        }

        // Nested alternative 2.

        Span span = createSpan(yyStart,yyCount);
        List<Id> ids = new ArrayList<Id>(a2s.list().size()+1);
        ids.add(NodeFactory.makeId(span, a1));
        for ( String name : a2s.list() ) ids.add(NodeFactory.makeId(span, name));
        Id bogusId = NodeFactory.bogusId(span);
        for (Id _id : ids) {
          String id = _id.getText();
          if (FORTRESS_KEYWORDS.contains(id))
          log(span, id + " is a Fortress keyword.");
          else if (NodeUtil.validOp(id))
          log(span, id + " is not a valid Fortress identifier.");
          else if (!NodeUtil.validId(id))
          log(span, id + " is not a valid Fortress identifier.");
        }
        yyValue = NodeFactory.makeAPIName(span, ids);

        return new SemanticValue(yyValue, yyChoice2, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.APIName$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAPIName$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fAPIName$$Star1) 
      yyColumn.chunk25.fAPIName$$Star1 = pAPIName$$Star1$1(yyStart);
    return yyColumn.chunk25.fAPIName$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.APIName$$Star1. */
  private Result pAPIName$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pidOrKeyword(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyResult = pAPIName$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<String> v$2 = yyResult.semanticValue();

          yyValue = new Pair<String>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.QualifiedName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedName(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fQualifiedName) 
      yyColumn.chunk25.fQualifiedName = pQualifiedName$1(yyStart);
    return yyColumn.chunk25.fQualifiedName;
  }

  /** Actually parse Identifier.QualifiedName. */
  private Result pQualifiedName$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyPredResult = pw(yyResult.index);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyPredResult = pellipses(yyPredResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pQualifiedName$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Id> a2s = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyPredResult = pw(yyChoice1);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pellipses(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyValue = NodeFactory.makeId(createSpan(yyStart,yyCount),a1,a2s.list());

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }

        // Nested alternative 2.

        yyValue = NodeFactory.makeId(createSpan(yyStart,yyCount),a1,a2s.list());

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.QualifiedName$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedName$$Star1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fQualifiedName$$Star1) 
      yyColumn.chunk25.fQualifiedName$$Star1 = pQualifiedName$$Star1$1(yyStart);
    return yyColumn.chunk25.fQualifiedName$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.QualifiedName$$Star1. */
  private Result pQualifiedName$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id v$el$1 = yyResult.semanticValue();

        yyResult = pQualifiedName$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Id>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Encloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloser(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fEncloser) 
      yyColumn.chunk25.fEncloser = pEncloser$1(yyStart);
    return yyColumn.chunk25.fEncloser;
  }

  /** Actually parse Symbol.Encloser. */
  private Result pEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pencloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.LeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLeftEncloser(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fLeftEncloser) 
      yyColumn.chunk25.fLeftEncloser = pLeftEncloser$1(yyStart);
    return yyColumn.chunk25.fLeftEncloser;
  }

  /** Actually parse Symbol.LeftEncloser. */
  private Result pLeftEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = popendoublesquare(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pleftEncloser(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a1 = yyResult.semanticValue();

        yyValue = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("left encloser expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.RightEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRightEncloser(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fRightEncloser) 
      yyColumn.chunk25.fRightEncloser = pRightEncloser$1(yyStart);
    return yyColumn.chunk25.fRightEncloser;
  }

  /** Actually parse Symbol.RightEncloser. */
  private Result pRightEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ExponentOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponentOp(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fExponentOp) 
      yyColumn.chunk25.fExponentOp = pExponentOp$1(yyStart);
    return yyColumn.chunk25.fExponentOp;
  }

  /** Actually parse Symbol.ExponentOp. */
  private Result pExponentOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpPostfix(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.EncloserPair.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloserPair(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fEncloserPair) 
      yyColumn.chunk25.fEncloserPair = pEncloserPair$1(yyStart);
    return yyColumn.chunk25.fEncloserPair;
  }

  /** Actually parse Symbol.EncloserPair. */
  private Result pEncloserPair$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloserPair$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDOT(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEncloserPair$$Choice2(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          if (! PrecedenceMap.ONLY.matchedBrackets(a1.getText(), a2.getText()))
          log(NodeUtil.getSpan(a2), "Mismatched Enclosers: " + a1 + " and " + a2);
          yyValue = NodeFactory.makeEnclosing(createSpan(yyStart,yyCount),
          a1.getText(), a2.getText());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.EncloserPair$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloserPair$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.EncloserPair$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloserPair$$Choice2(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol$bar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyPredIndex;
    Result     yyPredResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyPredIndex = yyStart + 1;

      yyPredResult = pwr(yyPredIndex);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyPredResult = pNoNewlineExpr$GeneratorClauseList(yyPredResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pclosingComprehension(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyC = character(yyStart);
            if ('|' == yyC) {
              yyIndex = yyStart + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("bar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closingComprehension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosingComprehension(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = prightEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '}':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case '|':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('>' == yyC) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
          break;

        case '\u27e9':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }
    }

    // Alternative 2.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pArrayComprehensionClause(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (']' == yyC) {
        yyIndex = yyResult.index + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\"]\" expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("closing comprehension expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.sd.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psd(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyC = character(yyOption1);
    if (-1 != yyC) {
      yyIndex = yyOption1 + 1;

      switch (yyC) {
      case '*':
      case '.':
        {
          yyOption1  = yyIndex;
        }

      default:
        /* No match. */
      }
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyOption1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbars(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = psd(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('|' == yyC) {
            yyIndex = yyResult.index + 1;

            yyRepetition1 = yyIndex;
            continue;
          } else {
            yyError = yyError.select("\"|\" expected", yyBase);
          }
        }
        break;
      }

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("bars expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.slashes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslashes(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '/':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyResult = psd(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if ('/' == yyC) {
                yyIndex = yyResult.index + 1;

                yyRepetition1 = yyIndex;
                continue;
              } else {
                yyError = yyError.select("\"/\" expected", yyBase);
              }
            }
            break;
          }

          yyValue = null;

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }

      case '\\':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyResult = psd(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if ('\\' == yyC) {
                yyIndex = yyResult.index + 1;

                yyRepetition1 = yyIndex;
                continue;
              } else {
                yyError = yyError.select("\"\\\\\" expected", yyBase);
              }
            }
            break;
          }

          yyValue = null;

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("slashes expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.lesses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plesses(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = psd(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('<' == yyC) {
            yyIndex = yyResult.index + 1;

            yyRepetition1 = yyIndex;
            continue;
          } else {
            yyError = yyError.select("\"<\" expected", yyBase);
          }
        }
        break;
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("lesses expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.greaters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgreaters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = psd(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('>' == yyC) {
            yyIndex = yyResult.index + 1;

            yyRepetition1 = yyIndex;
            continue;
          } else {
            yyError = yyError.select("\">\" expected", yyBase);
          }
        }
        break;
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("greaters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.encloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pencloser(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pSymbol$bar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pbars(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyPredMatched = false;

        yyPredResult = pencloser$$Choice1(yyResult.index);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("encloser expected", yyStart);
        }
      }
    } else {
      yyError = yyError.select("encloser expected", yyStart);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\u2016' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "\u2016";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\u2af4' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "\u2af4";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.encloser$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pencloser$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
      case '.':
      case '/':
      case '>':
      case '\\':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('>' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.leftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftEncloser(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloserMulti(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (PrecedenceMap.ONLY.isLeft(yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '|' && PrecedenceMap.ONLY.isLeft(""+c)) {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("left encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.leftEncloserMulti.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftEncloserMulti(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '(':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('.' == yyC) {

              final int yyChoice1 = yyIndex;

              // Nested alternative 1.

              yyRepetition1 = yyChoice1;
              yyRepeated1   = false;
              while (true) {

                yyBase = yyRepetition1;
                yyC    = character(yyBase);
                if ('/' == yyC) {
                  yyIndex = yyRepetition1 + 1;

                  yyRepetition1 = yyIndex;
                  yyRepeated1   = true;
                  continue;
                } else {
                  yyError = yyError.select("\"/\" expected", yyBase);
                }
                break;
              }

              if (yyRepeated1) {

                yyValue = difference(yyStart, yyRepetition1);

                return new SemanticValue(yyValue, yyRepetition1, yyError);
              }

              // Nested alternative 2.

              yyRepetition1 = yyChoice1;
              yyRepeated1   = false;
              while (true) {

                yyBase = yyRepetition1;
                yyC    = character(yyBase);
                if ('\\' == yyC) {
                  yyIndex = yyRepetition1 + 1;

                  yyRepetition1 = yyIndex;
                  yyRepeated1   = true;
                  continue;
                } else {
                  yyError = yyError.select("\"\\\\\" expected", yyBase);
                }
                break;
              }

              if (yyRepeated1) {

                yyValue = difference(yyStart, yyRepetition1);

                return new SemanticValue(yyValue, yyRepetition1, yyError);
              }
            }
          }
        }
        break;

      case '[':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('/' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('\\' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('/' == yyC) {

                      final int yyChoice2 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice2);
                      if (-1 != yyC) {
                        yyIndex = yyChoice2 + 1;
                        if ('\\' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('/' == yyC) {

                              yyValue = "[/\\/\\/";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }

                      // Nested alternative 2.

                      yyValue = "[/\\/";

                      return new SemanticValue(yyValue, yyChoice2, yyError);
                    }
                  }
                }
              }
            }
          }

          // Nested alternative 2.

          yyResult = psd(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pslashes(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = difference(yyStart, yyResult.index);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      case '{':
        {
          yyResult = psd(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pslashes(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = difference(yyStart, yyResult.index);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = plesses(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '/':
            {
              yyRepetition1 = yyIndex;
              while (true) {

                yyResult = psd(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyBase = yyResult.index;
                  yyC    = character(yyBase);
                  if ('/' == yyC) {
                    yyIndex = yyResult.index + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  } else {
                    yyError = yyError.select("\"/\" expected", yyBase);
                  }
                }
                break;
              }

              yyValue = difference(yyStart, yyRepetition1);

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            }

          case '\\':
            {
              yyRepetition1 = yyIndex;
              while (true) {

                yyResult = psd(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyBase = yyResult.index;
                  yyC    = character(yyBase);
                  if ('\\' == yyC) {
                    yyIndex = yyResult.index + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  } else {
                    yyError = yyError.select("\"\\\\\" expected", yyBase);
                  }
                }
                break;
              }

              yyValue = difference(yyStart, yyRepetition1);

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            }

          case '|':
            {
              yyRepetition1 = yyIndex;
              while (true) {

                yyResult = psd(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyBase = yyResult.index;
                  yyC    = character(yyBase);
                  if ('|' == yyC) {
                    yyIndex = yyResult.index + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  } else {
                    yyError = yyError.select("\"|\" expected", yyBase);
                  }
                }
                break;
              }

              yyValue = difference(yyStart, yyRepetition1);

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            }

          default:
            /* No match. */
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pbars(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pslashes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '{':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('*' == yyC) {

              yyValue = "{*";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '[':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('*' == yyC) {

              yyValue = "[*";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '(':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '(':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('.' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('>' == yyC) {

                        yyValue = "((.>";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
              }
              break;

            case '.':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('<' == yyC) {

                    yyValue = "(.<";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("left encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.rightEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloser(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightEncloserMulti(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (PrecedenceMap.ONLY.isRight(yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '|' && PrecedenceMap.ONLY.isRight(""+c)) {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("right encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.rightEncloserMulti.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloserMulti(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyBase = yyRepetition1;
      yyC    = character(yyBase);
      if ('/' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyRepetition1 = yyIndex;
        yyRepeated1   = true;
        continue;
      } else {
        yyError = yyError.select("\"/\" expected", yyBase);
      }
      break;
    }

    if (yyRepeated1) {

      yyBase = yyRepetition1;
      yyC    = character(yyBase);
      if ('.' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyC = character(yyIndex);
        if (')' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\".)\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\".)\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyBase = yyRepetition1;
      yyC    = character(yyBase);
      if ('\\' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyRepetition1 = yyIndex;
        yyRepeated1   = true;
        continue;
      } else {
        yyError = yyError.select("\"\\\\\" expected", yyBase);
      }
      break;
    }

    if (yyRepeated1) {

      yyBase = yyRepetition1;
      yyC    = character(yyBase);
      if ('.' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyC = character(yyIndex);
        if (')' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\".)\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\".)\" expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pslashes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '>':
            {
              yyRepetition1 = yyIndex;
              while (true) {

                yyResult = psd(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyBase = yyResult.index;
                  yyC    = character(yyBase);
                  if ('>' == yyC) {
                    yyIndex = yyResult.index + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  } else {
                    yyError = yyError.select("\">\" expected", yyBase);
                  }
                }
                break;
              }

              yyValue = difference(yyStart, yyRepetition1);

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            }

          case '|':
            {
              yyRepetition1 = yyIndex;
              while (true) {

                yyResult = psd(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyBase = yyResult.index;
                  yyC    = character(yyBase);
                  if ('|' == yyC) {
                    yyIndex = yyResult.index + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  } else {
                    yyError = yyError.select("\"|\" expected", yyBase);
                  }
                }
                break;
              }

              yyValue = difference(yyStart, yyRepetition1);

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            }

          case ']':
          case '}':
            {
              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pbars(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pgreaters(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case ']':
              {
                yyValue = "*]";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '}':
              {
                yyValue = "*}";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('.' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if (')' == yyC) {

                  yyValue = ">.)";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('.' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if (')' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if (')' == yyC) {

                      yyValue = "<.))";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case '/':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\\' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('/' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '\\':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('/' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if (']' == yyC) {

                                yyValue = "/\\/\\/]";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                        }
                      }
                      break;

                    case ']':
                      {
                        yyValue = "/\\/]";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }

                    default:
                      /* No match. */
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("right encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.exponentOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexponentOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('T' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "^T";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = "^";

      yyResult = p$$Shared60(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("exponent op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.$$Shared60.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.templateparser.TemplateParser.exponentOp$$Choice1, 
   * com.sun.fortress.parser.templateparser.TemplateParser.condOp$$Choice1, 
   * and com.sun.fortress.parser.templateparser.TemplateParser.condOp$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared60(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pencloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.OpName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOpName(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fOpName) 
      yyColumn.chunk25.fOpName = pOpName$1(yyStart);
    return yyColumn.chunk25.fOpName;
  }

  /** Actually parse Symbol.OpName. */
  private Result pOpName$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String opn = yyResult.semanticValue();

      if (NodeUtil.validOp(opn)) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("op name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Op.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOp(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fOp) yyColumn.chunk25.fOp = pOp$1(yyStart);
    return yyColumn.chunk25.fOp;
  }

  /** Actually parse Symbol.Op. */
  private Result pOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyPredMatched = false;

      yyPredResult = pSymbol$Symbol(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = NodeFactory.makeOpUnknown(createSpan(yyStart, yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("op expected", yyStart);
      }
    }

    // Alternative 2.

    yyResult = pSymbols(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      log(createSpan(yyStart,yyCount),
      a1 + " is not a valid operator in Fortress.");
      yyValue = NodeFactory.makeOpUnknown(createSpan(yyStart, yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Op$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcondOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyPredMatched = false;

      yyPredResult = pequalsOp(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("op expected", yyStart);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '=':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('=' == yyC) {

                    yyValue = "===";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '/':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('=' == yyC) {

                    yyValue = "=/=";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = "<=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = ">=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Symbols.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbols(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    boolean      yyRepeated1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pSymbol$Symbol(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<String> a1s = yyRepValue1.reverse();

      StringBuilder buf = new StringBuilder();
      for (String n: a1s.list()) buf.append(n);
      yyValue = buf.toString();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol$Symbol(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = "+";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("symbol expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.condOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcondOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <ErrorProduction>.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (':' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if (':' == yyC) {
          yyIndex = yyIndex + 1;

          log(createSpan(yyStart,yyCount),
          "Three or more colons are not valid operators in Fortress.");
          yyValue = "";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = ":";

      yyResult = p$$Shared60(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pSymbol$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          yyValue = a1+a2+a3;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = p$$Shared60(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pSymbol$colon(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("cond op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.multiOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmultiOp(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fmultiOp) 
      yyColumn.chunk26.fmultiOp = pmultiOp$1(yyStart);
    return yyColumn.chunk26.fmultiOp;
  }

  /** Actually parse Symbol.multiOp. */
  private Result pmultiOp$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('>' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "-/->";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('/' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('-' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "<-/-";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "-->";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "==>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = ">>>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pmapstoOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('<' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "<<<";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 8.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "<->";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 9.

    yyResult = pleftarrowOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "<=>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 11.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "->";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 12.

    yyResult = pdoublerightarrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 13.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">>";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 14.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<<";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 15.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "!!";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 16.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (':' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "::";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 17.

    yyPredMatched = false;

    yyPredResult = prightEncloserMulti(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      final int yyChoice1 = yyStart;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('/' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('/' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('/' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "///";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('/' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('/' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "//";

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"//\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"//\" expected", yyBase);
      }
    } else {
      yyError = yyError.select("multi op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.singleOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psingleOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = psingleOp$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        yyPredMatched = false;

        yyC = character(yyIndex);
        if ('*' == yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          if (PrecedenceMap.ONLY.isOperator("" + a1)) {

            yyValue = "" + a1;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        } else {
          yyError = yyError.select("single op expected", yyStart);
        }
      }
    } else {
      yyError = yyError.select("single op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("single op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.singleOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psingleOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pencloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = prightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pmultiOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '=':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('=' == yyC) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '/':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('=' == yyC) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '>':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\u21d2':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("single op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.op.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pop(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fop) yyColumn.chunk26.fop = pop$1(yyStart);
    return yyColumn.chunk26.fop;
  }

  /** Actually parse Symbol.op. */
  private Result pop$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOpName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pmultiOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.CompoundOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompoundOp(final int yyStart) throws IOException {
    Result        yyResult;
    FunctionalRef yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCompoundOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pequalsOp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = ExprFactory.makeOpRef(NodeFactory.makeOpInfix(createSpan(yyStart, yyCount), a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.CompoundOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompoundOp$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pencloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.doublerightarrow.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdoublerightarrow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "=>";

        yyPredResult = pw(yyIndex);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pBlockElems(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyPredResult = pw(yyPredResult.index);
            yyError      = yyPredResult.select(yyError);
            if (yyPredResult.hasValue()) {

              yyPredResult = pmatch(yyPredResult.index);
              yyError      = yyPredResult.select(yyError);
              if (yyPredResult.hasValue()) {

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("doublerightarrow expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.leftarrow.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftarrow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('-' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\u2190':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("leftarrow expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.caret.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcaret(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('T' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = "^";

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("caret expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("caret expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.colonequals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcolonequals(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ':':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\u2254':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("colonequals expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.equals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pequals(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "=";

      yyPredMatched = false;

      yyPredResult = pop(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("equals expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("equals expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.equalsOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pequalsOp(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("=")) {
      yyValue = "=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("equals op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.semicolon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psemicolon(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = ";";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("semicolon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.one.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pone(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('1' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("one expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.colon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol$colon(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ":";

      yyPredMatched = false;

      yyPredResult = pop(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("colon expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("colon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closecurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosecurly(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('}' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closecurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opencurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popencurly(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pleftEncloserMulti(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pleftEncloser(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("{")) {
        yyValue = "{";

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("opencurly expected", yyStart);
    }

    // Done.
    yyError = yyError.select("opencurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opensquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol$opensquare(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = popendoublesquare(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pleftEncloser(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("[")) {
        yyValue = "[";

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("opensquare expected", yyStart);
    }

    // Done.
    yyError = yyError.select("opensquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ellipses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pellipses(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('.' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('.' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = "...";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ellipses expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.lessthanequal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plessthanequal(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("<=")) {
      yyValue = "<=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("LE")) {
      yyValue = "LE";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("\u2264")) {
      yyValue = "\u2264";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("lessthanequal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.lessthan.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plessthan(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("<")) {
      yyValue = "<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("LT")) {
      yyValue = "LT";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("<")) {
      yyValue = "<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("lessthan expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.greaterthanequal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgreaterthanequal(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue(">=")) {
      yyValue = ">=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("GE")) {
      yyValue = "GE";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("\u2265")) {
      yyValue = "\u2265";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("greaterthanequal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.greaterthan.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgreaterthan(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue(">")) {
      yyValue = ">";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("GT")) {
      yyValue = "GT";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue(">")) {
      yyValue = ">";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("greaterthan expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.OR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOR(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("OR")) {
      yyValue = "OR";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("\u2228")) {
      yyValue = "\u2228";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("OR expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.AND.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAND(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("AND")) {
      yyValue = "AND";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("\u2227")) {
      yyValue = "\u2227";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("AND expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.IMPLIES.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIMPLIES(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("IMPLIES")) {
      yyValue = "IMPLIES";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("\u2192")) {
      yyValue = "\u2192";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("IMPLIES expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.DOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOT(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOpName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("DOT")) {
      yyValue = "DOT";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("\u00b7")) {
      yyValue = "\u00b7";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("DOT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.slash.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslash(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("/")) {
      yyValue = "/";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("slash expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.rightarrow.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightarrow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('>' == yyC) {

              yyValue = "->";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\u2192':
        {
          yyValue = "\u2192";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("rightarrow expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.underscore.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result punderscore(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("underscore expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closedoublesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosedoublesquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\\':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (']' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\u27e7':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("closedoublesquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closeparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcloseparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (')' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closeparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.cross.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcross(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'B':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('Y' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\u2a2f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("cross expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.mapsto.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmapsto(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '|':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('-' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('>' == yyC) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case '\u21a6':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("mapsto expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.match.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmatch(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('>' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\u21d2':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("match expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.minus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pminus(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("-")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("\u2212")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opendoublesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popendoublesquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '[':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\\' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\u27e6':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("opendoublesquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.openparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popenparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pleftEncloser(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if ('(' == yyC) {
        yyIndex = yyStart + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("openparen expected", yyStart);
    }

    // Done.
    yyError = yyError.select("openparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.plus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol$plus(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("+")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("plus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.pound.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ppound(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("#")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("pound expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.comma.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomma(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("comma expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.commaOrNot.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol$commaOrNot(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.dot.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdot(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("dot expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.AssignOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignOp(final int yyStart) throws IOException {
    Result                yyResult;
    Option<FunctionalRef> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcolonequals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Option.<FunctionalRef>none();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pCompoundOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FunctionalRef a1 = yyResult.semanticValue();

      yyValue = Option.<FunctionalRef>some(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.SUM.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSUM(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('S' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('U' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('M' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = NodeFactory.makeOpBig(createSpan(yyStart,yyCount), "BIG +");

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("SUM expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.PROD.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPROD(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('P' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('R' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('O' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('D' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = NodeFactory.makeOpBig(createSpan(yyStart,yyCount),
            "BIG juxtaposition");

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("PROD expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Accumulator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAccumulator(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSUM(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPROD(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pBIG(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAccumulator$$Choice1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a1 = yyResult.semanticValue();

          yyValue = NodeFactory.makeOpBig(createSpan(yyStart,yyCount),
          "BIG " + a1.getText());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.Accumulator$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAccumulator$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ArrayComprehensionClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayComprehensionClause(final int yyStart) 
    throws IOException {

    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fArrayComprehensionClause) 
      yyColumn.chunk26.fArrayComprehensionClause = pArrayComprehensionClause$1(yyStart);
    return yyColumn.chunk26.fArrayComprehensionClause;
  }

  /** Actually parse Symbol.ArrayComprehensionClause. */
  private Result pArrayComprehensionClause$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    ArrayComprehensionClause yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArrayComprehensionLeft(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      com.sun.fortress.useful.Pair<List<Expr>,Expr> a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol$bar(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pwr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$GeneratorClauseList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<GeneratorClause> a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeArrayComprehensionClause(createSpan(yyStart,yyCount),
              a1.getA(), a1.getB(), a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.DoubleStar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDoubleStar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("double star expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('\u001a' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    } else {
      yyError = yyError.select("\"\\u001a\" expected", yyBase);
    }

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if (-1 != yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("end of file expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Whitespace.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhitespace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\f' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = ps(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pWhitespace(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <ErrorProduction1>.

    yyResult = pInvalidSpace$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      log(createSpan(yyStart,yyCount),
      "Tab characters are not allowed in Fortress programs except in comments.");

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <ErrorProduction2>.

    yyResult = pInvalidSpace$$Choice2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      log(createSpan(yyStart,yyCount),
      "An invalid whitespace character is used.");

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pNoNewlineComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('\n' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 8.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('\n' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("whitespace expected", yyStart);
      }
    }

    // Alternative 9.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 10.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('\u2028' <= yyC) && (yyC <= '\u2029')) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 11.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('&' == yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pComment(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("whitespace expected", yyStart);
    }

    // Done.
    yyError = yyError.select("whitespace expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing$Space(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\f' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = ps(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pWhitespace(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <ErrorProduction1>.

    yyResult = pInvalidSpace$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      log(createSpan(yyStart,yyCount),
      "Tab characters are not allowed in Fortress programs except in comments.");

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <ErrorProduction2>.

    yyResult = pInvalidSpace$$Choice2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      log(createSpan(yyStart,yyCount),
      "An invalid whitespace character is used.");

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pNoNewlineComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.InvalidSpace$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInvalidSpace$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\t':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u000b':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("invalid space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.InvalidSpace$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInvalidSpace$$Choice2(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\u001c':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u001d':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u001e':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u001f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("invalid space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Newline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing$Newline(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('\n' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('\n' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("newline expected", yyStart);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('\u2028' <= yyC) && (yyC <= '\u2029')) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 5.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('&' == yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pComment(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("newline expected", yyStart);
    }

    // Done.
    yyError = yyError.select("newline expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Comment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComment(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fComment) 
      yyColumn.chunk26.fComment = pComment$1(yyStart);
    return yyColumn.chunk26.fComment;
  }

  /** Actually parse Spacing.Comment. */
  private Result pComment$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pCommentContents(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyBase = yyChoice1;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyC = character(yyIndex);
            if (')' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"*)\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"*)\" expected", yyBase);
          }

          // Nested alternative 2.

          yyResult = pw(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pEndOfFile(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              log(createSpan(yyStart,yyCount),
              "Unbalanced comment: '*)' is expected.");

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.NoNewlineComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineComment(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fNoNewlineComment) 
      yyColumn.chunk26.fNoNewlineComment = pNoNewlineComment$1(yyStart);
    return yyColumn.chunk26.fNoNewlineComment;
  }

  /** Actually parse Spacing.NoNewlineComment. */
  private Result pNoNewlineComment$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '(':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('*' == yyC) {

              final int yyChoice1 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice1);
              if (-1 != yyC) {
                yyIndex = yyChoice1 + 1;
                if (')' == yyC) {

                  yyResult = pNNCommentContents(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = null;

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pNNCommentContents(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyBase = yyResult.index;
                yyC    = character(yyBase);
                if ('*' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyC = character(yyIndex);
                  if (')' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("\"*)\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"*)\" expected", yyBase);
                }
              }

              // Nested alternative 3.

              yyResult = pCommentContents(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pEndOfFile(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    log(createSpan(yyStart,yyCount),
                    "Unbalanced comment: '*)' is expected.");

                    yyValue = null;

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
        break;

      case '&':
        {
          yyResult = ps(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pComment(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("no newline comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.CommentContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommentContents(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pCommentContent(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.NNCommentContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNNCommentContents(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pNNCommentContent(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.CommentContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommentContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if (')' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyPredMatched = false;

          yyC = character(yyIndex);
          if (')' == yyC) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("comment content expected", yyStart);
          }
        }
        break;

      case '\t':
      case '\n':
      case '\u000b':
      case '\f':
      case '\r':
      case '\u001c':
      case '\u001d':
      case '\u001e':
      case '\u001f':
      case '\u2028':
      case '\u2029':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '*' && Character.getType(c) != Character.CONTROL) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("comment content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.NNCommentContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNNCommentContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if (')' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pNoNewlineComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyPredMatched = false;

          yyC = character(yyIndex);
          if (')' == yyC) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("n n comment content expected", yyStart);
          }
        }
        break;

      case '\t':
      case '\u000b':
      case '\f':
      case '\u001c':
      case '\u001d':
      case '\u001e':
      case '\u001f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '*' && c != '\n' && c != '\r' && Character.getType(c) != Character.CONTROL) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("n n comment content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.w.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pw(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.wr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.s.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ps(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpacing$Space(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.sr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing$sr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pSpacing$Space(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.nl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnl(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSpacing$Newline(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.br.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pSpacing$Newline(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if (';' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyResult = pw(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\";\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.WhitespaceString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhitespaceString(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing$Space(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = " ";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSpacing$Newline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "\n";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.hasW.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result phasW(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Boolean      yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pWhitespaceString(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for a1s.
      Pair<String> a1s = yyRepValue1.reverse();

      if ( a1s == null || a1s.size() == 0 ) yyValue = false;
      else                                  yyValue = true;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for a1s.
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.RectSeparator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRectSeparator(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    boolean      yyRepeated1;
    Pair<String> yyRepValue1;
    Integer      yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pw(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<String> a1s = yyRepValue1.reverse();

      yyResult = pw(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = a1s.size() + 1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pnl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = 2;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pSpacing$sr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = 1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.per.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pper(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("per expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("per expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.FORALL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFORALL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('F' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('O' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('R' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('A' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('L' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('L' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("FORALL expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("FORALL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.Zilch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pZilch(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('Z' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('c' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('h' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("zilch expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("zilch expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.absorbs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pabsorbs(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('b' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('b' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("absorbs expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("absorbs expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.also.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result palso(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("also expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("also expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.api.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result papi(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('p' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("api expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("api expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.asif.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pasif(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('f' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("asif expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("asif expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.at.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pat(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("at expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("at expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.bool.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbool(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('b' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("bool expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("bool expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.case.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcase(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("case expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("case expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.catch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcatch(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('c' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('h' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("catch expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("catch expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.coerce.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcoerce(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("coerce expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("coerce expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.coerces.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcoerces(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("coerces expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("coerces expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.component.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomponent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('o' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("component expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("component expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.comprises.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomprises(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('s' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("comprises expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("comprises expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.default.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdefault(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('f' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('u' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("default expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("default expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.dim.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdim(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("dim expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("dim expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.dominates.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdominates(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('s' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("dominates expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("dominates expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.elif.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pelif(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('f' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("elif expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("elif expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.else.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pelse(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("else expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("else expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.ensures.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pensures(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("ensures expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("ensures expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.except.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexcept(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("except expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("except expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.excludes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexcludes(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('u' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('s' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("excludes expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("excludes expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.exit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("exit expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("exit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.export.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexport(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("export expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("export expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.extends.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pextends(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("extends expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("extends expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.finally.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfinally(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('y' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("finally expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("finally expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.fn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfn(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("fn expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("fn expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.for.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfor(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("for expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("for expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.forbid.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pforbid(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('b' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("forbid expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("forbid expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.if.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pif(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("if expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("if expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pimport(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("import expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("import expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.int.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pint(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("int expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("int expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.invariant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pinvariant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('v' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('a' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("invariant expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("invariant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.label.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plabel(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('l' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('b' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("label expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("label expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.most.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmost(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('m' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("most expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("most expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.nat.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnat(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("nat expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("nat expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.object.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pobject(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('b' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('j' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("object expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("object expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.opr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('p' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("opr expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("opr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.or.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result por(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("or expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("or expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.property.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pproperty(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('y' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("property expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("property expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.provided.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pprovided(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('v' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('d' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("provided expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("provided expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.requires.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prequires(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('q' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('s' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("requires expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("requires expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.spawn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pspawn(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('p' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('w' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("spawn expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("spawn expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.then.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('n' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("then expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("then expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.throw.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthrow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('w' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("throw expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("throw expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.throws.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthrows(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('w' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("throws expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("throws expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.trait.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptrait(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("trait expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("trait expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.try.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptry(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('y' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("try expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("try expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.tryatomic.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptryatomic(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('y' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('o' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('m' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('i' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('c' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("tryatomic expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("tryatomic expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptype(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("type expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.typecase.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptypecase(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("typecase expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("typecase expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.typed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptyped(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('d' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("typed expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("typed expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.where.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwhere(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("where expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("where expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.while.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwhile(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("while expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("while expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.with.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwith(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('h' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("with expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("with expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.BIG.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBIG(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('B' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('I' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('G' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "BIG";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("BIG expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("BIG expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.Self.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelf(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('S' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('f' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = "Self";

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("self expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("self expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.abstract.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pabstract(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('b' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('c' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('t' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("abstract expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("abstract expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.atomic.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result patomic(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('c' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "atomic";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("atomic expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("atomic expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.do.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdo(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("do expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("do expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.end.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pend(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("end expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("end expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.getter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgetter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('g' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("getter expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("getter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.grammar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgrammar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('g' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('m' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('r' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("grammar expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("grammar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.hidden.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result phidden(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('h' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('d' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("hidden expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("hidden expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.in.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pin(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("in expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("in expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.io.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pio(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("io expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("io expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.native.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnative(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('v' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "native";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("native expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("native expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.of.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pof(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("of expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("of expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.override.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result poverride(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('v' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('d' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("override expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("override expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.private.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pprivate(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('v' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = "private";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("private expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("private expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.self.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pself(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('f' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = "self";

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("self expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("self expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.settable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psettable(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('b' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('l' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("settable expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("settable expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.setter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psetter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("setter expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("setter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.test.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptest(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("test expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("test expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.unit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result punit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = "unit";

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("unit expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("unit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.value.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pvalue(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("value expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("value expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.var.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pvar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("var expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("var expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.widens.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwidens(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "widens";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("widens expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("widens expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.wrapped.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwrapped(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('d' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("wrapped expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("wrapped expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.ParamList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParamList(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fParamList) 
      yyColumn.chunk26.fParamList = pParamList$1(yyStart);
    return yyColumn.chunk26.fParamList;
  }

  /** Actually parse Gaps.ParamList. */
  private Result pParamList$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pParamList$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> a2s = yyResult.semanticValue();

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = Useful.cons(a1, a2s.list());

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 2.

        yyResult = pParamList$$Plus2(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> a2s = yyResult.semanticValue();

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            log(createSpan(yyStart,yyCount), "Missing comma.");
            yyValue = Useful.cons(a1, a2s.list());

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 3.

        yyResult = pcloseparen(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = Useful.list(a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ParamList$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParamList$$Plus1(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fParamList$$Plus1) 
      yyColumn.chunk26.fParamList$$Plus1 = pParamList$$Plus1$1(yyStart);
    return yyColumn.chunk26.fParamList$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.ParamList$$Plus1. */
  private Result pParamList$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pId(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Id v$el$1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pParamList$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Id> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Id>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<Id>(v$el$1);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.templateparser.TemplateParser.ParamList$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParamList$$Plus2(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fParamList$$Plus2) 
      yyColumn.chunk26.fParamList$$Plus2 = pParamList$$Plus2$1(yyStart);
    return yyColumn.chunk26.fParamList$$Plus2;
  }

  /** Actually parse com.sun.fortress.parser.templateparser.TemplateParser.ParamList$$Plus2. */
  private Result pParamList$$Plus2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSymbol$commaOrNot(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pId(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Id v$el$3 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pParamList$$Plus2(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Id> v$4 = yyResult.semanticValue();

              yyValue = new Pair<Id>(v$el$3, v$4);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<Id>(v$el$3);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.prefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pprefix(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fprefix) 
      yyColumn.chunk26.fprefix = pprefix$1(yyStart);
    return yyColumn.chunk26.fprefix;
  }

  /** Actually parse Gaps.prefix. */
  private Result pprefix$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('@' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('#' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('$' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('%' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('^' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('&' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('*' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('<' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("prefix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.suffix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psuffix(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fsuffix) 
      yyColumn.chunk26.fsuffix = psuffix$1(yyStart);
    return yyColumn.chunk26.fsuffix;
  }

  /** Actually parse Gaps.suffix. */
  private Result psuffix$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('&' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('^' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('%' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('$' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('#' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('@' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('!' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('>' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("suffix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.ExprGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprGap(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fExprGap) 
      yyColumn.chunk27.fExprGap = pExprGap$1(yyStart);
    return yyColumn.chunk27.fExprGap;
  }

  /** Actually parse Gaps.ExprGap. */
  private Result pExprGap$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    List<Id>   yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('E' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('x' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pw(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pId(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Id a1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pParamList(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<Id> v$el$1 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$1;
                  }
                  { // Start scope for params.
                    List<Id> params = yyOpValue1;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = psuffix(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        if (params == null) params = new LinkedList<Id>();
                        yyValue = ExprFactory.makeTemplateGapExpr(createSpan(yyStart,yyCount), a1, params);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  } // End scope for params.
                }
              }
            } else {
              yyError = yyError.select("\"Expr\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"Expr\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"Expr\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"Expr\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.SimpleExprGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExprGap(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    List<Id>   yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('S' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('E' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('x' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('p' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('r' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyResult = pw(yyIndex);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pId(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Id a1 = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = null;

                              yyResult = pParamList(yyOption1);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {
                                List<Id> v$el$1 = yyResult.semanticValue();

                                yyOption1  = yyResult.index;
                                yyOpValue1 = v$el$1;
                              }
                              { // Start scope for params.
                                List<Id> params = yyOpValue1;

                                yyResult = pw(yyOption1);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyResult = psuffix(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    if (params == null) params = new LinkedList<Id>();
                                    yyValue = ExprFactory.makeTemplateGapSimpleExpr(createSpan(yyStart,yyCount), a1, params);

                                    return yyResult.createValue(yyValue, yyError);
                                  }
                                }
                              } // End scope for params.
                            }
                          }
                        } else {
                          yyError = yyError.select("\"SimpleExpr\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"SimpleExpr\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"SimpleExpr\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"SimpleExpr\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"SimpleExpr\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"SimpleExpr\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"SimpleExpr\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"SimpleExpr\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"SimpleExpr\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"SimpleExpr\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.PrimaryGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimaryGap(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    List<Id>   yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('P' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('m' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('r' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('y' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyResult = pw(yyIndex);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pId(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Id a1 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = null;

                        yyResult = pParamList(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          List<Id> v$el$1 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$1;
                        }
                        { // Start scope for params.
                          List<Id> params = yyOpValue1;

                          yyResult = pw(yyOption1);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = psuffix(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              if (params == null) params = new LinkedList<Id>();
                              yyValue = ExprFactory.makeTemplateGapPrimary(createSpan(yyStart,yyCount), a1, params);

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        } // End scope for params.
                      }
                    }
                  } else {
                    yyError = yyError.select("\"Primary\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"Primary\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"Primary\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"Primary\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"Primary\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"Primary\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"Primary\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.FnExprGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnExprGap(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fFnExprGap) 
      yyColumn.chunk27.fFnExprGap = pFnExprGap$1(yyStart);
    return yyColumn.chunk27.fFnExprGap;
  }

  /** Actually parse Gaps.FnExprGap. */
  private Result pFnExprGap$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    List<Id>   yyOpValue1;
    FnExpr     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('F' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('E' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('x' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('p' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('r' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pw(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pId(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Id a1 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pParamList(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        List<Id> v$el$1 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$1;
                      }
                      { // Start scope for params.
                        List<Id> params = yyOpValue1;

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = psuffix(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            if (params == null) params = new LinkedList<Id>();
                            yyValue = ExprFactory.makeTemplateGapFnExpr(createSpan(yyStart,yyCount), a1, params);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      } // End scope for params.
                    }
                  }
                } else {
                  yyError = yyError.select("\"FnExpr\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"FnExpr\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"FnExpr\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"FnExpr\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"FnExpr\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"FnExpr\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.LooseJuxtGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLooseJuxtGap(final int yyStart) throws IOException {
    TemplateParserColumn yyColumn = (TemplateParserColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fLooseJuxtGap) 
      yyColumn.chunk27.fLooseJuxtGap = pLooseJuxtGap$1(yyStart);
    return yyColumn.chunk27.fLooseJuxtGap;
  }

  /** Actually parse Gaps.LooseJuxtGap. */
  private Result pLooseJuxtGap$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    List<Id>   yyOpValue1;
    Juxt       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('L' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('s' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('J' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('u' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('x' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('t' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyResult = pw(yyIndex);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pId(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            Id a1 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;
                            yyOpValue1 = null;

                            yyResult = pParamList(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              List<Id> v$el$1 = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$1;
                            }
                            { // Start scope for params.
                              List<Id> params = yyOpValue1;

                              yyResult = pw(yyOption1);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = psuffix(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  if (params == null) params = new LinkedList<Id>();
                                  yyValue = ExprFactory.makeTemplateGapJuxt(createSpan(yyStart,yyCount), a1, params);

                                  return yyResult.createValue(yyValue, yyError);
                                }
                              }
                            } // End scope for params.
                          }
                        }
                      } else {
                        yyError = yyError.select("\"LooseJuxt\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"LooseJuxt\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"LooseJuxt\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"LooseJuxt\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"LooseJuxt\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"LooseJuxt\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"LooseJuxt\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"LooseJuxt\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"LooseJuxt\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.BindIdOrBindIdTupleGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindIdOrBindIdTupleGap(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    List<Id>   yyOpValue1;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('L' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('<' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('I' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('d' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('>' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyResult = pw(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pId(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Id a1 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = null;

                          yyResult = pParamList(yyOption1);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            List<Id> v$el$1 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;
                            yyOpValue1 = v$el$1;
                          }
                          { // Start scope for params.
                            List<Id> params = yyOpValue1;

                            yyResult = pw(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = psuffix(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                if (params == null) params = new LinkedList<Id>();
                                TemplateGapId t = ExprFactory.makeTemplateGapId(createSpan(yyStart,yyCount), a1, params);
                                yyValue = Useful.list((Id)t);

                                return yyResult.createValue(yyValue, yyError);
                              }
                            }
                          } // End scope for params.
                        }
                      }
                    } else {
                      yyError = yyError.select("\"List<Id>\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"List<Id>\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"List<Id>\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"List<Id>\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"List<Id>\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"List<Id>\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"List<Id>\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"List<Id>\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.NameGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNameGap(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    List<Id>   yyOpValue1;
    Name       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('N' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pw(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pId(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Id a1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pParamList(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<Id> v$el$1 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$1;
                  }
                  { // Start scope for params.
                    List<Id> params = yyOpValue1;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = psuffix(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        if (params == null) params = new LinkedList<Id>();
                        yyValue = ExprFactory.makeTemplateGapName(createSpan(yyStart,yyCount), a1, params);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  } // End scope for params.
                }
              }
            } else {
              yyError = yyError.select("\"Name\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"Name\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"Name\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"Name\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.IdGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdGap(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    List<Id>   yyOpValue1;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('I' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pw(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pParamList(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Id> v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
              { // Start scope for params.
                List<Id> params = yyOpValue1;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = psuffix(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    final int yyChoice1 = yyResult.index;

                    // Nested alternative 1.

                    yyResult = pw(yyChoice1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pDoubleStar(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        if (params == null) params = new LinkedList<Id>();
                        /* yyValue = ExprFactory.makeTemplateGapId(createSpan(yyStart,yyCount), a1, params); */
                        yyValue = new _EllipsesId(NodeFactory.makeSpanInfo(createSpan(yyStart, yyCount)),
                        ExprFactory.makeTemplateGapId(createSpan(yyStart,yyCount), a1, params));

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }

                    // Nested alternative 2.

                    if (params == null) params = new LinkedList<Id>();
                    /* yyValue = ExprFactory.makeTemplateGapId(createSpan(yyStart,yyCount), a1, params); */
                    yyValue = ExprFactory.makeTemplateGapId(createSpan(yyStart,yyCount), a1, params);

                    return new SemanticValue(yyValue, yyChoice1, yyError);
                  }
                }
              } // End scope for params.
            }
          }
        } else {
          yyError = yyError.select("\"Id\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"Id\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.LiteralExprGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteralExprGap(final int yyStart) throws IOException {
    int         yyC;
    int         yyIndex;
    Result      yyResult;
    int         yyBase;
    int         yyOption1;
    List<Id>    yyOpValue1;
    LiteralExpr yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('L' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('a' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('l' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('E' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('x' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('p' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('r' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyResult = pw(yyIndex);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pId(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {
                                Id a1 = yyResult.semanticValue();

                                yyOption1  = yyResult.index;
                                yyOpValue1 = null;

                                yyResult = pParamList(yyOption1);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  List<Id> v$el$1 = yyResult.semanticValue();

                                  yyOption1  = yyResult.index;
                                  yyOpValue1 = v$el$1;
                                }
                                { // Start scope for params.
                                  List<Id> params = yyOpValue1;

                                  yyResult = pw(yyOption1);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = psuffix(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {

                                      if (params == null) params = new LinkedList<Id>();
                                      yyValue = ExprFactory.makeTemplateGapNumberLiteralExpr(createSpan(yyStart,yyCount), a1, params);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                } // End scope for params.
                              }
                            }
                          } else {
                            yyError = yyError.select("\"LiteralExpr\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"LiteralExpr\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"LiteralExpr\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"LiteralExpr\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"LiteralExpr\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"LiteralExpr\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"LiteralExpr\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"LiteralExpr\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"LiteralExpr\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"LiteralExpr\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"LiteralExpr\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.NumberLiteralExprGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumberLiteralExprGap(final int yyStart) throws IOException {
    int               yyC;
    int               yyIndex;
    Result            yyResult;
    int               yyBase;
    int               yyOption1;
    List<Id>          yyOpValue1;
    NumberLiteralExpr yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('N' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('b' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('r' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('L' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('i' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('t' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('r' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('a' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('l' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyC = character(yyIndex);
                                if ('E' == yyC) {
                                  yyIndex = yyIndex + 1;

                                  yyC = character(yyIndex);
                                  if ('x' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyC = character(yyIndex);
                                    if ('p' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyC = character(yyIndex);
                                      if ('r' == yyC) {
                                        yyIndex = yyIndex + 1;

                                        yyResult = pw(yyIndex);
                                        yyError  = yyResult.select(yyError);
                                        if (yyResult.hasValue()) {

                                          yyResult = pId(yyResult.index);
                                          yyError  = yyResult.select(yyError);
                                          if (yyResult.hasValue()) {
                                            Id a1 = yyResult.semanticValue();

                                            yyOption1  = yyResult.index;
                                            yyOpValue1 = null;

                                            yyResult = pParamList(yyOption1);
                                            yyError  = 
                                              yyResult.select(yyError);
                                            if (yyResult.hasValue()) {
                                              List<Id> v$el$1 = yyResult.semanticValue();

                                              yyOption1  = yyResult.index;
                                              yyOpValue1 = v$el$1;
                                            }
                                            { // Start scope for params.
                                              List<Id> params = yyOpValue1;

                                              yyResult = pw(yyOption1);
                                              yyError  = 
                                                yyResult.select(yyError);
                                              if (yyResult.hasValue()) {

                                                yyResult = 
                                                  psuffix(yyResult.index);
                                                yyError  = 
                                                  yyResult.select(yyError);
                                                if (yyResult.hasValue()) {

                                                  if (params == null) params = new LinkedList<Id>();
                                                  yyValue = ExprFactory.makeTemplateGapNumberLiteralExpr(createSpan(yyStart,yyCount), a1, params);

                                                  return yyResult.createValue(yyValue, yyError);
                                                }
                                              }
                                            } // End scope for params.
                                          }
                                        }
                                      } else {
                                        yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                                      }
                                    } else {
                                      yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                                }
                              } else {
                                yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"NumberLiteralExpr\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.IntLiteralExprGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntLiteralExprGap(final int yyStart) throws IOException {
    int            yyC;
    int            yyIndex;
    Result         yyResult;
    int            yyBase;
    int            yyOption1;
    List<Id>       yyOpValue1;
    IntLiteralExpr yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('I' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('L' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('r' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('a' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('l' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('E' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('x' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('p' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyC = character(yyIndex);
                                if ('r' == yyC) {
                                  yyIndex = yyIndex + 1;

                                  yyResult = pw(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pId(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Id a1 = yyResult.semanticValue();

                                      yyOption1  = yyResult.index;
                                      yyOpValue1 = null;

                                      yyResult = pParamList(yyOption1);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {
                                        List<Id> v$el$1 = yyResult.semanticValue();

                                        yyOption1  = yyResult.index;
                                        yyOpValue1 = v$el$1;
                                      }
                                      { // Start scope for params.
                                        List<Id> params = yyOpValue1;

                                        yyResult = pw(yyOption1);
                                        yyError  = yyResult.select(yyError);
                                        if (yyResult.hasValue()) {

                                          yyResult = psuffix(yyResult.index);
                                          yyError  = yyResult.select(yyError);
                                          if (yyResult.hasValue()) {

                                            if (params == null) params = new LinkedList<Id>();
                                            yyValue = ExprFactory.makeTemplateGapIntLiteralExpr(createSpan(yyStart,yyCount), a1, params);

                                            return yyResult.createValue(yyValue, yyError);
                                          }
                                        }
                                      } // End scope for params.
                                    }
                                  }
                                } else {
                                  yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
                                }
                              } else {
                                yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"IntLiteralExpr\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.CharLiteralExprGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharLiteralExprGap(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    Result          yyResult;
    int             yyBase;
    int             yyOption1;
    List<Id>        yyOpValue1;
    CharLiteralExpr yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('C' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('h' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('L' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('t' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('e' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('r' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('a' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('l' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('E' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('x' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyC = character(yyIndex);
                                if ('p' == yyC) {
                                  yyIndex = yyIndex + 1;

                                  yyC = character(yyIndex);
                                  if ('r' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyResult = pw(yyIndex);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {

                                      yyResult = pId(yyResult.index);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {
                                        Id a1 = yyResult.semanticValue();

                                        yyOption1  = yyResult.index;
                                        yyOpValue1 = null;

                                        yyResult = pParamList(yyOption1);
                                        yyError  = yyResult.select(yyError);
                                        if (yyResult.hasValue()) {
                                          List<Id> v$el$1 = yyResult.semanticValue();

                                          yyOption1  = yyResult.index;
                                          yyOpValue1 = v$el$1;
                                        }
                                        { // Start scope for params.
                                          List<Id> params = yyOpValue1;

                                          yyResult = pw(yyOption1);
                                          yyError  = yyResult.select(yyError);
                                          if (yyResult.hasValue()) {

                                            yyResult = 
                                              psuffix(yyResult.index);
                                            yyError  = 
                                              yyResult.select(yyError);
                                            if (yyResult.hasValue()) {

                                              if (params == null) params = new LinkedList<Id>();
                                              yyValue = ExprFactory.makeTemplateGapCharLiteralExpr(createSpan(yyStart,yyCount), a1, params);

                                              return yyResult.createValue(yyValue, yyError);
                                            }
                                          }
                                        } // End scope for params.
                                      }
                                    }
                                  } else {
                                    yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
                                }
                              } else {
                                yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"CharLiteralExpr\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.StringLiteralExprGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralExprGap(final int yyStart) throws IOException {
    int               yyC;
    int               yyIndex;
    Result            yyResult;
    int               yyBase;
    int               yyOption1;
    List<Id>          yyOpValue1;
    StringLiteralExpr yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('S' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('g' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('L' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('i' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('t' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('r' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('a' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('l' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyC = character(yyIndex);
                                if ('E' == yyC) {
                                  yyIndex = yyIndex + 1;

                                  yyC = character(yyIndex);
                                  if ('x' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyC = character(yyIndex);
                                    if ('p' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyC = character(yyIndex);
                                      if ('r' == yyC) {
                                        yyIndex = yyIndex + 1;

                                        yyResult = pw(yyIndex);
                                        yyError  = yyResult.select(yyError);
                                        if (yyResult.hasValue()) {

                                          yyResult = pId(yyResult.index);
                                          yyError  = yyResult.select(yyError);
                                          if (yyResult.hasValue()) {
                                            Id a1 = yyResult.semanticValue();

                                            yyOption1  = yyResult.index;
                                            yyOpValue1 = null;

                                            yyResult = pParamList(yyOption1);
                                            yyError  = 
                                              yyResult.select(yyError);
                                            if (yyResult.hasValue()) {
                                              List<Id> v$el$1 = yyResult.semanticValue();

                                              yyOption1  = yyResult.index;
                                              yyOpValue1 = v$el$1;
                                            }
                                            { // Start scope for params.
                                              List<Id> params = yyOpValue1;

                                              yyResult = pw(yyOption1);
                                              yyError  = 
                                                yyResult.select(yyError);
                                              if (yyResult.hasValue()) {

                                                yyResult = 
                                                  psuffix(yyResult.index);
                                                yyError  = 
                                                  yyResult.select(yyError);
                                                if (yyResult.hasValue()) {

                                                  if (params == null) params = new LinkedList<Id>();
                                                  yyValue = ExprFactory.makeTemplateGapStringLiteralExpr(createSpan(yyStart,yyCount), a1, params);

                                                  return yyResult.createValue(yyValue, yyError);
                                                }
                                              }
                                            } // End scope for params.
                                          }
                                        }
                                      } else {
                                        yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                                      }
                                    } else {
                                      yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                                }
                              } else {
                                yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"StringLiteralExpr\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Gaps.VoidLiteralExprGap.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVoidLiteralExprGap(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    Result          yyResult;
    int             yyBase;
    int             yyOption1;
    List<Id>        yyOpValue1;
    VoidLiteralExpr yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative <GAP>.

    yyResult = pprefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('V' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('d' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pw(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pId(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Id a1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pParamList(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<Id> v$el$1 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$1;
                  }
                  { // Start scope for params.
                    List<Id> params = yyOpValue1;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = psuffix(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        if (params == null) params = new LinkedList<Id>();
                        yyValue = ExprFactory.makeTemplateGapVoidLiteralExpr(createSpan(yyStart,yyCount), a1, params);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  } // End scope for params.
                }
              }
            } else {
              yyError = yyError.select("\"Void\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"Void\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"Void\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"Void\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /*
  * Set expectedName when parsing a file that should contain
  * exactly one API or Component, and set it to the expected name
  * of the API/Component (usually based on the file name).
  * If expectedName is none (the default), then no name check is
  * performed.
  */
  protected Option<APIName> expectedName = Option.<APIName>none();
  public Option<APIName> getExpectedName() {
    return expectedName;
  }
  public void setExpectedName(Option<APIName> expectedName) {
    if (expectedName == null) {
      throw new IllegalArgumentException("expected name must not be null");
    }
    this.expectedName = expectedName;
  }
  public void setExpectedName(APIName expectedName) {
    setExpectedName(Option.wrap(expectedName));
  }
  
  Span createSpan(int start, int end) {
    int i = end-2;
    while ( i >= 0 && yyData[i] == ' ' ) { i--; }
    if ( i-1 >= start )
    end = i-1;
    else
    end = start;
    Column s = column(start);
    Column e = column(end);
    SourceLocRats slStart = new SourceLocRats(s.file, s.line, s.column, start);
    SourceLocRats slEnd   = new SourceLocRats(e.file, e.line, e.column, end);
    return new Span(slStart, slEnd);
  }
  
  private SpanInfo makeSpanInfo(int start, int end) {
    return NodeFactory.makeSpanInfo(createSpan(start, end));
  }
  
  private BufferedWriter writer = getWriter();
  private BufferedWriter getWriter() {
    try {
      return Useful.filenameToBufferedWriter( ProjectProperties.macroErrorLog(column(0).file) );
    } catch (IOException error) {
      return error("Creating a log file for the parser failed!");
    }
  }
  private void log(Span span, String message) {}
  static {
    add(FORTRESS_SYNTAX_SPECIAL_SYMBOLS, new String[] {
      "AND",    "BACKSPACE",    "FORMFEED",    "NEWLINE",
      "NOT",    "RETURN",       "TAB",         "SPACE",
      "<\\[",   "without",      "=>"
    });
    
    add(FORTRESS_SYNTAX_SPECIAL_CHARS, new String[] {
      "#",      ":",      "`",      "\\+",    "\\?",    "\\*",
      "\\[",    "\\]",    "\\|",    "\\_",    "\\{",    "\\}"
    });
  }
  static {
    add(FORTRESS_KEYWORDS, new String[] {
      "FORALL",
      "Zilch",
      
      "goto",         "idiom",        "public",       "pure",
      "reciprocal",   "static",
      
      "BIG",          "Self",         "SI_unit",      "absorbs",
      "abstract",     "also",         "api",          "asif",
      "at",           "atomic",       "bool",         "case",
      "catch",        "coerce",       "coerces",      "component",
      "comprises",    "contravariant","covariant",
      "default",      "dim",          "do",           "dominates",
      "elif",         "else",         "end",          "ensures",
      "except",       "excludes",     "exit",         "export",
      "extends",      "finally",      "fn",           "for",
      "forbid",       "getter",       "grammar",      "hidden",
      "if",           "import",       "int",
      "invariant",    "io",           "label",        "most",
      "nat",          "native",       "object",       "of",
      "opr",          "or",           "override",
      "private",      "property",     "provided",     "requires",
      "self",         "settable",     "setter",       "spawn",
      "syntax",       "test",         "then",         "throw",
      "throws",       "trait",        "try",          "tryatomic",
      "type",         "typecase",     "typed",        "unit",
      "value",        "var",          "where",        "while",
      "widens",       "with",         "wrapped",
      "true",         "false"
    });
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
